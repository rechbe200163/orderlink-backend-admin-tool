
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model CustomerHistory
 * 
 */
export type CustomerHistory = $Result.DefaultSelection<Prisma.$CustomerHistoryPayload>
/**
 * Model Cart
 * 
 */
export type Cart = $Result.DefaultSelection<Prisma.$CartPayload>
/**
 * Model Address
 * 
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductHistory
 * 
 */
export type ProductHistory = $Result.DefaultSelection<Prisma.$ProductHistoryPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Order
 * *
 *  * Order
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model Invoice
 * *
 *  * Invoice
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model Route
 * *
 *  * Route
 */
export type Route = $Result.DefaultSelection<Prisma.$RoutePayload>
/**
 * Model Employees
 * *
 *  * Employees
 */
export type Employees = $Result.DefaultSelection<Prisma.$EmployeesPayload>
/**
 * Model SiteConfig
 * *
 *  * SiteConfig
 */
export type SiteConfig = $Result.DefaultSelection<Prisma.$SiteConfigPayload>
/**
 * Model Action
 * 
 */
export type Action = $Result.DefaultSelection<Prisma.$ActionPayload>
/**
 * Model Ressource
 * 
 */
export type Ressource = $Result.DefaultSelection<Prisma.$RessourcePayload>
/**
 * Model ResourceAction
 * 
 */
export type ResourceAction = $Result.DefaultSelection<Prisma.$ResourceActionPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model CartOnProducts
 * 
 */
export type CartOnProducts = $Result.DefaultSelection<Prisma.$CartOnProductsPayload>
/**
 * Model OrderOnProducts
 * 
 */
export type OrderOnProducts = $Result.DefaultSelection<Prisma.$OrderOnProductsPayload>
/**
 * Model RoutesOnOrders
 * 
 */
export type RoutesOnOrders = $Result.DefaultSelection<Prisma.$RoutesOnOrdersPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Actions: {
  READ: 'READ',
  DELETE: 'DELETE',
  UPDATE: 'UPDATE',
  CREATE: 'CREATE'
};

export type Actions = (typeof Actions)[keyof typeof Actions]


export const Ressources: {
  PRODUCT: 'PRODUCT',
  ORDER: 'ORDER',
  CUSTOMER: 'CUSTOMER',
  CART: 'CART',
  ADDRESS: 'ADDRESS',
  INVOICE: 'INVOICE',
  EMPLOYEE: 'EMPLOYEE',
  ROLE: 'ROLE',
  ROUTES: 'ROUTES',
  SITE_CONFIG: 'SITE_CONFIG',
  CATEGORY: 'CATEGORY',
  ACTION: 'ACTION',
  PERMISSION: 'PERMISSION',
  STATISTICS: 'STATISTICS'
};

export type Ressources = (typeof Ressources)[keyof typeof Ressources]


export const OrderState: {
  ORDER_PLACED: 'ORDER_PLACED',
  IN_PROGRESS: 'IN_PROGRESS',
  DISPATCHED: 'DISPATCHED',
  DELIVERED: 'DELIVERED',
  ORDER_COLLECTED: 'ORDER_COLLECTED'
};

export type OrderState = (typeof OrderState)[keyof typeof OrderState]


export const BusinessSector: {
  AGRICULTURE: 'AGRICULTURE',
  CONSTRUCTION: 'CONSTRUCTION',
  EDUCATION: 'EDUCATION',
  FINANCE: 'FINANCE',
  HEALTH: 'HEALTH',
  HOSPITALITY: 'HOSPITALITY',
  IT: 'IT',
  MANUFACTURING: 'MANUFACTURING',
  OTHER: 'OTHER',
  RETAIL: 'RETAIL',
  TECHNOLOGY: 'TECHNOLOGY',
  TOURISM: 'TOURISM',
  TRANSPORTATION: 'TRANSPORTATION'
};

export type BusinessSector = (typeof BusinessSector)[keyof typeof BusinessSector]

}

export type Actions = $Enums.Actions

export const Actions: typeof $Enums.Actions

export type Ressources = $Enums.Ressources

export const Ressources: typeof $Enums.Ressources

export type OrderState = $Enums.OrderState

export const OrderState: typeof $Enums.OrderState

export type BusinessSector = $Enums.BusinessSector

export const BusinessSector: typeof $Enums.BusinessSector

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Customers
 * const customers = await prisma.customer.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Customers
   * const customers = await prisma.customer.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerHistory`: Exposes CRUD operations for the **CustomerHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerHistories
    * const customerHistories = await prisma.customerHistory.findMany()
    * ```
    */
  get customerHistory(): Prisma.CustomerHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cart`: Exposes CRUD operations for the **Cart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carts
    * const carts = await prisma.cart.findMany()
    * ```
    */
  get cart(): Prisma.CartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productHistory`: Exposes CRUD operations for the **ProductHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductHistories
    * const productHistories = await prisma.productHistory.findMany()
    * ```
    */
  get productHistory(): Prisma.ProductHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.route`: Exposes CRUD operations for the **Route** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Routes
    * const routes = await prisma.route.findMany()
    * ```
    */
  get route(): Prisma.RouteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employees`: Exposes CRUD operations for the **Employees** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employees.findMany()
    * ```
    */
  get employees(): Prisma.EmployeesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.siteConfig`: Exposes CRUD operations for the **SiteConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SiteConfigs
    * const siteConfigs = await prisma.siteConfig.findMany()
    * ```
    */
  get siteConfig(): Prisma.SiteConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.action`: Exposes CRUD operations for the **Action** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Actions
    * const actions = await prisma.action.findMany()
    * ```
    */
  get action(): Prisma.ActionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ressource`: Exposes CRUD operations for the **Ressource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ressources
    * const ressources = await prisma.ressource.findMany()
    * ```
    */
  get ressource(): Prisma.RessourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resourceAction`: Exposes CRUD operations for the **ResourceAction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResourceActions
    * const resourceActions = await prisma.resourceAction.findMany()
    * ```
    */
  get resourceAction(): Prisma.ResourceActionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cartOnProducts`: Exposes CRUD operations for the **CartOnProducts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CartOnProducts
    * const cartOnProducts = await prisma.cartOnProducts.findMany()
    * ```
    */
  get cartOnProducts(): Prisma.CartOnProductsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderOnProducts`: Exposes CRUD operations for the **OrderOnProducts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderOnProducts
    * const orderOnProducts = await prisma.orderOnProducts.findMany()
    * ```
    */
  get orderOnProducts(): Prisma.OrderOnProductsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.routesOnOrders`: Exposes CRUD operations for the **RoutesOnOrders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoutesOnOrders
    * const routesOnOrders = await prisma.routesOnOrders.findMany()
    * ```
    */
  get routesOnOrders(): Prisma.RoutesOnOrdersDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.1
   * Query Engine version: f40f79ec31188888a2e33acda0ecc8fd10a853a9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Customer: 'Customer',
    CustomerHistory: 'CustomerHistory',
    Cart: 'Cart',
    Address: 'Address',
    Product: 'Product',
    ProductHistory: 'ProductHistory',
    Category: 'Category',
    Order: 'Order',
    Invoice: 'Invoice',
    Route: 'Route',
    Employees: 'Employees',
    SiteConfig: 'SiteConfig',
    Action: 'Action',
    Ressource: 'Ressource',
    ResourceAction: 'ResourceAction',
    Role: 'Role',
    Permission: 'Permission',
    CartOnProducts: 'CartOnProducts',
    OrderOnProducts: 'OrderOnProducts',
    RoutesOnOrders: 'RoutesOnOrders'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "customer" | "customerHistory" | "cart" | "address" | "product" | "productHistory" | "category" | "order" | "invoice" | "route" | "employees" | "siteConfig" | "action" | "ressource" | "resourceAction" | "role" | "permission" | "cartOnProducts" | "orderOnProducts" | "routesOnOrders"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      CustomerHistory: {
        payload: Prisma.$CustomerHistoryPayload<ExtArgs>
        fields: Prisma.CustomerHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerHistoryPayload>
          }
          findFirst: {
            args: Prisma.CustomerHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerHistoryPayload>
          }
          findMany: {
            args: Prisma.CustomerHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerHistoryPayload>[]
          }
          create: {
            args: Prisma.CustomerHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerHistoryPayload>
          }
          createMany: {
            args: Prisma.CustomerHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerHistoryPayload>[]
          }
          delete: {
            args: Prisma.CustomerHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerHistoryPayload>
          }
          update: {
            args: Prisma.CustomerHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerHistoryPayload>
          }
          deleteMany: {
            args: Prisma.CustomerHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerHistoryPayload>[]
          }
          upsert: {
            args: Prisma.CustomerHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerHistoryPayload>
          }
          aggregate: {
            args: Prisma.CustomerHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerHistory>
          }
          groupBy: {
            args: Prisma.CustomerHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerHistoryCountAggregateOutputType> | number
          }
        }
      }
      Cart: {
        payload: Prisma.$CartPayload<ExtArgs>
        fields: Prisma.CartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          findFirst: {
            args: Prisma.CartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          findMany: {
            args: Prisma.CartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          create: {
            args: Prisma.CartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          createMany: {
            args: Prisma.CartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CartCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          delete: {
            args: Prisma.CartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          update: {
            args: Prisma.CartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          deleteMany: {
            args: Prisma.CartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CartUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          upsert: {
            args: Prisma.CartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          aggregate: {
            args: Prisma.CartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCart>
          }
          groupBy: {
            args: Prisma.CartGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartCountArgs<ExtArgs>
            result: $Utils.Optional<CartCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductHistory: {
        payload: Prisma.$ProductHistoryPayload<ExtArgs>
        fields: Prisma.ProductHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductHistoryPayload>
          }
          findFirst: {
            args: Prisma.ProductHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductHistoryPayload>
          }
          findMany: {
            args: Prisma.ProductHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductHistoryPayload>[]
          }
          create: {
            args: Prisma.ProductHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductHistoryPayload>
          }
          createMany: {
            args: Prisma.ProductHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductHistoryPayload>[]
          }
          delete: {
            args: Prisma.ProductHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductHistoryPayload>
          }
          update: {
            args: Prisma.ProductHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductHistoryPayload>
          }
          deleteMany: {
            args: Prisma.ProductHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductHistoryPayload>[]
          }
          upsert: {
            args: Prisma.ProductHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductHistoryPayload>
          }
          aggregate: {
            args: Prisma.ProductHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductHistory>
          }
          groupBy: {
            args: Prisma.ProductHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductHistoryCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      Route: {
        payload: Prisma.$RoutePayload<ExtArgs>
        fields: Prisma.RouteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RouteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RouteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          findFirst: {
            args: Prisma.RouteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RouteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          findMany: {
            args: Prisma.RouteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>[]
          }
          create: {
            args: Prisma.RouteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          createMany: {
            args: Prisma.RouteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RouteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>[]
          }
          delete: {
            args: Prisma.RouteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          update: {
            args: Prisma.RouteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          deleteMany: {
            args: Prisma.RouteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RouteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RouteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>[]
          }
          upsert: {
            args: Prisma.RouteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          aggregate: {
            args: Prisma.RouteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoute>
          }
          groupBy: {
            args: Prisma.RouteGroupByArgs<ExtArgs>
            result: $Utils.Optional<RouteGroupByOutputType>[]
          }
          count: {
            args: Prisma.RouteCountArgs<ExtArgs>
            result: $Utils.Optional<RouteCountAggregateOutputType> | number
          }
        }
      }
      Employees: {
        payload: Prisma.$EmployeesPayload<ExtArgs>
        fields: Prisma.EmployeesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>
          }
          findFirst: {
            args: Prisma.EmployeesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>
          }
          findMany: {
            args: Prisma.EmployeesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>[]
          }
          create: {
            args: Prisma.EmployeesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>
          }
          createMany: {
            args: Prisma.EmployeesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>[]
          }
          delete: {
            args: Prisma.EmployeesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>
          }
          update: {
            args: Prisma.EmployeesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>
          }
          deleteMany: {
            args: Prisma.EmployeesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>[]
          }
          upsert: {
            args: Prisma.EmployeesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeesPayload>
          }
          aggregate: {
            args: Prisma.EmployeesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployees>
          }
          groupBy: {
            args: Prisma.EmployeesGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeesGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeesCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeesCountAggregateOutputType> | number
          }
        }
      }
      SiteConfig: {
        payload: Prisma.$SiteConfigPayload<ExtArgs>
        fields: Prisma.SiteConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SiteConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SiteConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload>
          }
          findFirst: {
            args: Prisma.SiteConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SiteConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload>
          }
          findMany: {
            args: Prisma.SiteConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload>[]
          }
          create: {
            args: Prisma.SiteConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload>
          }
          createMany: {
            args: Prisma.SiteConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SiteConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload>[]
          }
          delete: {
            args: Prisma.SiteConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload>
          }
          update: {
            args: Prisma.SiteConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload>
          }
          deleteMany: {
            args: Prisma.SiteConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SiteConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SiteConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload>[]
          }
          upsert: {
            args: Prisma.SiteConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigPayload>
          }
          aggregate: {
            args: Prisma.SiteConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSiteConfig>
          }
          groupBy: {
            args: Prisma.SiteConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<SiteConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.SiteConfigCountArgs<ExtArgs>
            result: $Utils.Optional<SiteConfigCountAggregateOutputType> | number
          }
        }
      }
      Action: {
        payload: Prisma.$ActionPayload<ExtArgs>
        fields: Prisma.ActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          findFirst: {
            args: Prisma.ActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          findMany: {
            args: Prisma.ActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>[]
          }
          create: {
            args: Prisma.ActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          createMany: {
            args: Prisma.ActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>[]
          }
          delete: {
            args: Prisma.ActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          update: {
            args: Prisma.ActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          deleteMany: {
            args: Prisma.ActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>[]
          }
          upsert: {
            args: Prisma.ActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          aggregate: {
            args: Prisma.ActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAction>
          }
          groupBy: {
            args: Prisma.ActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActionCountArgs<ExtArgs>
            result: $Utils.Optional<ActionCountAggregateOutputType> | number
          }
        }
      }
      Ressource: {
        payload: Prisma.$RessourcePayload<ExtArgs>
        fields: Prisma.RessourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RessourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RessourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RessourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RessourcePayload>
          }
          findFirst: {
            args: Prisma.RessourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RessourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RessourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RessourcePayload>
          }
          findMany: {
            args: Prisma.RessourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RessourcePayload>[]
          }
          create: {
            args: Prisma.RessourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RessourcePayload>
          }
          createMany: {
            args: Prisma.RessourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RessourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RessourcePayload>[]
          }
          delete: {
            args: Prisma.RessourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RessourcePayload>
          }
          update: {
            args: Prisma.RessourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RessourcePayload>
          }
          deleteMany: {
            args: Prisma.RessourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RessourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RessourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RessourcePayload>[]
          }
          upsert: {
            args: Prisma.RessourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RessourcePayload>
          }
          aggregate: {
            args: Prisma.RessourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRessource>
          }
          groupBy: {
            args: Prisma.RessourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<RessourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.RessourceCountArgs<ExtArgs>
            result: $Utils.Optional<RessourceCountAggregateOutputType> | number
          }
        }
      }
      ResourceAction: {
        payload: Prisma.$ResourceActionPayload<ExtArgs>
        fields: Prisma.ResourceActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResourceActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResourceActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceActionPayload>
          }
          findFirst: {
            args: Prisma.ResourceActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResourceActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceActionPayload>
          }
          findMany: {
            args: Prisma.ResourceActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceActionPayload>[]
          }
          create: {
            args: Prisma.ResourceActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceActionPayload>
          }
          createMany: {
            args: Prisma.ResourceActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResourceActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceActionPayload>[]
          }
          delete: {
            args: Prisma.ResourceActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceActionPayload>
          }
          update: {
            args: Prisma.ResourceActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceActionPayload>
          }
          deleteMany: {
            args: Prisma.ResourceActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResourceActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResourceActionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceActionPayload>[]
          }
          upsert: {
            args: Prisma.ResourceActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceActionPayload>
          }
          aggregate: {
            args: Prisma.ResourceActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResourceAction>
          }
          groupBy: {
            args: Prisma.ResourceActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourceActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResourceActionCountArgs<ExtArgs>
            result: $Utils.Optional<ResourceActionCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      CartOnProducts: {
        payload: Prisma.$CartOnProductsPayload<ExtArgs>
        fields: Prisma.CartOnProductsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartOnProductsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartOnProductsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartOnProductsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartOnProductsPayload>
          }
          findFirst: {
            args: Prisma.CartOnProductsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartOnProductsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartOnProductsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartOnProductsPayload>
          }
          findMany: {
            args: Prisma.CartOnProductsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartOnProductsPayload>[]
          }
          create: {
            args: Prisma.CartOnProductsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartOnProductsPayload>
          }
          createMany: {
            args: Prisma.CartOnProductsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CartOnProductsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartOnProductsPayload>[]
          }
          delete: {
            args: Prisma.CartOnProductsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartOnProductsPayload>
          }
          update: {
            args: Prisma.CartOnProductsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartOnProductsPayload>
          }
          deleteMany: {
            args: Prisma.CartOnProductsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartOnProductsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CartOnProductsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartOnProductsPayload>[]
          }
          upsert: {
            args: Prisma.CartOnProductsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartOnProductsPayload>
          }
          aggregate: {
            args: Prisma.CartOnProductsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCartOnProducts>
          }
          groupBy: {
            args: Prisma.CartOnProductsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartOnProductsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartOnProductsCountArgs<ExtArgs>
            result: $Utils.Optional<CartOnProductsCountAggregateOutputType> | number
          }
        }
      }
      OrderOnProducts: {
        payload: Prisma.$OrderOnProductsPayload<ExtArgs>
        fields: Prisma.OrderOnProductsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderOnProductsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderOnProductsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderOnProductsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderOnProductsPayload>
          }
          findFirst: {
            args: Prisma.OrderOnProductsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderOnProductsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderOnProductsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderOnProductsPayload>
          }
          findMany: {
            args: Prisma.OrderOnProductsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderOnProductsPayload>[]
          }
          create: {
            args: Prisma.OrderOnProductsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderOnProductsPayload>
          }
          createMany: {
            args: Prisma.OrderOnProductsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderOnProductsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderOnProductsPayload>[]
          }
          delete: {
            args: Prisma.OrderOnProductsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderOnProductsPayload>
          }
          update: {
            args: Prisma.OrderOnProductsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderOnProductsPayload>
          }
          deleteMany: {
            args: Prisma.OrderOnProductsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderOnProductsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderOnProductsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderOnProductsPayload>[]
          }
          upsert: {
            args: Prisma.OrderOnProductsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderOnProductsPayload>
          }
          aggregate: {
            args: Prisma.OrderOnProductsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderOnProducts>
          }
          groupBy: {
            args: Prisma.OrderOnProductsGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderOnProductsGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderOnProductsCountArgs<ExtArgs>
            result: $Utils.Optional<OrderOnProductsCountAggregateOutputType> | number
          }
        }
      }
      RoutesOnOrders: {
        payload: Prisma.$RoutesOnOrdersPayload<ExtArgs>
        fields: Prisma.RoutesOnOrdersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoutesOnOrdersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutesOnOrdersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoutesOnOrdersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutesOnOrdersPayload>
          }
          findFirst: {
            args: Prisma.RoutesOnOrdersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutesOnOrdersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoutesOnOrdersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutesOnOrdersPayload>
          }
          findMany: {
            args: Prisma.RoutesOnOrdersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutesOnOrdersPayload>[]
          }
          create: {
            args: Prisma.RoutesOnOrdersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutesOnOrdersPayload>
          }
          createMany: {
            args: Prisma.RoutesOnOrdersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoutesOnOrdersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutesOnOrdersPayload>[]
          }
          delete: {
            args: Prisma.RoutesOnOrdersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutesOnOrdersPayload>
          }
          update: {
            args: Prisma.RoutesOnOrdersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutesOnOrdersPayload>
          }
          deleteMany: {
            args: Prisma.RoutesOnOrdersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoutesOnOrdersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoutesOnOrdersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutesOnOrdersPayload>[]
          }
          upsert: {
            args: Prisma.RoutesOnOrdersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutesOnOrdersPayload>
          }
          aggregate: {
            args: Prisma.RoutesOnOrdersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoutesOnOrders>
          }
          groupBy: {
            args: Prisma.RoutesOnOrdersGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoutesOnOrdersGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoutesOnOrdersCountArgs<ExtArgs>
            result: $Utils.Optional<RoutesOnOrdersCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    customer?: CustomerOmit
    customerHistory?: CustomerHistoryOmit
    cart?: CartOmit
    address?: AddressOmit
    product?: ProductOmit
    productHistory?: ProductHistoryOmit
    category?: CategoryOmit
    order?: OrderOmit
    invoice?: InvoiceOmit
    route?: RouteOmit
    employees?: EmployeesOmit
    siteConfig?: SiteConfigOmit
    action?: ActionOmit
    ressource?: RessourceOmit
    resourceAction?: ResourceActionOmit
    role?: RoleOmit
    permission?: PermissionOmit
    cartOnProducts?: CartOnProductsOmit
    orderOnProducts?: OrderOnProductsOmit
    routesOnOrders?: RoutesOnOrdersOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    orders: number
    history: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | CustomerCountOutputTypeCountOrdersArgs
    history?: boolean | CustomerCountOutputTypeCountHistoryArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerHistoryWhereInput
  }


  /**
   * Count Type CartCountOutputType
   */

  export type CartCountOutputType = {
    products: number
  }

  export type CartCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CartCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartCountOutputType
     */
    select?: CartCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartOnProductsWhereInput
  }


  /**
   * Count Type AddressCountOutputType
   */

  export type AddressCountOutputType = {
    customers: number
    siteConfig: number
  }

  export type AddressCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | AddressCountOutputTypeCountCustomersArgs
    siteConfig?: boolean | AddressCountOutputTypeCountSiteConfigArgs
  }

  // Custom InputTypes
  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressCountOutputType
     */
    select?: AddressCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }

  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeCountSiteConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteConfigWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    carts: number
    orders: number
    ProductHistory: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carts?: boolean | ProductCountOutputTypeCountCartsArgs
    orders?: boolean | ProductCountOutputTypeCountOrdersArgs
    ProductHistory?: boolean | ProductCountOutputTypeCountProductHistoryArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartOnProductsWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderOnProductsWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductHistoryWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    products: number
    ProductHistory: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
    ProductHistory?: boolean | CategoryCountOutputTypeCountProductHistoryArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductHistoryWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    products: number
    route: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | OrderCountOutputTypeCountProductsArgs
    route?: boolean | OrderCountOutputTypeCountRouteArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderOnProductsWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountRouteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoutesOnOrdersWhereInput
  }


  /**
   * Count Type RouteCountOutputType
   */

  export type RouteCountOutputType = {
    order: number
  }

  export type RouteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | RouteCountOutputTypeCountOrderArgs
  }

  // Custom InputTypes
  /**
   * RouteCountOutputType without action
   */
  export type RouteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteCountOutputType
     */
    select?: RouteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RouteCountOutputType without action
   */
  export type RouteCountOutputTypeCountOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoutesOnOrdersWhereInput
  }


  /**
   * Count Type ActionCountOutputType
   */

  export type ActionCountOutputType = {
    resourceLinks: number
  }

  export type ActionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resourceLinks?: boolean | ActionCountOutputTypeCountResourceLinksArgs
  }

  // Custom InputTypes
  /**
   * ActionCountOutputType without action
   */
  export type ActionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionCountOutputType
     */
    select?: ActionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActionCountOutputType without action
   */
  export type ActionCountOutputTypeCountResourceLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceActionWhereInput
  }


  /**
   * Count Type RessourceCountOutputType
   */

  export type RessourceCountOutputType = {
    actionLinks: number
  }

  export type RessourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actionLinks?: boolean | RessourceCountOutputTypeCountActionLinksArgs
  }

  // Custom InputTypes
  /**
   * RessourceCountOutputType without action
   */
  export type RessourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RessourceCountOutputType
     */
    select?: RessourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RessourceCountOutputType without action
   */
  export type RessourceCountOutputTypeCountActionLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceActionWhereInput
  }


  /**
   * Count Type ResourceActionCountOutputType
   */

  export type ResourceActionCountOutputType = {
    permissions: number
  }

  export type ResourceActionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | ResourceActionCountOutputTypeCountPermissionsArgs
  }

  // Custom InputTypes
  /**
   * ResourceActionCountOutputType without action
   */
  export type ResourceActionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceActionCountOutputType
     */
    select?: ResourceActionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResourceActionCountOutputType without action
   */
  export type ResourceActionCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    employees: number
    permissions: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | RoleCountOutputTypeCountEmployeesArgs
    permissions?: boolean | RoleCountOutputTypeCountPermissionsArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeesWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    customerReference: number | null
  }

  export type CustomerSumAggregateOutputType = {
    customerReference: number | null
  }

  export type CustomerMinAggregateOutputType = {
    customerId: string | null
    customerReference: number | null
    email: string | null
    phoneNumber: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    companyNumber: string | null
    modifiedAt: Date | null
    deleted: boolean | null
    signedUp: Date | null
    avatarPath: string | null
    addressId: string | null
    businessSector: $Enums.BusinessSector | null
  }

  export type CustomerMaxAggregateOutputType = {
    customerId: string | null
    customerReference: number | null
    email: string | null
    phoneNumber: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    companyNumber: string | null
    modifiedAt: Date | null
    deleted: boolean | null
    signedUp: Date | null
    avatarPath: string | null
    addressId: string | null
    businessSector: $Enums.BusinessSector | null
  }

  export type CustomerCountAggregateOutputType = {
    customerId: number
    customerReference: number
    email: number
    phoneNumber: number
    password: number
    firstName: number
    lastName: number
    companyNumber: number
    modifiedAt: number
    deleted: number
    signedUp: number
    avatarPath: number
    addressId: number
    businessSector: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    customerReference?: true
  }

  export type CustomerSumAggregateInputType = {
    customerReference?: true
  }

  export type CustomerMinAggregateInputType = {
    customerId?: true
    customerReference?: true
    email?: true
    phoneNumber?: true
    password?: true
    firstName?: true
    lastName?: true
    companyNumber?: true
    modifiedAt?: true
    deleted?: true
    signedUp?: true
    avatarPath?: true
    addressId?: true
    businessSector?: true
  }

  export type CustomerMaxAggregateInputType = {
    customerId?: true
    customerReference?: true
    email?: true
    phoneNumber?: true
    password?: true
    firstName?: true
    lastName?: true
    companyNumber?: true
    modifiedAt?: true
    deleted?: true
    signedUp?: true
    avatarPath?: true
    addressId?: true
    businessSector?: true
  }

  export type CustomerCountAggregateInputType = {
    customerId?: true
    customerReference?: true
    email?: true
    phoneNumber?: true
    password?: true
    firstName?: true
    lastName?: true
    companyNumber?: true
    modifiedAt?: true
    deleted?: true
    signedUp?: true
    avatarPath?: true
    addressId?: true
    businessSector?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    customerId: string
    customerReference: number
    email: string
    phoneNumber: string
    password: string
    firstName: string | null
    lastName: string
    companyNumber: string | null
    modifiedAt: Date | null
    deleted: boolean
    signedUp: Date
    avatarPath: string | null
    addressId: string
    businessSector: $Enums.BusinessSector | null
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    customerId?: boolean
    customerReference?: boolean
    email?: boolean
    phoneNumber?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    companyNumber?: boolean
    modifiedAt?: boolean
    deleted?: boolean
    signedUp?: boolean
    avatarPath?: boolean
    addressId?: boolean
    businessSector?: boolean
    address?: boolean | AddressDefaultArgs<ExtArgs>
    cart?: boolean | Customer$cartArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    history?: boolean | Customer$historyArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    customerId?: boolean
    customerReference?: boolean
    email?: boolean
    phoneNumber?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    companyNumber?: boolean
    modifiedAt?: boolean
    deleted?: boolean
    signedUp?: boolean
    avatarPath?: boolean
    addressId?: boolean
    businessSector?: boolean
    address?: boolean | AddressDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    customerId?: boolean
    customerReference?: boolean
    email?: boolean
    phoneNumber?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    companyNumber?: boolean
    modifiedAt?: boolean
    deleted?: boolean
    signedUp?: boolean
    avatarPath?: boolean
    addressId?: boolean
    businessSector?: boolean
    address?: boolean | AddressDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    customerId?: boolean
    customerReference?: boolean
    email?: boolean
    phoneNumber?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    companyNumber?: boolean
    modifiedAt?: boolean
    deleted?: boolean
    signedUp?: boolean
    avatarPath?: boolean
    addressId?: boolean
    businessSector?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"customerId" | "customerReference" | "email" | "phoneNumber" | "password" | "firstName" | "lastName" | "companyNumber" | "modifiedAt" | "deleted" | "signedUp" | "avatarPath" | "addressId" | "businessSector", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | AddressDefaultArgs<ExtArgs>
    cart?: boolean | Customer$cartArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    history?: boolean | Customer$historyArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | AddressDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | AddressDefaultArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      address: Prisma.$AddressPayload<ExtArgs>
      cart: Prisma.$CartPayload<ExtArgs> | null
      orders: Prisma.$OrderPayload<ExtArgs>[]
      history: Prisma.$CustomerHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      customerId: string
      customerReference: number
      email: string
      phoneNumber: string
      password: string
      firstName: string | null
      lastName: string
      companyNumber: string | null
      modifiedAt: Date | null
      deleted: boolean
      signedUp: Date
      avatarPath: string | null
      addressId: string
      businessSector: $Enums.BusinessSector | null
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `customerId`
     * const customerWithCustomerIdOnly = await prisma.customer.findMany({ select: { customerId: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `customerId`
     * const customerWithCustomerIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { customerId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `customerId`
     * const customerWithCustomerIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { customerId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    address<T extends AddressDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddressDefaultArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cart<T extends Customer$cartArgs<ExtArgs> = {}>(args?: Subset<T, Customer$cartArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    orders<T extends Customer$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    history<T extends Customer$historyArgs<ExtArgs> = {}>(args?: Subset<T, Customer$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly customerId: FieldRef<"Customer", 'String'>
    readonly customerReference: FieldRef<"Customer", 'Int'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly phoneNumber: FieldRef<"Customer", 'String'>
    readonly password: FieldRef<"Customer", 'String'>
    readonly firstName: FieldRef<"Customer", 'String'>
    readonly lastName: FieldRef<"Customer", 'String'>
    readonly companyNumber: FieldRef<"Customer", 'String'>
    readonly modifiedAt: FieldRef<"Customer", 'DateTime'>
    readonly deleted: FieldRef<"Customer", 'Boolean'>
    readonly signedUp: FieldRef<"Customer", 'DateTime'>
    readonly avatarPath: FieldRef<"Customer", 'String'>
    readonly addressId: FieldRef<"Customer", 'String'>
    readonly businessSector: FieldRef<"Customer", 'BusinessSector'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.cart
   */
  export type Customer$cartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    where?: CartWhereInput
  }

  /**
   * Customer.orders
   */
  export type Customer$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Customer.history
   */
  export type Customer$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerHistory
     */
    select?: CustomerHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerHistory
     */
    omit?: CustomerHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerHistoryInclude<ExtArgs> | null
    where?: CustomerHistoryWhereInput
    orderBy?: CustomerHistoryOrderByWithRelationInput | CustomerHistoryOrderByWithRelationInput[]
    cursor?: CustomerHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerHistoryScalarFieldEnum | CustomerHistoryScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model CustomerHistory
   */

  export type AggregateCustomerHistory = {
    _count: CustomerHistoryCountAggregateOutputType | null
    _avg: CustomerHistoryAvgAggregateOutputType | null
    _sum: CustomerHistorySumAggregateOutputType | null
    _min: CustomerHistoryMinAggregateOutputType | null
    _max: CustomerHistoryMaxAggregateOutputType | null
  }

  export type CustomerHistoryAvgAggregateOutputType = {
    customerReference: number | null
  }

  export type CustomerHistorySumAggregateOutputType = {
    customerReference: number | null
  }

  export type CustomerHistoryMinAggregateOutputType = {
    historyId: string | null
    customerReference: number | null
    email: string | null
    phoneNumber: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    companyNumber: string | null
    modifiedAt: Date | null
    deleted: boolean | null
    signedUp: Date | null
    avatarPath: string | null
    addressId: string | null
    businessSector: $Enums.BusinessSector | null
  }

  export type CustomerHistoryMaxAggregateOutputType = {
    historyId: string | null
    customerReference: number | null
    email: string | null
    phoneNumber: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    companyNumber: string | null
    modifiedAt: Date | null
    deleted: boolean | null
    signedUp: Date | null
    avatarPath: string | null
    addressId: string | null
    businessSector: $Enums.BusinessSector | null
  }

  export type CustomerHistoryCountAggregateOutputType = {
    historyId: number
    customerReference: number
    email: number
    phoneNumber: number
    password: number
    firstName: number
    lastName: number
    companyNumber: number
    modifiedAt: number
    deleted: number
    signedUp: number
    avatarPath: number
    addressId: number
    businessSector: number
    _all: number
  }


  export type CustomerHistoryAvgAggregateInputType = {
    customerReference?: true
  }

  export type CustomerHistorySumAggregateInputType = {
    customerReference?: true
  }

  export type CustomerHistoryMinAggregateInputType = {
    historyId?: true
    customerReference?: true
    email?: true
    phoneNumber?: true
    password?: true
    firstName?: true
    lastName?: true
    companyNumber?: true
    modifiedAt?: true
    deleted?: true
    signedUp?: true
    avatarPath?: true
    addressId?: true
    businessSector?: true
  }

  export type CustomerHistoryMaxAggregateInputType = {
    historyId?: true
    customerReference?: true
    email?: true
    phoneNumber?: true
    password?: true
    firstName?: true
    lastName?: true
    companyNumber?: true
    modifiedAt?: true
    deleted?: true
    signedUp?: true
    avatarPath?: true
    addressId?: true
    businessSector?: true
  }

  export type CustomerHistoryCountAggregateInputType = {
    historyId?: true
    customerReference?: true
    email?: true
    phoneNumber?: true
    password?: true
    firstName?: true
    lastName?: true
    companyNumber?: true
    modifiedAt?: true
    deleted?: true
    signedUp?: true
    avatarPath?: true
    addressId?: true
    businessSector?: true
    _all?: true
  }

  export type CustomerHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerHistory to aggregate.
     */
    where?: CustomerHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerHistories to fetch.
     */
    orderBy?: CustomerHistoryOrderByWithRelationInput | CustomerHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerHistories
    **/
    _count?: true | CustomerHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerHistoryMaxAggregateInputType
  }

  export type GetCustomerHistoryAggregateType<T extends CustomerHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerHistory[P]>
      : GetScalarType<T[P], AggregateCustomerHistory[P]>
  }




  export type CustomerHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerHistoryWhereInput
    orderBy?: CustomerHistoryOrderByWithAggregationInput | CustomerHistoryOrderByWithAggregationInput[]
    by: CustomerHistoryScalarFieldEnum[] | CustomerHistoryScalarFieldEnum
    having?: CustomerHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerHistoryCountAggregateInputType | true
    _avg?: CustomerHistoryAvgAggregateInputType
    _sum?: CustomerHistorySumAggregateInputType
    _min?: CustomerHistoryMinAggregateInputType
    _max?: CustomerHistoryMaxAggregateInputType
  }

  export type CustomerHistoryGroupByOutputType = {
    historyId: string
    customerReference: number
    email: string
    phoneNumber: string
    password: string
    firstName: string | null
    lastName: string
    companyNumber: string | null
    modifiedAt: Date | null
    deleted: boolean
    signedUp: Date
    avatarPath: string | null
    addressId: string
    businessSector: $Enums.BusinessSector | null
    _count: CustomerHistoryCountAggregateOutputType | null
    _avg: CustomerHistoryAvgAggregateOutputType | null
    _sum: CustomerHistorySumAggregateOutputType | null
    _min: CustomerHistoryMinAggregateOutputType | null
    _max: CustomerHistoryMaxAggregateOutputType | null
  }

  type GetCustomerHistoryGroupByPayload<T extends CustomerHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerHistoryGroupByOutputType[P]>
        }
      >
    >


  export type CustomerHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    historyId?: boolean
    customerReference?: boolean
    email?: boolean
    phoneNumber?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    companyNumber?: boolean
    modifiedAt?: boolean
    deleted?: boolean
    signedUp?: boolean
    avatarPath?: boolean
    addressId?: boolean
    businessSector?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerHistory"]>

  export type CustomerHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    historyId?: boolean
    customerReference?: boolean
    email?: boolean
    phoneNumber?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    companyNumber?: boolean
    modifiedAt?: boolean
    deleted?: boolean
    signedUp?: boolean
    avatarPath?: boolean
    addressId?: boolean
    businessSector?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerHistory"]>

  export type CustomerHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    historyId?: boolean
    customerReference?: boolean
    email?: boolean
    phoneNumber?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    companyNumber?: boolean
    modifiedAt?: boolean
    deleted?: boolean
    signedUp?: boolean
    avatarPath?: boolean
    addressId?: boolean
    businessSector?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerHistory"]>

  export type CustomerHistorySelectScalar = {
    historyId?: boolean
    customerReference?: boolean
    email?: boolean
    phoneNumber?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    companyNumber?: boolean
    modifiedAt?: boolean
    deleted?: boolean
    signedUp?: boolean
    avatarPath?: boolean
    addressId?: boolean
    businessSector?: boolean
  }

  export type CustomerHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"historyId" | "customerReference" | "email" | "phoneNumber" | "password" | "firstName" | "lastName" | "companyNumber" | "modifiedAt" | "deleted" | "signedUp" | "avatarPath" | "addressId" | "businessSector", ExtArgs["result"]["customerHistory"]>
  export type CustomerHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $CustomerHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerHistory"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      historyId: string
      customerReference: number
      email: string
      phoneNumber: string
      password: string
      firstName: string | null
      lastName: string
      companyNumber: string | null
      modifiedAt: Date | null
      deleted: boolean
      signedUp: Date
      avatarPath: string | null
      addressId: string
      businessSector: $Enums.BusinessSector | null
    }, ExtArgs["result"]["customerHistory"]>
    composites: {}
  }

  type CustomerHistoryGetPayload<S extends boolean | null | undefined | CustomerHistoryDefaultArgs> = $Result.GetResult<Prisma.$CustomerHistoryPayload, S>

  type CustomerHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerHistoryCountAggregateInputType | true
    }

  export interface CustomerHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerHistory'], meta: { name: 'CustomerHistory' } }
    /**
     * Find zero or one CustomerHistory that matches the filter.
     * @param {CustomerHistoryFindUniqueArgs} args - Arguments to find a CustomerHistory
     * @example
     * // Get one CustomerHistory
     * const customerHistory = await prisma.customerHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerHistoryFindUniqueArgs>(args: SelectSubset<T, CustomerHistoryFindUniqueArgs<ExtArgs>>): Prisma__CustomerHistoryClient<$Result.GetResult<Prisma.$CustomerHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerHistoryFindUniqueOrThrowArgs} args - Arguments to find a CustomerHistory
     * @example
     * // Get one CustomerHistory
     * const customerHistory = await prisma.customerHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerHistoryClient<$Result.GetResult<Prisma.$CustomerHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerHistoryFindFirstArgs} args - Arguments to find a CustomerHistory
     * @example
     * // Get one CustomerHistory
     * const customerHistory = await prisma.customerHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerHistoryFindFirstArgs>(args?: SelectSubset<T, CustomerHistoryFindFirstArgs<ExtArgs>>): Prisma__CustomerHistoryClient<$Result.GetResult<Prisma.$CustomerHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerHistoryFindFirstOrThrowArgs} args - Arguments to find a CustomerHistory
     * @example
     * // Get one CustomerHistory
     * const customerHistory = await prisma.customerHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerHistoryClient<$Result.GetResult<Prisma.$CustomerHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerHistories
     * const customerHistories = await prisma.customerHistory.findMany()
     * 
     * // Get first 10 CustomerHistories
     * const customerHistories = await prisma.customerHistory.findMany({ take: 10 })
     * 
     * // Only select the `historyId`
     * const customerHistoryWithHistoryIdOnly = await prisma.customerHistory.findMany({ select: { historyId: true } })
     * 
     */
    findMany<T extends CustomerHistoryFindManyArgs>(args?: SelectSubset<T, CustomerHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerHistory.
     * @param {CustomerHistoryCreateArgs} args - Arguments to create a CustomerHistory.
     * @example
     * // Create one CustomerHistory
     * const CustomerHistory = await prisma.customerHistory.create({
     *   data: {
     *     // ... data to create a CustomerHistory
     *   }
     * })
     * 
     */
    create<T extends CustomerHistoryCreateArgs>(args: SelectSubset<T, CustomerHistoryCreateArgs<ExtArgs>>): Prisma__CustomerHistoryClient<$Result.GetResult<Prisma.$CustomerHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerHistories.
     * @param {CustomerHistoryCreateManyArgs} args - Arguments to create many CustomerHistories.
     * @example
     * // Create many CustomerHistories
     * const customerHistory = await prisma.customerHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerHistoryCreateManyArgs>(args?: SelectSubset<T, CustomerHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerHistories and returns the data saved in the database.
     * @param {CustomerHistoryCreateManyAndReturnArgs} args - Arguments to create many CustomerHistories.
     * @example
     * // Create many CustomerHistories
     * const customerHistory = await prisma.customerHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerHistories and only return the `historyId`
     * const customerHistoryWithHistoryIdOnly = await prisma.customerHistory.createManyAndReturn({
     *   select: { historyId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerHistory.
     * @param {CustomerHistoryDeleteArgs} args - Arguments to delete one CustomerHistory.
     * @example
     * // Delete one CustomerHistory
     * const CustomerHistory = await prisma.customerHistory.delete({
     *   where: {
     *     // ... filter to delete one CustomerHistory
     *   }
     * })
     * 
     */
    delete<T extends CustomerHistoryDeleteArgs>(args: SelectSubset<T, CustomerHistoryDeleteArgs<ExtArgs>>): Prisma__CustomerHistoryClient<$Result.GetResult<Prisma.$CustomerHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerHistory.
     * @param {CustomerHistoryUpdateArgs} args - Arguments to update one CustomerHistory.
     * @example
     * // Update one CustomerHistory
     * const customerHistory = await prisma.customerHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerHistoryUpdateArgs>(args: SelectSubset<T, CustomerHistoryUpdateArgs<ExtArgs>>): Prisma__CustomerHistoryClient<$Result.GetResult<Prisma.$CustomerHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerHistories.
     * @param {CustomerHistoryDeleteManyArgs} args - Arguments to filter CustomerHistories to delete.
     * @example
     * // Delete a few CustomerHistories
     * const { count } = await prisma.customerHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerHistoryDeleteManyArgs>(args?: SelectSubset<T, CustomerHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerHistories
     * const customerHistory = await prisma.customerHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerHistoryUpdateManyArgs>(args: SelectSubset<T, CustomerHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerHistories and returns the data updated in the database.
     * @param {CustomerHistoryUpdateManyAndReturnArgs} args - Arguments to update many CustomerHistories.
     * @example
     * // Update many CustomerHistories
     * const customerHistory = await prisma.customerHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerHistories and only return the `historyId`
     * const customerHistoryWithHistoryIdOnly = await prisma.customerHistory.updateManyAndReturn({
     *   select: { historyId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerHistory.
     * @param {CustomerHistoryUpsertArgs} args - Arguments to update or create a CustomerHistory.
     * @example
     * // Update or create a CustomerHistory
     * const customerHistory = await prisma.customerHistory.upsert({
     *   create: {
     *     // ... data to create a CustomerHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerHistory we want to update
     *   }
     * })
     */
    upsert<T extends CustomerHistoryUpsertArgs>(args: SelectSubset<T, CustomerHistoryUpsertArgs<ExtArgs>>): Prisma__CustomerHistoryClient<$Result.GetResult<Prisma.$CustomerHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerHistoryCountArgs} args - Arguments to filter CustomerHistories to count.
     * @example
     * // Count the number of CustomerHistories
     * const count = await prisma.customerHistory.count({
     *   where: {
     *     // ... the filter for the CustomerHistories we want to count
     *   }
     * })
    **/
    count<T extends CustomerHistoryCountArgs>(
      args?: Subset<T, CustomerHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerHistoryAggregateArgs>(args: Subset<T, CustomerHistoryAggregateArgs>): Prisma.PrismaPromise<GetCustomerHistoryAggregateType<T>>

    /**
     * Group by CustomerHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerHistoryGroupByArgs['orderBy'] }
        : { orderBy?: CustomerHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerHistory model
   */
  readonly fields: CustomerHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerHistory model
   */
  interface CustomerHistoryFieldRefs {
    readonly historyId: FieldRef<"CustomerHistory", 'String'>
    readonly customerReference: FieldRef<"CustomerHistory", 'Int'>
    readonly email: FieldRef<"CustomerHistory", 'String'>
    readonly phoneNumber: FieldRef<"CustomerHistory", 'String'>
    readonly password: FieldRef<"CustomerHistory", 'String'>
    readonly firstName: FieldRef<"CustomerHistory", 'String'>
    readonly lastName: FieldRef<"CustomerHistory", 'String'>
    readonly companyNumber: FieldRef<"CustomerHistory", 'String'>
    readonly modifiedAt: FieldRef<"CustomerHistory", 'DateTime'>
    readonly deleted: FieldRef<"CustomerHistory", 'Boolean'>
    readonly signedUp: FieldRef<"CustomerHistory", 'DateTime'>
    readonly avatarPath: FieldRef<"CustomerHistory", 'String'>
    readonly addressId: FieldRef<"CustomerHistory", 'String'>
    readonly businessSector: FieldRef<"CustomerHistory", 'BusinessSector'>
  }
    

  // Custom InputTypes
  /**
   * CustomerHistory findUnique
   */
  export type CustomerHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerHistory
     */
    select?: CustomerHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerHistory
     */
    omit?: CustomerHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CustomerHistory to fetch.
     */
    where: CustomerHistoryWhereUniqueInput
  }

  /**
   * CustomerHistory findUniqueOrThrow
   */
  export type CustomerHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerHistory
     */
    select?: CustomerHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerHistory
     */
    omit?: CustomerHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CustomerHistory to fetch.
     */
    where: CustomerHistoryWhereUniqueInput
  }

  /**
   * CustomerHistory findFirst
   */
  export type CustomerHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerHistory
     */
    select?: CustomerHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerHistory
     */
    omit?: CustomerHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CustomerHistory to fetch.
     */
    where?: CustomerHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerHistories to fetch.
     */
    orderBy?: CustomerHistoryOrderByWithRelationInput | CustomerHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerHistories.
     */
    cursor?: CustomerHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerHistories.
     */
    distinct?: CustomerHistoryScalarFieldEnum | CustomerHistoryScalarFieldEnum[]
  }

  /**
   * CustomerHistory findFirstOrThrow
   */
  export type CustomerHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerHistory
     */
    select?: CustomerHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerHistory
     */
    omit?: CustomerHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CustomerHistory to fetch.
     */
    where?: CustomerHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerHistories to fetch.
     */
    orderBy?: CustomerHistoryOrderByWithRelationInput | CustomerHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerHistories.
     */
    cursor?: CustomerHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerHistories.
     */
    distinct?: CustomerHistoryScalarFieldEnum | CustomerHistoryScalarFieldEnum[]
  }

  /**
   * CustomerHistory findMany
   */
  export type CustomerHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerHistory
     */
    select?: CustomerHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerHistory
     */
    omit?: CustomerHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CustomerHistories to fetch.
     */
    where?: CustomerHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerHistories to fetch.
     */
    orderBy?: CustomerHistoryOrderByWithRelationInput | CustomerHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerHistories.
     */
    cursor?: CustomerHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerHistories.
     */
    skip?: number
    distinct?: CustomerHistoryScalarFieldEnum | CustomerHistoryScalarFieldEnum[]
  }

  /**
   * CustomerHistory create
   */
  export type CustomerHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerHistory
     */
    select?: CustomerHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerHistory
     */
    omit?: CustomerHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerHistory.
     */
    data: XOR<CustomerHistoryCreateInput, CustomerHistoryUncheckedCreateInput>
  }

  /**
   * CustomerHistory createMany
   */
  export type CustomerHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerHistories.
     */
    data: CustomerHistoryCreateManyInput | CustomerHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerHistory createManyAndReturn
   */
  export type CustomerHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerHistory
     */
    select?: CustomerHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerHistory
     */
    omit?: CustomerHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerHistories.
     */
    data: CustomerHistoryCreateManyInput | CustomerHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerHistory update
   */
  export type CustomerHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerHistory
     */
    select?: CustomerHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerHistory
     */
    omit?: CustomerHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerHistory.
     */
    data: XOR<CustomerHistoryUpdateInput, CustomerHistoryUncheckedUpdateInput>
    /**
     * Choose, which CustomerHistory to update.
     */
    where: CustomerHistoryWhereUniqueInput
  }

  /**
   * CustomerHistory updateMany
   */
  export type CustomerHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerHistories.
     */
    data: XOR<CustomerHistoryUpdateManyMutationInput, CustomerHistoryUncheckedUpdateManyInput>
    /**
     * Filter which CustomerHistories to update
     */
    where?: CustomerHistoryWhereInput
    /**
     * Limit how many CustomerHistories to update.
     */
    limit?: number
  }

  /**
   * CustomerHistory updateManyAndReturn
   */
  export type CustomerHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerHistory
     */
    select?: CustomerHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerHistory
     */
    omit?: CustomerHistoryOmit<ExtArgs> | null
    /**
     * The data used to update CustomerHistories.
     */
    data: XOR<CustomerHistoryUpdateManyMutationInput, CustomerHistoryUncheckedUpdateManyInput>
    /**
     * Filter which CustomerHistories to update
     */
    where?: CustomerHistoryWhereInput
    /**
     * Limit how many CustomerHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerHistory upsert
   */
  export type CustomerHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerHistory
     */
    select?: CustomerHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerHistory
     */
    omit?: CustomerHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerHistory to update in case it exists.
     */
    where: CustomerHistoryWhereUniqueInput
    /**
     * In case the CustomerHistory found by the `where` argument doesn't exist, create a new CustomerHistory with this data.
     */
    create: XOR<CustomerHistoryCreateInput, CustomerHistoryUncheckedCreateInput>
    /**
     * In case the CustomerHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerHistoryUpdateInput, CustomerHistoryUncheckedUpdateInput>
  }

  /**
   * CustomerHistory delete
   */
  export type CustomerHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerHistory
     */
    select?: CustomerHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerHistory
     */
    omit?: CustomerHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerHistoryInclude<ExtArgs> | null
    /**
     * Filter which CustomerHistory to delete.
     */
    where: CustomerHistoryWhereUniqueInput
  }

  /**
   * CustomerHistory deleteMany
   */
  export type CustomerHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerHistories to delete
     */
    where?: CustomerHistoryWhereInput
    /**
     * Limit how many CustomerHistories to delete.
     */
    limit?: number
  }

  /**
   * CustomerHistory without action
   */
  export type CustomerHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerHistory
     */
    select?: CustomerHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerHistory
     */
    omit?: CustomerHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Cart
   */

  export type AggregateCart = {
    _count: CartCountAggregateOutputType | null
    _avg: CartAvgAggregateOutputType | null
    _sum: CartSumAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  export type CartAvgAggregateOutputType = {
    customerReference: number | null
  }

  export type CartSumAggregateOutputType = {
    customerReference: number | null
  }

  export type CartMinAggregateOutputType = {
    cartId: string | null
    customerReference: number | null
  }

  export type CartMaxAggregateOutputType = {
    cartId: string | null
    customerReference: number | null
  }

  export type CartCountAggregateOutputType = {
    cartId: number
    customerReference: number
    _all: number
  }


  export type CartAvgAggregateInputType = {
    customerReference?: true
  }

  export type CartSumAggregateInputType = {
    customerReference?: true
  }

  export type CartMinAggregateInputType = {
    cartId?: true
    customerReference?: true
  }

  export type CartMaxAggregateInputType = {
    cartId?: true
    customerReference?: true
  }

  export type CartCountAggregateInputType = {
    cartId?: true
    customerReference?: true
    _all?: true
  }

  export type CartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cart to aggregate.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Carts
    **/
    _count?: true | CartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartMaxAggregateInputType
  }

  export type GetCartAggregateType<T extends CartAggregateArgs> = {
        [P in keyof T & keyof AggregateCart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCart[P]>
      : GetScalarType<T[P], AggregateCart[P]>
  }




  export type CartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartWhereInput
    orderBy?: CartOrderByWithAggregationInput | CartOrderByWithAggregationInput[]
    by: CartScalarFieldEnum[] | CartScalarFieldEnum
    having?: CartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartCountAggregateInputType | true
    _avg?: CartAvgAggregateInputType
    _sum?: CartSumAggregateInputType
    _min?: CartMinAggregateInputType
    _max?: CartMaxAggregateInputType
  }

  export type CartGroupByOutputType = {
    cartId: string
    customerReference: number | null
    _count: CartCountAggregateOutputType | null
    _avg: CartAvgAggregateOutputType | null
    _sum: CartSumAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  type GetCartGroupByPayload<T extends CartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartGroupByOutputType[P]>
            : GetScalarType<T[P], CartGroupByOutputType[P]>
        }
      >
    >


  export type CartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cartId?: boolean
    customerReference?: boolean
    customer?: boolean | Cart$customerArgs<ExtArgs>
    products?: boolean | Cart$productsArgs<ExtArgs>
    _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cartId?: boolean
    customerReference?: boolean
    customer?: boolean | Cart$customerArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cartId?: boolean
    customerReference?: boolean
    customer?: boolean | Cart$customerArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectScalar = {
    cartId?: boolean
    customerReference?: boolean
  }

  export type CartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cartId" | "customerReference", ExtArgs["result"]["cart"]>
  export type CartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Cart$customerArgs<ExtArgs>
    products?: boolean | Cart$productsArgs<ExtArgs>
    _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Cart$customerArgs<ExtArgs>
  }
  export type CartIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Cart$customerArgs<ExtArgs>
  }

  export type $CartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cart"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      products: Prisma.$CartOnProductsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      cartId: string
      customerReference: number | null
    }, ExtArgs["result"]["cart"]>
    composites: {}
  }

  type CartGetPayload<S extends boolean | null | undefined | CartDefaultArgs> = $Result.GetResult<Prisma.$CartPayload, S>

  type CartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartCountAggregateInputType | true
    }

  export interface CartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cart'], meta: { name: 'Cart' } }
    /**
     * Find zero or one Cart that matches the filter.
     * @param {CartFindUniqueArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartFindUniqueArgs>(args: SelectSubset<T, CartFindUniqueArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartFindUniqueOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartFindUniqueOrThrowArgs>(args: SelectSubset<T, CartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartFindFirstArgs>(args?: SelectSubset<T, CartFindFirstArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartFindFirstOrThrowArgs>(args?: SelectSubset<T, CartFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Carts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carts
     * const carts = await prisma.cart.findMany()
     * 
     * // Get first 10 Carts
     * const carts = await prisma.cart.findMany({ take: 10 })
     * 
     * // Only select the `cartId`
     * const cartWithCartIdOnly = await prisma.cart.findMany({ select: { cartId: true } })
     * 
     */
    findMany<T extends CartFindManyArgs>(args?: SelectSubset<T, CartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cart.
     * @param {CartCreateArgs} args - Arguments to create a Cart.
     * @example
     * // Create one Cart
     * const Cart = await prisma.cart.create({
     *   data: {
     *     // ... data to create a Cart
     *   }
     * })
     * 
     */
    create<T extends CartCreateArgs>(args: SelectSubset<T, CartCreateArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Carts.
     * @param {CartCreateManyArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartCreateManyArgs>(args?: SelectSubset<T, CartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Carts and returns the data saved in the database.
     * @param {CartCreateManyAndReturnArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Carts and only return the `cartId`
     * const cartWithCartIdOnly = await prisma.cart.createManyAndReturn({
     *   select: { cartId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CartCreateManyAndReturnArgs>(args?: SelectSubset<T, CartCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cart.
     * @param {CartDeleteArgs} args - Arguments to delete one Cart.
     * @example
     * // Delete one Cart
     * const Cart = await prisma.cart.delete({
     *   where: {
     *     // ... filter to delete one Cart
     *   }
     * })
     * 
     */
    delete<T extends CartDeleteArgs>(args: SelectSubset<T, CartDeleteArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cart.
     * @param {CartUpdateArgs} args - Arguments to update one Cart.
     * @example
     * // Update one Cart
     * const cart = await prisma.cart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartUpdateArgs>(args: SelectSubset<T, CartUpdateArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Carts.
     * @param {CartDeleteManyArgs} args - Arguments to filter Carts to delete.
     * @example
     * // Delete a few Carts
     * const { count } = await prisma.cart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartDeleteManyArgs>(args?: SelectSubset<T, CartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartUpdateManyArgs>(args: SelectSubset<T, CartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts and returns the data updated in the database.
     * @param {CartUpdateManyAndReturnArgs} args - Arguments to update many Carts.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Carts and only return the `cartId`
     * const cartWithCartIdOnly = await prisma.cart.updateManyAndReturn({
     *   select: { cartId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CartUpdateManyAndReturnArgs>(args: SelectSubset<T, CartUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cart.
     * @param {CartUpsertArgs} args - Arguments to update or create a Cart.
     * @example
     * // Update or create a Cart
     * const cart = await prisma.cart.upsert({
     *   create: {
     *     // ... data to create a Cart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cart we want to update
     *   }
     * })
     */
    upsert<T extends CartUpsertArgs>(args: SelectSubset<T, CartUpsertArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartCountArgs} args - Arguments to filter Carts to count.
     * @example
     * // Count the number of Carts
     * const count = await prisma.cart.count({
     *   where: {
     *     // ... the filter for the Carts we want to count
     *   }
     * })
    **/
    count<T extends CartCountArgs>(
      args?: Subset<T, CartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartAggregateArgs>(args: Subset<T, CartAggregateArgs>): Prisma.PrismaPromise<GetCartAggregateType<T>>

    /**
     * Group by Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartGroupByArgs['orderBy'] }
        : { orderBy?: CartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cart model
   */
  readonly fields: CartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends Cart$customerArgs<ExtArgs> = {}>(args?: Subset<T, Cart$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    products<T extends Cart$productsArgs<ExtArgs> = {}>(args?: Subset<T, Cart$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartOnProductsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cart model
   */
  interface CartFieldRefs {
    readonly cartId: FieldRef<"Cart", 'String'>
    readonly customerReference: FieldRef<"Cart", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Cart findUnique
   */
  export type CartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart findUniqueOrThrow
   */
  export type CartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart findFirst
   */
  export type CartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart findFirstOrThrow
   */
  export type CartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart findMany
   */
  export type CartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Carts to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart create
   */
  export type CartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to create a Cart.
     */
    data?: XOR<CartCreateInput, CartUncheckedCreateInput>
  }

  /**
   * Cart createMany
   */
  export type CartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Carts.
     */
    data: CartCreateManyInput | CartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cart createManyAndReturn
   */
  export type CartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * The data used to create many Carts.
     */
    data: CartCreateManyInput | CartCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cart update
   */
  export type CartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to update a Cart.
     */
    data: XOR<CartUpdateInput, CartUncheckedUpdateInput>
    /**
     * Choose, which Cart to update.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart updateMany
   */
  export type CartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Carts.
     */
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>
    /**
     * Filter which Carts to update
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to update.
     */
    limit?: number
  }

  /**
   * Cart updateManyAndReturn
   */
  export type CartUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * The data used to update Carts.
     */
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>
    /**
     * Filter which Carts to update
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cart upsert
   */
  export type CartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The filter to search for the Cart to update in case it exists.
     */
    where: CartWhereUniqueInput
    /**
     * In case the Cart found by the `where` argument doesn't exist, create a new Cart with this data.
     */
    create: XOR<CartCreateInput, CartUncheckedCreateInput>
    /**
     * In case the Cart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartUpdateInput, CartUncheckedUpdateInput>
  }

  /**
   * Cart delete
   */
  export type CartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter which Cart to delete.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart deleteMany
   */
  export type CartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carts to delete
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to delete.
     */
    limit?: number
  }

  /**
   * Cart.customer
   */
  export type Cart$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Cart.products
   */
  export type Cart$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartOnProducts
     */
    select?: CartOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartOnProducts
     */
    omit?: CartOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartOnProductsInclude<ExtArgs> | null
    where?: CartOnProductsWhereInput
    orderBy?: CartOnProductsOrderByWithRelationInput | CartOnProductsOrderByWithRelationInput[]
    cursor?: CartOnProductsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartOnProductsScalarFieldEnum | CartOnProductsScalarFieldEnum[]
  }

  /**
   * Cart without action
   */
  export type CartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
  }


  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressMinAggregateOutputType = {
    addressId: string | null
    city: string | null
    country: string | null
    postCode: string | null
    state: string | null
    streetName: string | null
    streetNumber: string | null
    modifiedAt: Date | null
    deleted: boolean | null
  }

  export type AddressMaxAggregateOutputType = {
    addressId: string | null
    city: string | null
    country: string | null
    postCode: string | null
    state: string | null
    streetName: string | null
    streetNumber: string | null
    modifiedAt: Date | null
    deleted: boolean | null
  }

  export type AddressCountAggregateOutputType = {
    addressId: number
    city: number
    country: number
    postCode: number
    state: number
    streetName: number
    streetNumber: number
    modifiedAt: number
    deleted: number
    _all: number
  }


  export type AddressMinAggregateInputType = {
    addressId?: true
    city?: true
    country?: true
    postCode?: true
    state?: true
    streetName?: true
    streetNumber?: true
    modifiedAt?: true
    deleted?: true
  }

  export type AddressMaxAggregateInputType = {
    addressId?: true
    city?: true
    country?: true
    postCode?: true
    state?: true
    streetName?: true
    streetNumber?: true
    modifiedAt?: true
    deleted?: true
  }

  export type AddressCountAggregateInputType = {
    addressId?: true
    city?: true
    country?: true
    postCode?: true
    state?: true
    streetName?: true
    streetNumber?: true
    modifiedAt?: true
    deleted?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    addressId: string
    city: string
    country: string
    postCode: string
    state: string
    streetName: string
    streetNumber: string
    modifiedAt: Date | null
    deleted: boolean
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    addressId?: boolean
    city?: boolean
    country?: boolean
    postCode?: boolean
    state?: boolean
    streetName?: boolean
    streetNumber?: boolean
    modifiedAt?: boolean
    deleted?: boolean
    customers?: boolean | Address$customersArgs<ExtArgs>
    siteConfig?: boolean | Address$siteConfigArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    addressId?: boolean
    city?: boolean
    country?: boolean
    postCode?: boolean
    state?: boolean
    streetName?: boolean
    streetNumber?: boolean
    modifiedAt?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["address"]>

  export type AddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    addressId?: boolean
    city?: boolean
    country?: boolean
    postCode?: boolean
    state?: boolean
    streetName?: boolean
    streetNumber?: boolean
    modifiedAt?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    addressId?: boolean
    city?: boolean
    country?: boolean
    postCode?: boolean
    state?: boolean
    streetName?: boolean
    streetNumber?: boolean
    modifiedAt?: boolean
    deleted?: boolean
  }

  export type AddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"addressId" | "city" | "country" | "postCode" | "state" | "streetName" | "streetNumber" | "modifiedAt" | "deleted", ExtArgs["result"]["address"]>
  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | Address$customersArgs<ExtArgs>
    siteConfig?: boolean | Address$siteConfigArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {
      customers: Prisma.$CustomerPayload<ExtArgs>[]
      siteConfig: Prisma.$SiteConfigPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      addressId: string
      city: string
      country: string
      postCode: string
      state: string
      streetName: string
      streetNumber: string
      modifiedAt: Date | null
      deleted: boolean
    }, ExtArgs["result"]["address"]>
    composites: {}
  }

  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `addressId`
     * const addressWithAddressIdOnly = await prisma.address.findMany({ select: { addressId: true } })
     * 
     */
    findMany<T extends AddressFindManyArgs>(args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
     */
    create<T extends AddressCreateArgs>(args: SelectSubset<T, AddressCreateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressCreateManyArgs>(args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {AddressCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addresses and only return the `addressId`
     * const addressWithAddressIdOnly = await prisma.address.createManyAndReturn({
     *   select: { addressId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
     */
    delete<T extends AddressDeleteArgs>(args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressUpdateArgs>(args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressDeleteManyArgs>(args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressUpdateManyArgs>(args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses and returns the data updated in the database.
     * @param {AddressUpdateManyAndReturnArgs} args - Arguments to update many Addresses.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Addresses and only return the `addressId`
     * const addressWithAddressIdOnly = await prisma.address.updateManyAndReturn({
     *   select: { addressId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddressUpdateManyAndReturnArgs>(args: SelectSubset<T, AddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customers<T extends Address$customersArgs<ExtArgs> = {}>(args?: Subset<T, Address$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    siteConfig<T extends Address$siteConfigArgs<ExtArgs> = {}>(args?: Subset<T, Address$siteConfigArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Address model
   */
  interface AddressFieldRefs {
    readonly addressId: FieldRef<"Address", 'String'>
    readonly city: FieldRef<"Address", 'String'>
    readonly country: FieldRef<"Address", 'String'>
    readonly postCode: FieldRef<"Address", 'String'>
    readonly state: FieldRef<"Address", 'String'>
    readonly streetName: FieldRef<"Address", 'String'>
    readonly streetNumber: FieldRef<"Address", 'String'>
    readonly modifiedAt: FieldRef<"Address", 'DateTime'>
    readonly deleted: FieldRef<"Address", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address createManyAndReturn
   */
  export type AddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address updateManyAndReturn
   */
  export type AddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to delete.
     */
    limit?: number
  }

  /**
   * Address.customers
   */
  export type Address$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Address.siteConfig
   */
  export type Address$siteConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfig
     */
    omit?: SiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigInclude<ExtArgs> | null
    where?: SiteConfigWhereInput
    orderBy?: SiteConfigOrderByWithRelationInput | SiteConfigOrderByWithRelationInput[]
    cursor?: SiteConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SiteConfigScalarFieldEnum | SiteConfigScalarFieldEnum[]
  }

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    price: number | null
    stock: number | null
  }

  export type ProductSumAggregateOutputType = {
    price: number | null
    stock: number | null
  }

  export type ProductMinAggregateOutputType = {
    productId: string | null
    name: string | null
    price: number | null
    description: string | null
    stock: number | null
    imagePath: string | null
    createdAt: Date | null
    modifiedAt: Date | null
    deleted: boolean | null
    categoryId: string | null
  }

  export type ProductMaxAggregateOutputType = {
    productId: string | null
    name: string | null
    price: number | null
    description: string | null
    stock: number | null
    imagePath: string | null
    createdAt: Date | null
    modifiedAt: Date | null
    deleted: boolean | null
    categoryId: string | null
  }

  export type ProductCountAggregateOutputType = {
    productId: number
    name: number
    price: number
    description: number
    stock: number
    imagePath: number
    createdAt: number
    modifiedAt: number
    deleted: number
    categoryId: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    price?: true
    stock?: true
  }

  export type ProductSumAggregateInputType = {
    price?: true
    stock?: true
  }

  export type ProductMinAggregateInputType = {
    productId?: true
    name?: true
    price?: true
    description?: true
    stock?: true
    imagePath?: true
    createdAt?: true
    modifiedAt?: true
    deleted?: true
    categoryId?: true
  }

  export type ProductMaxAggregateInputType = {
    productId?: true
    name?: true
    price?: true
    description?: true
    stock?: true
    imagePath?: true
    createdAt?: true
    modifiedAt?: true
    deleted?: true
    categoryId?: true
  }

  export type ProductCountAggregateInputType = {
    productId?: true
    name?: true
    price?: true
    description?: true
    stock?: true
    imagePath?: true
    createdAt?: true
    modifiedAt?: true
    deleted?: true
    categoryId?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    productId: string
    name: string
    price: number
    description: string
    stock: number
    imagePath: string | null
    createdAt: Date
    modifiedAt: Date | null
    deleted: boolean
    categoryId: string
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    productId?: boolean
    name?: boolean
    price?: boolean
    description?: boolean
    stock?: boolean
    imagePath?: boolean
    createdAt?: boolean
    modifiedAt?: boolean
    deleted?: boolean
    categoryId?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    carts?: boolean | Product$cartsArgs<ExtArgs>
    orders?: boolean | Product$ordersArgs<ExtArgs>
    ProductHistory?: boolean | Product$ProductHistoryArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    productId?: boolean
    name?: boolean
    price?: boolean
    description?: boolean
    stock?: boolean
    imagePath?: boolean
    createdAt?: boolean
    modifiedAt?: boolean
    deleted?: boolean
    categoryId?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    productId?: boolean
    name?: boolean
    price?: boolean
    description?: boolean
    stock?: boolean
    imagePath?: boolean
    createdAt?: boolean
    modifiedAt?: boolean
    deleted?: boolean
    categoryId?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    productId?: boolean
    name?: boolean
    price?: boolean
    description?: boolean
    stock?: boolean
    imagePath?: boolean
    createdAt?: boolean
    modifiedAt?: boolean
    deleted?: boolean
    categoryId?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"productId" | "name" | "price" | "description" | "stock" | "imagePath" | "createdAt" | "modifiedAt" | "deleted" | "categoryId", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    carts?: boolean | Product$cartsArgs<ExtArgs>
    orders?: boolean | Product$ordersArgs<ExtArgs>
    ProductHistory?: boolean | Product$ProductHistoryArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      carts: Prisma.$CartOnProductsPayload<ExtArgs>[]
      orders: Prisma.$OrderOnProductsPayload<ExtArgs>[]
      ProductHistory: Prisma.$ProductHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      productId: string
      name: string
      price: number
      description: string
      stock: number
      imagePath: string | null
      createdAt: Date
      modifiedAt: Date | null
      deleted: boolean
      categoryId: string
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `productId`
     * const productWithProductIdOnly = await prisma.product.findMany({ select: { productId: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `productId`
     * const productWithProductIdOnly = await prisma.product.createManyAndReturn({
     *   select: { productId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `productId`
     * const productWithProductIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { productId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    carts<T extends Product$cartsArgs<ExtArgs> = {}>(args?: Subset<T, Product$cartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartOnProductsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends Product$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Product$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderOnProductsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProductHistory<T extends Product$ProductHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$ProductHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly productId: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Int'>
    readonly description: FieldRef<"Product", 'String'>
    readonly stock: FieldRef<"Product", 'Int'>
    readonly imagePath: FieldRef<"Product", 'String'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly modifiedAt: FieldRef<"Product", 'DateTime'>
    readonly deleted: FieldRef<"Product", 'Boolean'>
    readonly categoryId: FieldRef<"Product", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.carts
   */
  export type Product$cartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartOnProducts
     */
    select?: CartOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartOnProducts
     */
    omit?: CartOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartOnProductsInclude<ExtArgs> | null
    where?: CartOnProductsWhereInput
    orderBy?: CartOnProductsOrderByWithRelationInput | CartOnProductsOrderByWithRelationInput[]
    cursor?: CartOnProductsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartOnProductsScalarFieldEnum | CartOnProductsScalarFieldEnum[]
  }

  /**
   * Product.orders
   */
  export type Product$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderOnProducts
     */
    select?: OrderOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderOnProducts
     */
    omit?: OrderOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderOnProductsInclude<ExtArgs> | null
    where?: OrderOnProductsWhereInput
    orderBy?: OrderOnProductsOrderByWithRelationInput | OrderOnProductsOrderByWithRelationInput[]
    cursor?: OrderOnProductsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderOnProductsScalarFieldEnum | OrderOnProductsScalarFieldEnum[]
  }

  /**
   * Product.ProductHistory
   */
  export type Product$ProductHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductHistory
     */
    select?: ProductHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductHistory
     */
    omit?: ProductHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductHistoryInclude<ExtArgs> | null
    where?: ProductHistoryWhereInput
    orderBy?: ProductHistoryOrderByWithRelationInput | ProductHistoryOrderByWithRelationInput[]
    cursor?: ProductHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductHistoryScalarFieldEnum | ProductHistoryScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductHistory
   */

  export type AggregateProductHistory = {
    _count: ProductHistoryCountAggregateOutputType | null
    _avg: ProductHistoryAvgAggregateOutputType | null
    _sum: ProductHistorySumAggregateOutputType | null
    _min: ProductHistoryMinAggregateOutputType | null
    _max: ProductHistoryMaxAggregateOutputType | null
  }

  export type ProductHistoryAvgAggregateOutputType = {
    price: number | null
    stock: number | null
  }

  export type ProductHistorySumAggregateOutputType = {
    price: number | null
    stock: number | null
  }

  export type ProductHistoryMinAggregateOutputType = {
    historyId: string | null
    productId: string | null
    name: string | null
    price: number | null
    description: string | null
    stock: number | null
    imagePath: string | null
    createdAt: Date | null
    modifiedAt: Date | null
    deleted: boolean | null
    categoryId: string | null
  }

  export type ProductHistoryMaxAggregateOutputType = {
    historyId: string | null
    productId: string | null
    name: string | null
    price: number | null
    description: string | null
    stock: number | null
    imagePath: string | null
    createdAt: Date | null
    modifiedAt: Date | null
    deleted: boolean | null
    categoryId: string | null
  }

  export type ProductHistoryCountAggregateOutputType = {
    historyId: number
    productId: number
    name: number
    price: number
    description: number
    stock: number
    imagePath: number
    createdAt: number
    modifiedAt: number
    deleted: number
    categoryId: number
    _all: number
  }


  export type ProductHistoryAvgAggregateInputType = {
    price?: true
    stock?: true
  }

  export type ProductHistorySumAggregateInputType = {
    price?: true
    stock?: true
  }

  export type ProductHistoryMinAggregateInputType = {
    historyId?: true
    productId?: true
    name?: true
    price?: true
    description?: true
    stock?: true
    imagePath?: true
    createdAt?: true
    modifiedAt?: true
    deleted?: true
    categoryId?: true
  }

  export type ProductHistoryMaxAggregateInputType = {
    historyId?: true
    productId?: true
    name?: true
    price?: true
    description?: true
    stock?: true
    imagePath?: true
    createdAt?: true
    modifiedAt?: true
    deleted?: true
    categoryId?: true
  }

  export type ProductHistoryCountAggregateInputType = {
    historyId?: true
    productId?: true
    name?: true
    price?: true
    description?: true
    stock?: true
    imagePath?: true
    createdAt?: true
    modifiedAt?: true
    deleted?: true
    categoryId?: true
    _all?: true
  }

  export type ProductHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductHistory to aggregate.
     */
    where?: ProductHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductHistories to fetch.
     */
    orderBy?: ProductHistoryOrderByWithRelationInput | ProductHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductHistories
    **/
    _count?: true | ProductHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductHistoryMaxAggregateInputType
  }

  export type GetProductHistoryAggregateType<T extends ProductHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductHistory[P]>
      : GetScalarType<T[P], AggregateProductHistory[P]>
  }




  export type ProductHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductHistoryWhereInput
    orderBy?: ProductHistoryOrderByWithAggregationInput | ProductHistoryOrderByWithAggregationInput[]
    by: ProductHistoryScalarFieldEnum[] | ProductHistoryScalarFieldEnum
    having?: ProductHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductHistoryCountAggregateInputType | true
    _avg?: ProductHistoryAvgAggregateInputType
    _sum?: ProductHistorySumAggregateInputType
    _min?: ProductHistoryMinAggregateInputType
    _max?: ProductHistoryMaxAggregateInputType
  }

  export type ProductHistoryGroupByOutputType = {
    historyId: string
    productId: string
    name: string
    price: number
    description: string
    stock: number
    imagePath: string | null
    createdAt: Date
    modifiedAt: Date | null
    deleted: boolean
    categoryId: string
    _count: ProductHistoryCountAggregateOutputType | null
    _avg: ProductHistoryAvgAggregateOutputType | null
    _sum: ProductHistorySumAggregateOutputType | null
    _min: ProductHistoryMinAggregateOutputType | null
    _max: ProductHistoryMaxAggregateOutputType | null
  }

  type GetProductHistoryGroupByPayload<T extends ProductHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductHistoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    historyId?: boolean
    productId?: boolean
    name?: boolean
    price?: boolean
    description?: boolean
    stock?: boolean
    imagePath?: boolean
    createdAt?: boolean
    modifiedAt?: boolean
    deleted?: boolean
    categoryId?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productHistory"]>

  export type ProductHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    historyId?: boolean
    productId?: boolean
    name?: boolean
    price?: boolean
    description?: boolean
    stock?: boolean
    imagePath?: boolean
    createdAt?: boolean
    modifiedAt?: boolean
    deleted?: boolean
    categoryId?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productHistory"]>

  export type ProductHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    historyId?: boolean
    productId?: boolean
    name?: boolean
    price?: boolean
    description?: boolean
    stock?: boolean
    imagePath?: boolean
    createdAt?: boolean
    modifiedAt?: boolean
    deleted?: boolean
    categoryId?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productHistory"]>

  export type ProductHistorySelectScalar = {
    historyId?: boolean
    productId?: boolean
    name?: boolean
    price?: boolean
    description?: boolean
    stock?: boolean
    imagePath?: boolean
    createdAt?: boolean
    modifiedAt?: boolean
    deleted?: boolean
    categoryId?: boolean
  }

  export type ProductHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"historyId" | "productId" | "name" | "price" | "description" | "stock" | "imagePath" | "createdAt" | "modifiedAt" | "deleted" | "categoryId", ExtArgs["result"]["productHistory"]>
  export type ProductHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductHistory"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      historyId: string
      productId: string
      name: string
      price: number
      description: string
      stock: number
      imagePath: string | null
      createdAt: Date
      modifiedAt: Date | null
      deleted: boolean
      categoryId: string
    }, ExtArgs["result"]["productHistory"]>
    composites: {}
  }

  type ProductHistoryGetPayload<S extends boolean | null | undefined | ProductHistoryDefaultArgs> = $Result.GetResult<Prisma.$ProductHistoryPayload, S>

  type ProductHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductHistoryCountAggregateInputType | true
    }

  export interface ProductHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductHistory'], meta: { name: 'ProductHistory' } }
    /**
     * Find zero or one ProductHistory that matches the filter.
     * @param {ProductHistoryFindUniqueArgs} args - Arguments to find a ProductHistory
     * @example
     * // Get one ProductHistory
     * const productHistory = await prisma.productHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductHistoryFindUniqueArgs>(args: SelectSubset<T, ProductHistoryFindUniqueArgs<ExtArgs>>): Prisma__ProductHistoryClient<$Result.GetResult<Prisma.$ProductHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductHistoryFindUniqueOrThrowArgs} args - Arguments to find a ProductHistory
     * @example
     * // Get one ProductHistory
     * const productHistory = await prisma.productHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductHistoryClient<$Result.GetResult<Prisma.$ProductHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductHistoryFindFirstArgs} args - Arguments to find a ProductHistory
     * @example
     * // Get one ProductHistory
     * const productHistory = await prisma.productHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductHistoryFindFirstArgs>(args?: SelectSubset<T, ProductHistoryFindFirstArgs<ExtArgs>>): Prisma__ProductHistoryClient<$Result.GetResult<Prisma.$ProductHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductHistoryFindFirstOrThrowArgs} args - Arguments to find a ProductHistory
     * @example
     * // Get one ProductHistory
     * const productHistory = await prisma.productHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductHistoryClient<$Result.GetResult<Prisma.$ProductHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductHistories
     * const productHistories = await prisma.productHistory.findMany()
     * 
     * // Get first 10 ProductHistories
     * const productHistories = await prisma.productHistory.findMany({ take: 10 })
     * 
     * // Only select the `historyId`
     * const productHistoryWithHistoryIdOnly = await prisma.productHistory.findMany({ select: { historyId: true } })
     * 
     */
    findMany<T extends ProductHistoryFindManyArgs>(args?: SelectSubset<T, ProductHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductHistory.
     * @param {ProductHistoryCreateArgs} args - Arguments to create a ProductHistory.
     * @example
     * // Create one ProductHistory
     * const ProductHistory = await prisma.productHistory.create({
     *   data: {
     *     // ... data to create a ProductHistory
     *   }
     * })
     * 
     */
    create<T extends ProductHistoryCreateArgs>(args: SelectSubset<T, ProductHistoryCreateArgs<ExtArgs>>): Prisma__ProductHistoryClient<$Result.GetResult<Prisma.$ProductHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductHistories.
     * @param {ProductHistoryCreateManyArgs} args - Arguments to create many ProductHistories.
     * @example
     * // Create many ProductHistories
     * const productHistory = await prisma.productHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductHistoryCreateManyArgs>(args?: SelectSubset<T, ProductHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductHistories and returns the data saved in the database.
     * @param {ProductHistoryCreateManyAndReturnArgs} args - Arguments to create many ProductHistories.
     * @example
     * // Create many ProductHistories
     * const productHistory = await prisma.productHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductHistories and only return the `historyId`
     * const productHistoryWithHistoryIdOnly = await prisma.productHistory.createManyAndReturn({
     *   select: { historyId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductHistory.
     * @param {ProductHistoryDeleteArgs} args - Arguments to delete one ProductHistory.
     * @example
     * // Delete one ProductHistory
     * const ProductHistory = await prisma.productHistory.delete({
     *   where: {
     *     // ... filter to delete one ProductHistory
     *   }
     * })
     * 
     */
    delete<T extends ProductHistoryDeleteArgs>(args: SelectSubset<T, ProductHistoryDeleteArgs<ExtArgs>>): Prisma__ProductHistoryClient<$Result.GetResult<Prisma.$ProductHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductHistory.
     * @param {ProductHistoryUpdateArgs} args - Arguments to update one ProductHistory.
     * @example
     * // Update one ProductHistory
     * const productHistory = await prisma.productHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductHistoryUpdateArgs>(args: SelectSubset<T, ProductHistoryUpdateArgs<ExtArgs>>): Prisma__ProductHistoryClient<$Result.GetResult<Prisma.$ProductHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductHistories.
     * @param {ProductHistoryDeleteManyArgs} args - Arguments to filter ProductHistories to delete.
     * @example
     * // Delete a few ProductHistories
     * const { count } = await prisma.productHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductHistoryDeleteManyArgs>(args?: SelectSubset<T, ProductHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductHistories
     * const productHistory = await prisma.productHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductHistoryUpdateManyArgs>(args: SelectSubset<T, ProductHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductHistories and returns the data updated in the database.
     * @param {ProductHistoryUpdateManyAndReturnArgs} args - Arguments to update many ProductHistories.
     * @example
     * // Update many ProductHistories
     * const productHistory = await prisma.productHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductHistories and only return the `historyId`
     * const productHistoryWithHistoryIdOnly = await prisma.productHistory.updateManyAndReturn({
     *   select: { historyId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductHistory.
     * @param {ProductHistoryUpsertArgs} args - Arguments to update or create a ProductHistory.
     * @example
     * // Update or create a ProductHistory
     * const productHistory = await prisma.productHistory.upsert({
     *   create: {
     *     // ... data to create a ProductHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductHistory we want to update
     *   }
     * })
     */
    upsert<T extends ProductHistoryUpsertArgs>(args: SelectSubset<T, ProductHistoryUpsertArgs<ExtArgs>>): Prisma__ProductHistoryClient<$Result.GetResult<Prisma.$ProductHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductHistoryCountArgs} args - Arguments to filter ProductHistories to count.
     * @example
     * // Count the number of ProductHistories
     * const count = await prisma.productHistory.count({
     *   where: {
     *     // ... the filter for the ProductHistories we want to count
     *   }
     * })
    **/
    count<T extends ProductHistoryCountArgs>(
      args?: Subset<T, ProductHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductHistoryAggregateArgs>(args: Subset<T, ProductHistoryAggregateArgs>): Prisma.PrismaPromise<GetProductHistoryAggregateType<T>>

    /**
     * Group by ProductHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductHistory model
   */
  readonly fields: ProductHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductHistory model
   */
  interface ProductHistoryFieldRefs {
    readonly historyId: FieldRef<"ProductHistory", 'String'>
    readonly productId: FieldRef<"ProductHistory", 'String'>
    readonly name: FieldRef<"ProductHistory", 'String'>
    readonly price: FieldRef<"ProductHistory", 'Int'>
    readonly description: FieldRef<"ProductHistory", 'String'>
    readonly stock: FieldRef<"ProductHistory", 'Int'>
    readonly imagePath: FieldRef<"ProductHistory", 'String'>
    readonly createdAt: FieldRef<"ProductHistory", 'DateTime'>
    readonly modifiedAt: FieldRef<"ProductHistory", 'DateTime'>
    readonly deleted: FieldRef<"ProductHistory", 'Boolean'>
    readonly categoryId: FieldRef<"ProductHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductHistory findUnique
   */
  export type ProductHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductHistory
     */
    select?: ProductHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductHistory
     */
    omit?: ProductHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductHistory to fetch.
     */
    where: ProductHistoryWhereUniqueInput
  }

  /**
   * ProductHistory findUniqueOrThrow
   */
  export type ProductHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductHistory
     */
    select?: ProductHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductHistory
     */
    omit?: ProductHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductHistory to fetch.
     */
    where: ProductHistoryWhereUniqueInput
  }

  /**
   * ProductHistory findFirst
   */
  export type ProductHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductHistory
     */
    select?: ProductHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductHistory
     */
    omit?: ProductHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductHistory to fetch.
     */
    where?: ProductHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductHistories to fetch.
     */
    orderBy?: ProductHistoryOrderByWithRelationInput | ProductHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductHistories.
     */
    cursor?: ProductHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductHistories.
     */
    distinct?: ProductHistoryScalarFieldEnum | ProductHistoryScalarFieldEnum[]
  }

  /**
   * ProductHistory findFirstOrThrow
   */
  export type ProductHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductHistory
     */
    select?: ProductHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductHistory
     */
    omit?: ProductHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductHistory to fetch.
     */
    where?: ProductHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductHistories to fetch.
     */
    orderBy?: ProductHistoryOrderByWithRelationInput | ProductHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductHistories.
     */
    cursor?: ProductHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductHistories.
     */
    distinct?: ProductHistoryScalarFieldEnum | ProductHistoryScalarFieldEnum[]
  }

  /**
   * ProductHistory findMany
   */
  export type ProductHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductHistory
     */
    select?: ProductHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductHistory
     */
    omit?: ProductHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductHistories to fetch.
     */
    where?: ProductHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductHistories to fetch.
     */
    orderBy?: ProductHistoryOrderByWithRelationInput | ProductHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductHistories.
     */
    cursor?: ProductHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductHistories.
     */
    skip?: number
    distinct?: ProductHistoryScalarFieldEnum | ProductHistoryScalarFieldEnum[]
  }

  /**
   * ProductHistory create
   */
  export type ProductHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductHistory
     */
    select?: ProductHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductHistory
     */
    omit?: ProductHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductHistory.
     */
    data: XOR<ProductHistoryCreateInput, ProductHistoryUncheckedCreateInput>
  }

  /**
   * ProductHistory createMany
   */
  export type ProductHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductHistories.
     */
    data: ProductHistoryCreateManyInput | ProductHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductHistory createManyAndReturn
   */
  export type ProductHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductHistory
     */
    select?: ProductHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductHistory
     */
    omit?: ProductHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many ProductHistories.
     */
    data: ProductHistoryCreateManyInput | ProductHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductHistory update
   */
  export type ProductHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductHistory
     */
    select?: ProductHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductHistory
     */
    omit?: ProductHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductHistory.
     */
    data: XOR<ProductHistoryUpdateInput, ProductHistoryUncheckedUpdateInput>
    /**
     * Choose, which ProductHistory to update.
     */
    where: ProductHistoryWhereUniqueInput
  }

  /**
   * ProductHistory updateMany
   */
  export type ProductHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductHistories.
     */
    data: XOR<ProductHistoryUpdateManyMutationInput, ProductHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductHistories to update
     */
    where?: ProductHistoryWhereInput
    /**
     * Limit how many ProductHistories to update.
     */
    limit?: number
  }

  /**
   * ProductHistory updateManyAndReturn
   */
  export type ProductHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductHistory
     */
    select?: ProductHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductHistory
     */
    omit?: ProductHistoryOmit<ExtArgs> | null
    /**
     * The data used to update ProductHistories.
     */
    data: XOR<ProductHistoryUpdateManyMutationInput, ProductHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductHistories to update
     */
    where?: ProductHistoryWhereInput
    /**
     * Limit how many ProductHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductHistory upsert
   */
  export type ProductHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductHistory
     */
    select?: ProductHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductHistory
     */
    omit?: ProductHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductHistory to update in case it exists.
     */
    where: ProductHistoryWhereUniqueInput
    /**
     * In case the ProductHistory found by the `where` argument doesn't exist, create a new ProductHistory with this data.
     */
    create: XOR<ProductHistoryCreateInput, ProductHistoryUncheckedCreateInput>
    /**
     * In case the ProductHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductHistoryUpdateInput, ProductHistoryUncheckedUpdateInput>
  }

  /**
   * ProductHistory delete
   */
  export type ProductHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductHistory
     */
    select?: ProductHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductHistory
     */
    omit?: ProductHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductHistoryInclude<ExtArgs> | null
    /**
     * Filter which ProductHistory to delete.
     */
    where: ProductHistoryWhereUniqueInput
  }

  /**
   * ProductHistory deleteMany
   */
  export type ProductHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductHistories to delete
     */
    where?: ProductHistoryWhereInput
    /**
     * Limit how many ProductHistories to delete.
     */
    limit?: number
  }

  /**
   * ProductHistory without action
   */
  export type ProductHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductHistory
     */
    select?: ProductHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductHistory
     */
    omit?: ProductHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    categoryId: string | null
    name: string | null
    imagePath: string | null
    deleted: boolean | null
  }

  export type CategoryMaxAggregateOutputType = {
    categoryId: string | null
    name: string | null
    imagePath: string | null
    deleted: boolean | null
  }

  export type CategoryCountAggregateOutputType = {
    categoryId: number
    name: number
    imagePath: number
    deleted: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    categoryId?: true
    name?: true
    imagePath?: true
    deleted?: true
  }

  export type CategoryMaxAggregateInputType = {
    categoryId?: true
    name?: true
    imagePath?: true
    deleted?: true
  }

  export type CategoryCountAggregateInputType = {
    categoryId?: true
    name?: true
    imagePath?: true
    deleted?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    categoryId: string
    name: string
    imagePath: string | null
    deleted: boolean
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    categoryId?: boolean
    name?: boolean
    imagePath?: boolean
    deleted?: boolean
    products?: boolean | Category$productsArgs<ExtArgs>
    ProductHistory?: boolean | Category$ProductHistoryArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    categoryId?: boolean
    name?: boolean
    imagePath?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    categoryId?: boolean
    name?: boolean
    imagePath?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    categoryId?: boolean
    name?: boolean
    imagePath?: boolean
    deleted?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"categoryId" | "name" | "imagePath" | "deleted", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Category$productsArgs<ExtArgs>
    ProductHistory?: boolean | Category$ProductHistoryArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
      ProductHistory: Prisma.$ProductHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      categoryId: string
      name: string
      imagePath: string | null
      deleted: boolean
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `categoryId`
     * const categoryWithCategoryIdOnly = await prisma.category.findMany({ select: { categoryId: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `categoryId`
     * const categoryWithCategoryIdOnly = await prisma.category.createManyAndReturn({
     *   select: { categoryId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `categoryId`
     * const categoryWithCategoryIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { categoryId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Category$productsArgs<ExtArgs> = {}>(args?: Subset<T, Category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProductHistory<T extends Category$ProductHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Category$ProductHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly categoryId: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly imagePath: FieldRef<"Category", 'String'>
    readonly deleted: FieldRef<"Category", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.products
   */
  export type Category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Category.ProductHistory
   */
  export type Category$ProductHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductHistory
     */
    select?: ProductHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductHistory
     */
    omit?: ProductHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductHistoryInclude<ExtArgs> | null
    where?: ProductHistoryWhereInput
    orderBy?: ProductHistoryOrderByWithRelationInput | ProductHistoryOrderByWithRelationInput[]
    cursor?: ProductHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductHistoryScalarFieldEnum | ProductHistoryScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    customerReference: number | null
  }

  export type OrderSumAggregateOutputType = {
    customerReference: number | null
  }

  export type OrderMinAggregateOutputType = {
    orderId: string | null
    customerReference: number | null
    orderDate: Date | null
    deliveryDate: Date | null
    deleted: boolean | null
    orderState: $Enums.OrderState | null
    selfCollect: boolean | null
  }

  export type OrderMaxAggregateOutputType = {
    orderId: string | null
    customerReference: number | null
    orderDate: Date | null
    deliveryDate: Date | null
    deleted: boolean | null
    orderState: $Enums.OrderState | null
    selfCollect: boolean | null
  }

  export type OrderCountAggregateOutputType = {
    orderId: number
    customerReference: number
    orderDate: number
    deliveryDate: number
    deleted: number
    orderState: number
    selfCollect: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    customerReference?: true
  }

  export type OrderSumAggregateInputType = {
    customerReference?: true
  }

  export type OrderMinAggregateInputType = {
    orderId?: true
    customerReference?: true
    orderDate?: true
    deliveryDate?: true
    deleted?: true
    orderState?: true
    selfCollect?: true
  }

  export type OrderMaxAggregateInputType = {
    orderId?: true
    customerReference?: true
    orderDate?: true
    deliveryDate?: true
    deleted?: true
    orderState?: true
    selfCollect?: true
  }

  export type OrderCountAggregateInputType = {
    orderId?: true
    customerReference?: true
    orderDate?: true
    deliveryDate?: true
    deleted?: true
    orderState?: true
    selfCollect?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    orderId: string
    customerReference: number
    orderDate: Date
    deliveryDate: Date | null
    deleted: boolean
    orderState: $Enums.OrderState
    selfCollect: boolean
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    orderId?: boolean
    customerReference?: boolean
    orderDate?: boolean
    deliveryDate?: boolean
    deleted?: boolean
    orderState?: boolean
    selfCollect?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    products?: boolean | Order$productsArgs<ExtArgs>
    invoice?: boolean | Order$invoiceArgs<ExtArgs>
    route?: boolean | Order$routeArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    orderId?: boolean
    customerReference?: boolean
    orderDate?: boolean
    deliveryDate?: boolean
    deleted?: boolean
    orderState?: boolean
    selfCollect?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    orderId?: boolean
    customerReference?: boolean
    orderDate?: boolean
    deliveryDate?: boolean
    deleted?: boolean
    orderState?: boolean
    selfCollect?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    orderId?: boolean
    customerReference?: boolean
    orderDate?: boolean
    deliveryDate?: boolean
    deleted?: boolean
    orderState?: boolean
    selfCollect?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"orderId" | "customerReference" | "orderDate" | "deliveryDate" | "deleted" | "orderState" | "selfCollect", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    products?: boolean | Order$productsArgs<ExtArgs>
    invoice?: boolean | Order$invoiceArgs<ExtArgs>
    route?: boolean | Order$routeArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      products: Prisma.$OrderOnProductsPayload<ExtArgs>[]
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      route: Prisma.$RoutesOnOrdersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      orderId: string
      customerReference: number
      orderDate: Date
      deliveryDate: Date | null
      deleted: boolean
      orderState: $Enums.OrderState
      selfCollect: boolean
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `orderId`
     * const orderWithOrderIdOnly = await prisma.order.findMany({ select: { orderId: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `orderId`
     * const orderWithOrderIdOnly = await prisma.order.createManyAndReturn({
     *   select: { orderId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `orderId`
     * const orderWithOrderIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { orderId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    products<T extends Order$productsArgs<ExtArgs> = {}>(args?: Subset<T, Order$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderOnProductsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoice<T extends Order$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Order$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    route<T extends Order$routeArgs<ExtArgs> = {}>(args?: Subset<T, Order$routeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutesOnOrdersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly orderId: FieldRef<"Order", 'String'>
    readonly customerReference: FieldRef<"Order", 'Int'>
    readonly orderDate: FieldRef<"Order", 'DateTime'>
    readonly deliveryDate: FieldRef<"Order", 'DateTime'>
    readonly deleted: FieldRef<"Order", 'Boolean'>
    readonly orderState: FieldRef<"Order", 'OrderState'>
    readonly selfCollect: FieldRef<"Order", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.products
   */
  export type Order$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderOnProducts
     */
    select?: OrderOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderOnProducts
     */
    omit?: OrderOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderOnProductsInclude<ExtArgs> | null
    where?: OrderOnProductsWhereInput
    orderBy?: OrderOnProductsOrderByWithRelationInput | OrderOnProductsOrderByWithRelationInput[]
    cursor?: OrderOnProductsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderOnProductsScalarFieldEnum | OrderOnProductsScalarFieldEnum[]
  }

  /**
   * Order.invoice
   */
  export type Order$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Order.route
   */
  export type Order$routeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutesOnOrders
     */
    select?: RoutesOnOrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoutesOnOrders
     */
    omit?: RoutesOnOrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutesOnOrdersInclude<ExtArgs> | null
    where?: RoutesOnOrdersWhereInput
    orderBy?: RoutesOnOrdersOrderByWithRelationInput | RoutesOnOrdersOrderByWithRelationInput[]
    cursor?: RoutesOnOrdersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoutesOnOrdersScalarFieldEnum | RoutesOnOrdersScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    invoiceAmount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    invoiceAmount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    invoiceId: string | null
    orderId: string | null
    invoiceAmount: number | null
    paymentDate: Date | null
    pdfUrl: string | null
    deleted: boolean | null
  }

  export type InvoiceMaxAggregateOutputType = {
    invoiceId: string | null
    orderId: string | null
    invoiceAmount: number | null
    paymentDate: Date | null
    pdfUrl: string | null
    deleted: boolean | null
  }

  export type InvoiceCountAggregateOutputType = {
    invoiceId: number
    orderId: number
    invoiceAmount: number
    paymentDate: number
    pdfUrl: number
    deleted: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    invoiceAmount?: true
  }

  export type InvoiceSumAggregateInputType = {
    invoiceAmount?: true
  }

  export type InvoiceMinAggregateInputType = {
    invoiceId?: true
    orderId?: true
    invoiceAmount?: true
    paymentDate?: true
    pdfUrl?: true
    deleted?: true
  }

  export type InvoiceMaxAggregateInputType = {
    invoiceId?: true
    orderId?: true
    invoiceAmount?: true
    paymentDate?: true
    pdfUrl?: true
    deleted?: true
  }

  export type InvoiceCountAggregateInputType = {
    invoiceId?: true
    orderId?: true
    invoiceAmount?: true
    paymentDate?: true
    pdfUrl?: true
    deleted?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    invoiceId: string
    orderId: string
    invoiceAmount: number
    paymentDate: Date | null
    pdfUrl: string
    deleted: boolean
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    invoiceId?: boolean
    orderId?: boolean
    invoiceAmount?: boolean
    paymentDate?: boolean
    pdfUrl?: boolean
    deleted?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    invoiceId?: boolean
    orderId?: boolean
    invoiceAmount?: boolean
    paymentDate?: boolean
    pdfUrl?: boolean
    deleted?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    invoiceId?: boolean
    orderId?: boolean
    invoiceAmount?: boolean
    paymentDate?: boolean
    pdfUrl?: boolean
    deleted?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    invoiceId?: boolean
    orderId?: boolean
    invoiceAmount?: boolean
    paymentDate?: boolean
    pdfUrl?: boolean
    deleted?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"invoiceId" | "orderId" | "invoiceAmount" | "paymentDate" | "pdfUrl" | "deleted", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      invoiceId: string
      orderId: string
      invoiceAmount: number
      paymentDate: Date | null
      pdfUrl: string
      deleted: boolean
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `invoiceId`
     * const invoiceWithInvoiceIdOnly = await prisma.invoice.findMany({ select: { invoiceId: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `invoiceId`
     * const invoiceWithInvoiceIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { invoiceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `invoiceId`
     * const invoiceWithInvoiceIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { invoiceId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly invoiceId: FieldRef<"Invoice", 'String'>
    readonly orderId: FieldRef<"Invoice", 'String'>
    readonly invoiceAmount: FieldRef<"Invoice", 'Int'>
    readonly paymentDate: FieldRef<"Invoice", 'DateTime'>
    readonly pdfUrl: FieldRef<"Invoice", 'String'>
    readonly deleted: FieldRef<"Invoice", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Route
   */

  export type AggregateRoute = {
    _count: RouteCountAggregateOutputType | null
    _min: RouteMinAggregateOutputType | null
    _max: RouteMaxAggregateOutputType | null
  }

  export type RouteMinAggregateOutputType = {
    routeId: string | null
    name: string | null
    deleted: boolean | null
  }

  export type RouteMaxAggregateOutputType = {
    routeId: string | null
    name: string | null
    deleted: boolean | null
  }

  export type RouteCountAggregateOutputType = {
    routeId: number
    name: number
    deleted: number
    _all: number
  }


  export type RouteMinAggregateInputType = {
    routeId?: true
    name?: true
    deleted?: true
  }

  export type RouteMaxAggregateInputType = {
    routeId?: true
    name?: true
    deleted?: true
  }

  export type RouteCountAggregateInputType = {
    routeId?: true
    name?: true
    deleted?: true
    _all?: true
  }

  export type RouteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Route to aggregate.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Routes
    **/
    _count?: true | RouteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RouteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RouteMaxAggregateInputType
  }

  export type GetRouteAggregateType<T extends RouteAggregateArgs> = {
        [P in keyof T & keyof AggregateRoute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoute[P]>
      : GetScalarType<T[P], AggregateRoute[P]>
  }




  export type RouteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteWhereInput
    orderBy?: RouteOrderByWithAggregationInput | RouteOrderByWithAggregationInput[]
    by: RouteScalarFieldEnum[] | RouteScalarFieldEnum
    having?: RouteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RouteCountAggregateInputType | true
    _min?: RouteMinAggregateInputType
    _max?: RouteMaxAggregateInputType
  }

  export type RouteGroupByOutputType = {
    routeId: string
    name: string
    deleted: boolean
    _count: RouteCountAggregateOutputType | null
    _min: RouteMinAggregateOutputType | null
    _max: RouteMaxAggregateOutputType | null
  }

  type GetRouteGroupByPayload<T extends RouteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RouteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RouteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RouteGroupByOutputType[P]>
            : GetScalarType<T[P], RouteGroupByOutputType[P]>
        }
      >
    >


  export type RouteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    routeId?: boolean
    name?: boolean
    deleted?: boolean
    order?: boolean | Route$orderArgs<ExtArgs>
    _count?: boolean | RouteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["route"]>

  export type RouteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    routeId?: boolean
    name?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["route"]>

  export type RouteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    routeId?: boolean
    name?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["route"]>

  export type RouteSelectScalar = {
    routeId?: boolean
    name?: boolean
    deleted?: boolean
  }

  export type RouteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"routeId" | "name" | "deleted", ExtArgs["result"]["route"]>
  export type RouteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | Route$orderArgs<ExtArgs>
    _count?: boolean | RouteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RouteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RouteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RoutePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Route"
    objects: {
      order: Prisma.$RoutesOnOrdersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      routeId: string
      name: string
      deleted: boolean
    }, ExtArgs["result"]["route"]>
    composites: {}
  }

  type RouteGetPayload<S extends boolean | null | undefined | RouteDefaultArgs> = $Result.GetResult<Prisma.$RoutePayload, S>

  type RouteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RouteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RouteCountAggregateInputType | true
    }

  export interface RouteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Route'], meta: { name: 'Route' } }
    /**
     * Find zero or one Route that matches the filter.
     * @param {RouteFindUniqueArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RouteFindUniqueArgs>(args: SelectSubset<T, RouteFindUniqueArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Route that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RouteFindUniqueOrThrowArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RouteFindUniqueOrThrowArgs>(args: SelectSubset<T, RouteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Route that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFindFirstArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RouteFindFirstArgs>(args?: SelectSubset<T, RouteFindFirstArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Route that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFindFirstOrThrowArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RouteFindFirstOrThrowArgs>(args?: SelectSubset<T, RouteFindFirstOrThrowArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Routes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Routes
     * const routes = await prisma.route.findMany()
     * 
     * // Get first 10 Routes
     * const routes = await prisma.route.findMany({ take: 10 })
     * 
     * // Only select the `routeId`
     * const routeWithRouteIdOnly = await prisma.route.findMany({ select: { routeId: true } })
     * 
     */
    findMany<T extends RouteFindManyArgs>(args?: SelectSubset<T, RouteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Route.
     * @param {RouteCreateArgs} args - Arguments to create a Route.
     * @example
     * // Create one Route
     * const Route = await prisma.route.create({
     *   data: {
     *     // ... data to create a Route
     *   }
     * })
     * 
     */
    create<T extends RouteCreateArgs>(args: SelectSubset<T, RouteCreateArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Routes.
     * @param {RouteCreateManyArgs} args - Arguments to create many Routes.
     * @example
     * // Create many Routes
     * const route = await prisma.route.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RouteCreateManyArgs>(args?: SelectSubset<T, RouteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Routes and returns the data saved in the database.
     * @param {RouteCreateManyAndReturnArgs} args - Arguments to create many Routes.
     * @example
     * // Create many Routes
     * const route = await prisma.route.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Routes and only return the `routeId`
     * const routeWithRouteIdOnly = await prisma.route.createManyAndReturn({
     *   select: { routeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RouteCreateManyAndReturnArgs>(args?: SelectSubset<T, RouteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Route.
     * @param {RouteDeleteArgs} args - Arguments to delete one Route.
     * @example
     * // Delete one Route
     * const Route = await prisma.route.delete({
     *   where: {
     *     // ... filter to delete one Route
     *   }
     * })
     * 
     */
    delete<T extends RouteDeleteArgs>(args: SelectSubset<T, RouteDeleteArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Route.
     * @param {RouteUpdateArgs} args - Arguments to update one Route.
     * @example
     * // Update one Route
     * const route = await prisma.route.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RouteUpdateArgs>(args: SelectSubset<T, RouteUpdateArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Routes.
     * @param {RouteDeleteManyArgs} args - Arguments to filter Routes to delete.
     * @example
     * // Delete a few Routes
     * const { count } = await prisma.route.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RouteDeleteManyArgs>(args?: SelectSubset<T, RouteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Routes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Routes
     * const route = await prisma.route.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RouteUpdateManyArgs>(args: SelectSubset<T, RouteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Routes and returns the data updated in the database.
     * @param {RouteUpdateManyAndReturnArgs} args - Arguments to update many Routes.
     * @example
     * // Update many Routes
     * const route = await prisma.route.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Routes and only return the `routeId`
     * const routeWithRouteIdOnly = await prisma.route.updateManyAndReturn({
     *   select: { routeId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RouteUpdateManyAndReturnArgs>(args: SelectSubset<T, RouteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Route.
     * @param {RouteUpsertArgs} args - Arguments to update or create a Route.
     * @example
     * // Update or create a Route
     * const route = await prisma.route.upsert({
     *   create: {
     *     // ... data to create a Route
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Route we want to update
     *   }
     * })
     */
    upsert<T extends RouteUpsertArgs>(args: SelectSubset<T, RouteUpsertArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Routes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteCountArgs} args - Arguments to filter Routes to count.
     * @example
     * // Count the number of Routes
     * const count = await prisma.route.count({
     *   where: {
     *     // ... the filter for the Routes we want to count
     *   }
     * })
    **/
    count<T extends RouteCountArgs>(
      args?: Subset<T, RouteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RouteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Route.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RouteAggregateArgs>(args: Subset<T, RouteAggregateArgs>): Prisma.PrismaPromise<GetRouteAggregateType<T>>

    /**
     * Group by Route.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RouteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RouteGroupByArgs['orderBy'] }
        : { orderBy?: RouteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RouteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRouteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Route model
   */
  readonly fields: RouteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Route.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RouteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends Route$orderArgs<ExtArgs> = {}>(args?: Subset<T, Route$orderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutesOnOrdersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Route model
   */
  interface RouteFieldRefs {
    readonly routeId: FieldRef<"Route", 'String'>
    readonly name: FieldRef<"Route", 'String'>
    readonly deleted: FieldRef<"Route", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Route findUnique
   */
  export type RouteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where: RouteWhereUniqueInput
  }

  /**
   * Route findUniqueOrThrow
   */
  export type RouteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where: RouteWhereUniqueInput
  }

  /**
   * Route findFirst
   */
  export type RouteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Routes.
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Routes.
     */
    distinct?: RouteScalarFieldEnum | RouteScalarFieldEnum[]
  }

  /**
   * Route findFirstOrThrow
   */
  export type RouteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Routes.
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Routes.
     */
    distinct?: RouteScalarFieldEnum | RouteScalarFieldEnum[]
  }

  /**
   * Route findMany
   */
  export type RouteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Routes to fetch.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Routes.
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    distinct?: RouteScalarFieldEnum | RouteScalarFieldEnum[]
  }

  /**
   * Route create
   */
  export type RouteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * The data needed to create a Route.
     */
    data: XOR<RouteCreateInput, RouteUncheckedCreateInput>
  }

  /**
   * Route createMany
   */
  export type RouteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Routes.
     */
    data: RouteCreateManyInput | RouteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Route createManyAndReturn
   */
  export type RouteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * The data used to create many Routes.
     */
    data: RouteCreateManyInput | RouteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Route update
   */
  export type RouteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * The data needed to update a Route.
     */
    data: XOR<RouteUpdateInput, RouteUncheckedUpdateInput>
    /**
     * Choose, which Route to update.
     */
    where: RouteWhereUniqueInput
  }

  /**
   * Route updateMany
   */
  export type RouteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Routes.
     */
    data: XOR<RouteUpdateManyMutationInput, RouteUncheckedUpdateManyInput>
    /**
     * Filter which Routes to update
     */
    where?: RouteWhereInput
    /**
     * Limit how many Routes to update.
     */
    limit?: number
  }

  /**
   * Route updateManyAndReturn
   */
  export type RouteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * The data used to update Routes.
     */
    data: XOR<RouteUpdateManyMutationInput, RouteUncheckedUpdateManyInput>
    /**
     * Filter which Routes to update
     */
    where?: RouteWhereInput
    /**
     * Limit how many Routes to update.
     */
    limit?: number
  }

  /**
   * Route upsert
   */
  export type RouteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * The filter to search for the Route to update in case it exists.
     */
    where: RouteWhereUniqueInput
    /**
     * In case the Route found by the `where` argument doesn't exist, create a new Route with this data.
     */
    create: XOR<RouteCreateInput, RouteUncheckedCreateInput>
    /**
     * In case the Route was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RouteUpdateInput, RouteUncheckedUpdateInput>
  }

  /**
   * Route delete
   */
  export type RouteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter which Route to delete.
     */
    where: RouteWhereUniqueInput
  }

  /**
   * Route deleteMany
   */
  export type RouteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Routes to delete
     */
    where?: RouteWhereInput
    /**
     * Limit how many Routes to delete.
     */
    limit?: number
  }

  /**
   * Route.order
   */
  export type Route$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutesOnOrders
     */
    select?: RoutesOnOrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoutesOnOrders
     */
    omit?: RoutesOnOrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutesOnOrdersInclude<ExtArgs> | null
    where?: RoutesOnOrdersWhereInput
    orderBy?: RoutesOnOrdersOrderByWithRelationInput | RoutesOnOrdersOrderByWithRelationInput[]
    cursor?: RoutesOnOrdersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoutesOnOrdersScalarFieldEnum | RoutesOnOrdersScalarFieldEnum[]
  }

  /**
   * Route without action
   */
  export type RouteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
  }


  /**
   * Model Employees
   */

  export type AggregateEmployees = {
    _count: EmployeesCountAggregateOutputType | null
    _min: EmployeesMinAggregateOutputType | null
    _max: EmployeesMaxAggregateOutputType | null
  }

  export type EmployeesMinAggregateOutputType = {
    employeeId: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    deleted: boolean | null
    role: string | null
  }

  export type EmployeesMaxAggregateOutputType = {
    employeeId: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    deleted: boolean | null
    role: string | null
  }

  export type EmployeesCountAggregateOutputType = {
    employeeId: number
    email: number
    password: number
    firstName: number
    lastName: number
    deleted: number
    role: number
    _all: number
  }


  export type EmployeesMinAggregateInputType = {
    employeeId?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    deleted?: true
    role?: true
  }

  export type EmployeesMaxAggregateInputType = {
    employeeId?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    deleted?: true
    role?: true
  }

  export type EmployeesCountAggregateInputType = {
    employeeId?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    deleted?: true
    role?: true
    _all?: true
  }

  export type EmployeesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to aggregate.
     */
    where?: EmployeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeesOrderByWithRelationInput | EmployeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeesMaxAggregateInputType
  }

  export type GetEmployeesAggregateType<T extends EmployeesAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployees]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployees[P]>
      : GetScalarType<T[P], AggregateEmployees[P]>
  }




  export type EmployeesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeesWhereInput
    orderBy?: EmployeesOrderByWithAggregationInput | EmployeesOrderByWithAggregationInput[]
    by: EmployeesScalarFieldEnum[] | EmployeesScalarFieldEnum
    having?: EmployeesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeesCountAggregateInputType | true
    _min?: EmployeesMinAggregateInputType
    _max?: EmployeesMaxAggregateInputType
  }

  export type EmployeesGroupByOutputType = {
    employeeId: string
    email: string
    password: string
    firstName: string
    lastName: string
    deleted: boolean
    role: string
    _count: EmployeesCountAggregateOutputType | null
    _min: EmployeesMinAggregateOutputType | null
    _max: EmployeesMaxAggregateOutputType | null
  }

  type GetEmployeesGroupByPayload<T extends EmployeesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeesGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeesGroupByOutputType[P]>
        }
      >
    >


  export type EmployeesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employeeId?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    deleted?: boolean
    role?: boolean
    Role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employees"]>

  export type EmployeesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employeeId?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    deleted?: boolean
    role?: boolean
    Role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employees"]>

  export type EmployeesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employeeId?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    deleted?: boolean
    role?: boolean
    Role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employees"]>

  export type EmployeesSelectScalar = {
    employeeId?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    deleted?: boolean
    role?: boolean
  }

  export type EmployeesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"employeeId" | "email" | "password" | "firstName" | "lastName" | "deleted" | "role", ExtArgs["result"]["employees"]>
  export type EmployeesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type EmployeesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type EmployeesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $EmployeesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employees"
    objects: {
      Role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      employeeId: string
      email: string
      password: string
      firstName: string
      lastName: string
      deleted: boolean
      role: string
    }, ExtArgs["result"]["employees"]>
    composites: {}
  }

  type EmployeesGetPayload<S extends boolean | null | undefined | EmployeesDefaultArgs> = $Result.GetResult<Prisma.$EmployeesPayload, S>

  type EmployeesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeesCountAggregateInputType | true
    }

  export interface EmployeesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employees'], meta: { name: 'Employees' } }
    /**
     * Find zero or one Employees that matches the filter.
     * @param {EmployeesFindUniqueArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeesFindUniqueArgs>(args: SelectSubset<T, EmployeesFindUniqueArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employees that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeesFindUniqueOrThrowArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeesFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesFindFirstArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeesFindFirstArgs>(args?: SelectSubset<T, EmployeesFindFirstArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employees that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesFindFirstOrThrowArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeesFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeesFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employees.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employees.findMany({ take: 10 })
     * 
     * // Only select the `employeeId`
     * const employeesWithEmployeeIdOnly = await prisma.employees.findMany({ select: { employeeId: true } })
     * 
     */
    findMany<T extends EmployeesFindManyArgs>(args?: SelectSubset<T, EmployeesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employees.
     * @param {EmployeesCreateArgs} args - Arguments to create a Employees.
     * @example
     * // Create one Employees
     * const Employees = await prisma.employees.create({
     *   data: {
     *     // ... data to create a Employees
     *   }
     * })
     * 
     */
    create<T extends EmployeesCreateArgs>(args: SelectSubset<T, EmployeesCreateArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeesCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employees = await prisma.employees.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeesCreateManyArgs>(args?: SelectSubset<T, EmployeesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeesCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employees = await prisma.employees.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `employeeId`
     * const employeesWithEmployeeIdOnly = await prisma.employees.createManyAndReturn({
     *   select: { employeeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeesCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employees.
     * @param {EmployeesDeleteArgs} args - Arguments to delete one Employees.
     * @example
     * // Delete one Employees
     * const Employees = await prisma.employees.delete({
     *   where: {
     *     // ... filter to delete one Employees
     *   }
     * })
     * 
     */
    delete<T extends EmployeesDeleteArgs>(args: SelectSubset<T, EmployeesDeleteArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employees.
     * @param {EmployeesUpdateArgs} args - Arguments to update one Employees.
     * @example
     * // Update one Employees
     * const employees = await prisma.employees.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeesUpdateArgs>(args: SelectSubset<T, EmployeesUpdateArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeesDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employees.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeesDeleteManyArgs>(args?: SelectSubset<T, EmployeesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employees = await prisma.employees.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeesUpdateManyArgs>(args: SelectSubset<T, EmployeesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeesUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employees = await prisma.employees.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `employeeId`
     * const employeesWithEmployeeIdOnly = await prisma.employees.updateManyAndReturn({
     *   select: { employeeId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeesUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employees.
     * @param {EmployeesUpsertArgs} args - Arguments to update or create a Employees.
     * @example
     * // Update or create a Employees
     * const employees = await prisma.employees.upsert({
     *   create: {
     *     // ... data to create a Employees
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employees we want to update
     *   }
     * })
     */
    upsert<T extends EmployeesUpsertArgs>(args: SelectSubset<T, EmployeesUpsertArgs<ExtArgs>>): Prisma__EmployeesClient<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employees.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeesCountArgs>(
      args?: Subset<T, EmployeesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeesAggregateArgs>(args: Subset<T, EmployeesAggregateArgs>): Prisma.PrismaPromise<GetEmployeesAggregateType<T>>

    /**
     * Group by Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeesGroupByArgs['orderBy'] }
        : { orderBy?: EmployeesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employees model
   */
  readonly fields: EmployeesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employees.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employees model
   */
  interface EmployeesFieldRefs {
    readonly employeeId: FieldRef<"Employees", 'String'>
    readonly email: FieldRef<"Employees", 'String'>
    readonly password: FieldRef<"Employees", 'String'>
    readonly firstName: FieldRef<"Employees", 'String'>
    readonly lastName: FieldRef<"Employees", 'String'>
    readonly deleted: FieldRef<"Employees", 'Boolean'>
    readonly role: FieldRef<"Employees", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Employees findUnique
   */
  export type EmployeesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where: EmployeesWhereUniqueInput
  }

  /**
   * Employees findUniqueOrThrow
   */
  export type EmployeesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where: EmployeesWhereUniqueInput
  }

  /**
   * Employees findFirst
   */
  export type EmployeesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeesOrderByWithRelationInput | EmployeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeesScalarFieldEnum | EmployeesScalarFieldEnum[]
  }

  /**
   * Employees findFirstOrThrow
   */
  export type EmployeesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeesOrderByWithRelationInput | EmployeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeesScalarFieldEnum | EmployeesScalarFieldEnum[]
  }

  /**
   * Employees findMany
   */
  export type EmployeesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeesOrderByWithRelationInput | EmployeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeesScalarFieldEnum | EmployeesScalarFieldEnum[]
  }

  /**
   * Employees create
   */
  export type EmployeesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * The data needed to create a Employees.
     */
    data: XOR<EmployeesCreateInput, EmployeesUncheckedCreateInput>
  }

  /**
   * Employees createMany
   */
  export type EmployeesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeesCreateManyInput | EmployeesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employees createManyAndReturn
   */
  export type EmployeesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeesCreateManyInput | EmployeesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employees update
   */
  export type EmployeesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * The data needed to update a Employees.
     */
    data: XOR<EmployeesUpdateInput, EmployeesUncheckedUpdateInput>
    /**
     * Choose, which Employees to update.
     */
    where: EmployeesWhereUniqueInput
  }

  /**
   * Employees updateMany
   */
  export type EmployeesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeesUpdateManyMutationInput, EmployeesUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeesWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employees updateManyAndReturn
   */
  export type EmployeesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeesUpdateManyMutationInput, EmployeesUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeesWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employees upsert
   */
  export type EmployeesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * The filter to search for the Employees to update in case it exists.
     */
    where: EmployeesWhereUniqueInput
    /**
     * In case the Employees found by the `where` argument doesn't exist, create a new Employees with this data.
     */
    create: XOR<EmployeesCreateInput, EmployeesUncheckedCreateInput>
    /**
     * In case the Employees was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeesUpdateInput, EmployeesUncheckedUpdateInput>
  }

  /**
   * Employees delete
   */
  export type EmployeesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    /**
     * Filter which Employees to delete.
     */
    where: EmployeesWhereUniqueInput
  }

  /**
   * Employees deleteMany
   */
  export type EmployeesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeesWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employees without action
   */
  export type EmployeesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
  }


  /**
   * Model SiteConfig
   */

  export type AggregateSiteConfig = {
    _count: SiteConfigCountAggregateOutputType | null
    _min: SiteConfigMinAggregateOutputType | null
    _max: SiteConfigMaxAggregateOutputType | null
  }

  export type SiteConfigMinAggregateOutputType = {
    siteConfigId: string | null
    companyName: string | null
    logoPath: string | null
    email: string | null
    phoneNumber: string | null
    iban: string | null
    companyNumber: string | null
    addressId: string | null
    modifiedAt: Date | null
    isPremium: boolean | null
    deleted: boolean | null
    stripeCustomerId: string | null
    stripeAccountId: string | null
    stripeConfigured: boolean | null
  }

  export type SiteConfigMaxAggregateOutputType = {
    siteConfigId: string | null
    companyName: string | null
    logoPath: string | null
    email: string | null
    phoneNumber: string | null
    iban: string | null
    companyNumber: string | null
    addressId: string | null
    modifiedAt: Date | null
    isPremium: boolean | null
    deleted: boolean | null
    stripeCustomerId: string | null
    stripeAccountId: string | null
    stripeConfigured: boolean | null
  }

  export type SiteConfigCountAggregateOutputType = {
    siteConfigId: number
    companyName: number
    logoPath: number
    email: number
    phoneNumber: number
    iban: number
    companyNumber: number
    addressId: number
    modifiedAt: number
    isPremium: number
    deleted: number
    stripeCustomerId: number
    stripeAccountId: number
    stripeConfigured: number
    _all: number
  }


  export type SiteConfigMinAggregateInputType = {
    siteConfigId?: true
    companyName?: true
    logoPath?: true
    email?: true
    phoneNumber?: true
    iban?: true
    companyNumber?: true
    addressId?: true
    modifiedAt?: true
    isPremium?: true
    deleted?: true
    stripeCustomerId?: true
    stripeAccountId?: true
    stripeConfigured?: true
  }

  export type SiteConfigMaxAggregateInputType = {
    siteConfigId?: true
    companyName?: true
    logoPath?: true
    email?: true
    phoneNumber?: true
    iban?: true
    companyNumber?: true
    addressId?: true
    modifiedAt?: true
    isPremium?: true
    deleted?: true
    stripeCustomerId?: true
    stripeAccountId?: true
    stripeConfigured?: true
  }

  export type SiteConfigCountAggregateInputType = {
    siteConfigId?: true
    companyName?: true
    logoPath?: true
    email?: true
    phoneNumber?: true
    iban?: true
    companyNumber?: true
    addressId?: true
    modifiedAt?: true
    isPremium?: true
    deleted?: true
    stripeCustomerId?: true
    stripeAccountId?: true
    stripeConfigured?: true
    _all?: true
  }

  export type SiteConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteConfig to aggregate.
     */
    where?: SiteConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteConfigs to fetch.
     */
    orderBy?: SiteConfigOrderByWithRelationInput | SiteConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SiteConfigs
    **/
    _count?: true | SiteConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteConfigMaxAggregateInputType
  }

  export type GetSiteConfigAggregateType<T extends SiteConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateSiteConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSiteConfig[P]>
      : GetScalarType<T[P], AggregateSiteConfig[P]>
  }




  export type SiteConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteConfigWhereInput
    orderBy?: SiteConfigOrderByWithAggregationInput | SiteConfigOrderByWithAggregationInput[]
    by: SiteConfigScalarFieldEnum[] | SiteConfigScalarFieldEnum
    having?: SiteConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteConfigCountAggregateInputType | true
    _min?: SiteConfigMinAggregateInputType
    _max?: SiteConfigMaxAggregateInputType
  }

  export type SiteConfigGroupByOutputType = {
    siteConfigId: string
    companyName: string
    logoPath: string
    email: string
    phoneNumber: string
    iban: string
    companyNumber: string
    addressId: string
    modifiedAt: Date | null
    isPremium: boolean
    deleted: boolean
    stripeCustomerId: string | null
    stripeAccountId: string | null
    stripeConfigured: boolean
    _count: SiteConfigCountAggregateOutputType | null
    _min: SiteConfigMinAggregateOutputType | null
    _max: SiteConfigMaxAggregateOutputType | null
  }

  type GetSiteConfigGroupByPayload<T extends SiteConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SiteConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteConfigGroupByOutputType[P]>
            : GetScalarType<T[P], SiteConfigGroupByOutputType[P]>
        }
      >
    >


  export type SiteConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    siteConfigId?: boolean
    companyName?: boolean
    logoPath?: boolean
    email?: boolean
    phoneNumber?: boolean
    iban?: boolean
    companyNumber?: boolean
    addressId?: boolean
    modifiedAt?: boolean
    isPremium?: boolean
    deleted?: boolean
    stripeCustomerId?: boolean
    stripeAccountId?: boolean
    stripeConfigured?: boolean
    address?: boolean | AddressDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["siteConfig"]>

  export type SiteConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    siteConfigId?: boolean
    companyName?: boolean
    logoPath?: boolean
    email?: boolean
    phoneNumber?: boolean
    iban?: boolean
    companyNumber?: boolean
    addressId?: boolean
    modifiedAt?: boolean
    isPremium?: boolean
    deleted?: boolean
    stripeCustomerId?: boolean
    stripeAccountId?: boolean
    stripeConfigured?: boolean
    address?: boolean | AddressDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["siteConfig"]>

  export type SiteConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    siteConfigId?: boolean
    companyName?: boolean
    logoPath?: boolean
    email?: boolean
    phoneNumber?: boolean
    iban?: boolean
    companyNumber?: boolean
    addressId?: boolean
    modifiedAt?: boolean
    isPremium?: boolean
    deleted?: boolean
    stripeCustomerId?: boolean
    stripeAccountId?: boolean
    stripeConfigured?: boolean
    address?: boolean | AddressDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["siteConfig"]>

  export type SiteConfigSelectScalar = {
    siteConfigId?: boolean
    companyName?: boolean
    logoPath?: boolean
    email?: boolean
    phoneNumber?: boolean
    iban?: boolean
    companyNumber?: boolean
    addressId?: boolean
    modifiedAt?: boolean
    isPremium?: boolean
    deleted?: boolean
    stripeCustomerId?: boolean
    stripeAccountId?: boolean
    stripeConfigured?: boolean
  }

  export type SiteConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"siteConfigId" | "companyName" | "logoPath" | "email" | "phoneNumber" | "iban" | "companyNumber" | "addressId" | "modifiedAt" | "isPremium" | "deleted" | "stripeCustomerId" | "stripeAccountId" | "stripeConfigured", ExtArgs["result"]["siteConfig"]>
  export type SiteConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | AddressDefaultArgs<ExtArgs>
  }
  export type SiteConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | AddressDefaultArgs<ExtArgs>
  }
  export type SiteConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | AddressDefaultArgs<ExtArgs>
  }

  export type $SiteConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SiteConfig"
    objects: {
      address: Prisma.$AddressPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      siteConfigId: string
      companyName: string
      logoPath: string
      email: string
      phoneNumber: string
      iban: string
      companyNumber: string
      addressId: string
      modifiedAt: Date | null
      isPremium: boolean
      deleted: boolean
      stripeCustomerId: string | null
      stripeAccountId: string | null
      stripeConfigured: boolean
    }, ExtArgs["result"]["siteConfig"]>
    composites: {}
  }

  type SiteConfigGetPayload<S extends boolean | null | undefined | SiteConfigDefaultArgs> = $Result.GetResult<Prisma.$SiteConfigPayload, S>

  type SiteConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SiteConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SiteConfigCountAggregateInputType | true
    }

  export interface SiteConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SiteConfig'], meta: { name: 'SiteConfig' } }
    /**
     * Find zero or one SiteConfig that matches the filter.
     * @param {SiteConfigFindUniqueArgs} args - Arguments to find a SiteConfig
     * @example
     * // Get one SiteConfig
     * const siteConfig = await prisma.siteConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SiteConfigFindUniqueArgs>(args: SelectSubset<T, SiteConfigFindUniqueArgs<ExtArgs>>): Prisma__SiteConfigClient<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SiteConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SiteConfigFindUniqueOrThrowArgs} args - Arguments to find a SiteConfig
     * @example
     * // Get one SiteConfig
     * const siteConfig = await prisma.siteConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SiteConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, SiteConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SiteConfigClient<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigFindFirstArgs} args - Arguments to find a SiteConfig
     * @example
     * // Get one SiteConfig
     * const siteConfig = await prisma.siteConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SiteConfigFindFirstArgs>(args?: SelectSubset<T, SiteConfigFindFirstArgs<ExtArgs>>): Prisma__SiteConfigClient<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigFindFirstOrThrowArgs} args - Arguments to find a SiteConfig
     * @example
     * // Get one SiteConfig
     * const siteConfig = await prisma.siteConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SiteConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, SiteConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__SiteConfigClient<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SiteConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SiteConfigs
     * const siteConfigs = await prisma.siteConfig.findMany()
     * 
     * // Get first 10 SiteConfigs
     * const siteConfigs = await prisma.siteConfig.findMany({ take: 10 })
     * 
     * // Only select the `siteConfigId`
     * const siteConfigWithSiteConfigIdOnly = await prisma.siteConfig.findMany({ select: { siteConfigId: true } })
     * 
     */
    findMany<T extends SiteConfigFindManyArgs>(args?: SelectSubset<T, SiteConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SiteConfig.
     * @param {SiteConfigCreateArgs} args - Arguments to create a SiteConfig.
     * @example
     * // Create one SiteConfig
     * const SiteConfig = await prisma.siteConfig.create({
     *   data: {
     *     // ... data to create a SiteConfig
     *   }
     * })
     * 
     */
    create<T extends SiteConfigCreateArgs>(args: SelectSubset<T, SiteConfigCreateArgs<ExtArgs>>): Prisma__SiteConfigClient<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SiteConfigs.
     * @param {SiteConfigCreateManyArgs} args - Arguments to create many SiteConfigs.
     * @example
     * // Create many SiteConfigs
     * const siteConfig = await prisma.siteConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SiteConfigCreateManyArgs>(args?: SelectSubset<T, SiteConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SiteConfigs and returns the data saved in the database.
     * @param {SiteConfigCreateManyAndReturnArgs} args - Arguments to create many SiteConfigs.
     * @example
     * // Create many SiteConfigs
     * const siteConfig = await prisma.siteConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SiteConfigs and only return the `siteConfigId`
     * const siteConfigWithSiteConfigIdOnly = await prisma.siteConfig.createManyAndReturn({
     *   select: { siteConfigId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SiteConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, SiteConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SiteConfig.
     * @param {SiteConfigDeleteArgs} args - Arguments to delete one SiteConfig.
     * @example
     * // Delete one SiteConfig
     * const SiteConfig = await prisma.siteConfig.delete({
     *   where: {
     *     // ... filter to delete one SiteConfig
     *   }
     * })
     * 
     */
    delete<T extends SiteConfigDeleteArgs>(args: SelectSubset<T, SiteConfigDeleteArgs<ExtArgs>>): Prisma__SiteConfigClient<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SiteConfig.
     * @param {SiteConfigUpdateArgs} args - Arguments to update one SiteConfig.
     * @example
     * // Update one SiteConfig
     * const siteConfig = await prisma.siteConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SiteConfigUpdateArgs>(args: SelectSubset<T, SiteConfigUpdateArgs<ExtArgs>>): Prisma__SiteConfigClient<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SiteConfigs.
     * @param {SiteConfigDeleteManyArgs} args - Arguments to filter SiteConfigs to delete.
     * @example
     * // Delete a few SiteConfigs
     * const { count } = await prisma.siteConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SiteConfigDeleteManyArgs>(args?: SelectSubset<T, SiteConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SiteConfigs
     * const siteConfig = await prisma.siteConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SiteConfigUpdateManyArgs>(args: SelectSubset<T, SiteConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteConfigs and returns the data updated in the database.
     * @param {SiteConfigUpdateManyAndReturnArgs} args - Arguments to update many SiteConfigs.
     * @example
     * // Update many SiteConfigs
     * const siteConfig = await prisma.siteConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SiteConfigs and only return the `siteConfigId`
     * const siteConfigWithSiteConfigIdOnly = await prisma.siteConfig.updateManyAndReturn({
     *   select: { siteConfigId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SiteConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, SiteConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SiteConfig.
     * @param {SiteConfigUpsertArgs} args - Arguments to update or create a SiteConfig.
     * @example
     * // Update or create a SiteConfig
     * const siteConfig = await prisma.siteConfig.upsert({
     *   create: {
     *     // ... data to create a SiteConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SiteConfig we want to update
     *   }
     * })
     */
    upsert<T extends SiteConfigUpsertArgs>(args: SelectSubset<T, SiteConfigUpsertArgs<ExtArgs>>): Prisma__SiteConfigClient<$Result.GetResult<Prisma.$SiteConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SiteConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigCountArgs} args - Arguments to filter SiteConfigs to count.
     * @example
     * // Count the number of SiteConfigs
     * const count = await prisma.siteConfig.count({
     *   where: {
     *     // ... the filter for the SiteConfigs we want to count
     *   }
     * })
    **/
    count<T extends SiteConfigCountArgs>(
      args?: Subset<T, SiteConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SiteConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteConfigAggregateArgs>(args: Subset<T, SiteConfigAggregateArgs>): Prisma.PrismaPromise<GetSiteConfigAggregateType<T>>

    /**
     * Group by SiteConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteConfigGroupByArgs['orderBy'] }
        : { orderBy?: SiteConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SiteConfig model
   */
  readonly fields: SiteConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SiteConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SiteConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    address<T extends AddressDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddressDefaultArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SiteConfig model
   */
  interface SiteConfigFieldRefs {
    readonly siteConfigId: FieldRef<"SiteConfig", 'String'>
    readonly companyName: FieldRef<"SiteConfig", 'String'>
    readonly logoPath: FieldRef<"SiteConfig", 'String'>
    readonly email: FieldRef<"SiteConfig", 'String'>
    readonly phoneNumber: FieldRef<"SiteConfig", 'String'>
    readonly iban: FieldRef<"SiteConfig", 'String'>
    readonly companyNumber: FieldRef<"SiteConfig", 'String'>
    readonly addressId: FieldRef<"SiteConfig", 'String'>
    readonly modifiedAt: FieldRef<"SiteConfig", 'DateTime'>
    readonly isPremium: FieldRef<"SiteConfig", 'Boolean'>
    readonly deleted: FieldRef<"SiteConfig", 'Boolean'>
    readonly stripeCustomerId: FieldRef<"SiteConfig", 'String'>
    readonly stripeAccountId: FieldRef<"SiteConfig", 'String'>
    readonly stripeConfigured: FieldRef<"SiteConfig", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * SiteConfig findUnique
   */
  export type SiteConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfig
     */
    omit?: SiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigInclude<ExtArgs> | null
    /**
     * Filter, which SiteConfig to fetch.
     */
    where: SiteConfigWhereUniqueInput
  }

  /**
   * SiteConfig findUniqueOrThrow
   */
  export type SiteConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfig
     */
    omit?: SiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigInclude<ExtArgs> | null
    /**
     * Filter, which SiteConfig to fetch.
     */
    where: SiteConfigWhereUniqueInput
  }

  /**
   * SiteConfig findFirst
   */
  export type SiteConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfig
     */
    omit?: SiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigInclude<ExtArgs> | null
    /**
     * Filter, which SiteConfig to fetch.
     */
    where?: SiteConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteConfigs to fetch.
     */
    orderBy?: SiteConfigOrderByWithRelationInput | SiteConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteConfigs.
     */
    cursor?: SiteConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteConfigs.
     */
    distinct?: SiteConfigScalarFieldEnum | SiteConfigScalarFieldEnum[]
  }

  /**
   * SiteConfig findFirstOrThrow
   */
  export type SiteConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfig
     */
    omit?: SiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigInclude<ExtArgs> | null
    /**
     * Filter, which SiteConfig to fetch.
     */
    where?: SiteConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteConfigs to fetch.
     */
    orderBy?: SiteConfigOrderByWithRelationInput | SiteConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteConfigs.
     */
    cursor?: SiteConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteConfigs.
     */
    distinct?: SiteConfigScalarFieldEnum | SiteConfigScalarFieldEnum[]
  }

  /**
   * SiteConfig findMany
   */
  export type SiteConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfig
     */
    omit?: SiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigInclude<ExtArgs> | null
    /**
     * Filter, which SiteConfigs to fetch.
     */
    where?: SiteConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteConfigs to fetch.
     */
    orderBy?: SiteConfigOrderByWithRelationInput | SiteConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SiteConfigs.
     */
    cursor?: SiteConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteConfigs.
     */
    skip?: number
    distinct?: SiteConfigScalarFieldEnum | SiteConfigScalarFieldEnum[]
  }

  /**
   * SiteConfig create
   */
  export type SiteConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfig
     */
    omit?: SiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a SiteConfig.
     */
    data: XOR<SiteConfigCreateInput, SiteConfigUncheckedCreateInput>
  }

  /**
   * SiteConfig createMany
   */
  export type SiteConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SiteConfigs.
     */
    data: SiteConfigCreateManyInput | SiteConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SiteConfig createManyAndReturn
   */
  export type SiteConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfig
     */
    omit?: SiteConfigOmit<ExtArgs> | null
    /**
     * The data used to create many SiteConfigs.
     */
    data: SiteConfigCreateManyInput | SiteConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SiteConfig update
   */
  export type SiteConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfig
     */
    omit?: SiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a SiteConfig.
     */
    data: XOR<SiteConfigUpdateInput, SiteConfigUncheckedUpdateInput>
    /**
     * Choose, which SiteConfig to update.
     */
    where: SiteConfigWhereUniqueInput
  }

  /**
   * SiteConfig updateMany
   */
  export type SiteConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SiteConfigs.
     */
    data: XOR<SiteConfigUpdateManyMutationInput, SiteConfigUncheckedUpdateManyInput>
    /**
     * Filter which SiteConfigs to update
     */
    where?: SiteConfigWhereInput
    /**
     * Limit how many SiteConfigs to update.
     */
    limit?: number
  }

  /**
   * SiteConfig updateManyAndReturn
   */
  export type SiteConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfig
     */
    omit?: SiteConfigOmit<ExtArgs> | null
    /**
     * The data used to update SiteConfigs.
     */
    data: XOR<SiteConfigUpdateManyMutationInput, SiteConfigUncheckedUpdateManyInput>
    /**
     * Filter which SiteConfigs to update
     */
    where?: SiteConfigWhereInput
    /**
     * Limit how many SiteConfigs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SiteConfig upsert
   */
  export type SiteConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfig
     */
    omit?: SiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the SiteConfig to update in case it exists.
     */
    where: SiteConfigWhereUniqueInput
    /**
     * In case the SiteConfig found by the `where` argument doesn't exist, create a new SiteConfig with this data.
     */
    create: XOR<SiteConfigCreateInput, SiteConfigUncheckedCreateInput>
    /**
     * In case the SiteConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteConfigUpdateInput, SiteConfigUncheckedUpdateInput>
  }

  /**
   * SiteConfig delete
   */
  export type SiteConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfig
     */
    omit?: SiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigInclude<ExtArgs> | null
    /**
     * Filter which SiteConfig to delete.
     */
    where: SiteConfigWhereUniqueInput
  }

  /**
   * SiteConfig deleteMany
   */
  export type SiteConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteConfigs to delete
     */
    where?: SiteConfigWhereInput
    /**
     * Limit how many SiteConfigs to delete.
     */
    limit?: number
  }

  /**
   * SiteConfig without action
   */
  export type SiteConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfig
     */
    select?: SiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfig
     */
    omit?: SiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SiteConfigInclude<ExtArgs> | null
  }


  /**
   * Model Action
   */

  export type AggregateAction = {
    _count: ActionCountAggregateOutputType | null
    _min: ActionMinAggregateOutputType | null
    _max: ActionMaxAggregateOutputType | null
  }

  export type ActionMinAggregateOutputType = {
    name: $Enums.Actions | null
    description: string | null
    deleted: boolean | null
  }

  export type ActionMaxAggregateOutputType = {
    name: $Enums.Actions | null
    description: string | null
    deleted: boolean | null
  }

  export type ActionCountAggregateOutputType = {
    name: number
    description: number
    deleted: number
    _all: number
  }


  export type ActionMinAggregateInputType = {
    name?: true
    description?: true
    deleted?: true
  }

  export type ActionMaxAggregateInputType = {
    name?: true
    description?: true
    deleted?: true
  }

  export type ActionCountAggregateInputType = {
    name?: true
    description?: true
    deleted?: true
    _all?: true
  }

  export type ActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Action to aggregate.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Actions
    **/
    _count?: true | ActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActionMaxAggregateInputType
  }

  export type GetActionAggregateType<T extends ActionAggregateArgs> = {
        [P in keyof T & keyof AggregateAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAction[P]>
      : GetScalarType<T[P], AggregateAction[P]>
  }




  export type ActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionWhereInput
    orderBy?: ActionOrderByWithAggregationInput | ActionOrderByWithAggregationInput[]
    by: ActionScalarFieldEnum[] | ActionScalarFieldEnum
    having?: ActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActionCountAggregateInputType | true
    _min?: ActionMinAggregateInputType
    _max?: ActionMaxAggregateInputType
  }

  export type ActionGroupByOutputType = {
    name: $Enums.Actions
    description: string | null
    deleted: boolean
    _count: ActionCountAggregateOutputType | null
    _min: ActionMinAggregateOutputType | null
    _max: ActionMaxAggregateOutputType | null
  }

  type GetActionGroupByPayload<T extends ActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActionGroupByOutputType[P]>
            : GetScalarType<T[P], ActionGroupByOutputType[P]>
        }
      >
    >


  export type ActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    deleted?: boolean
    resourceLinks?: boolean | Action$resourceLinksArgs<ExtArgs>
    _count?: boolean | ActionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["action"]>

  export type ActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["action"]>

  export type ActionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["action"]>

  export type ActionSelectScalar = {
    name?: boolean
    description?: boolean
    deleted?: boolean
  }

  export type ActionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"name" | "description" | "deleted", ExtArgs["result"]["action"]>
  export type ActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resourceLinks?: boolean | Action$resourceLinksArgs<ExtArgs>
    _count?: boolean | ActionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ActionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Action"
    objects: {
      resourceLinks: Prisma.$ResourceActionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      name: $Enums.Actions
      description: string | null
      deleted: boolean
    }, ExtArgs["result"]["action"]>
    composites: {}
  }

  type ActionGetPayload<S extends boolean | null | undefined | ActionDefaultArgs> = $Result.GetResult<Prisma.$ActionPayload, S>

  type ActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActionCountAggregateInputType | true
    }

  export interface ActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Action'], meta: { name: 'Action' } }
    /**
     * Find zero or one Action that matches the filter.
     * @param {ActionFindUniqueArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActionFindUniqueArgs>(args: SelectSubset<T, ActionFindUniqueArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Action that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActionFindUniqueOrThrowArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActionFindUniqueOrThrowArgs>(args: SelectSubset<T, ActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Action that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionFindFirstArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActionFindFirstArgs>(args?: SelectSubset<T, ActionFindFirstArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Action that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionFindFirstOrThrowArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActionFindFirstOrThrowArgs>(args?: SelectSubset<T, ActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Actions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Actions
     * const actions = await prisma.action.findMany()
     * 
     * // Get first 10 Actions
     * const actions = await prisma.action.findMany({ take: 10 })
     * 
     * // Only select the `description`
     * const actionWithDescriptionOnly = await prisma.action.findMany({ select: { description: true } })
     * 
     */
    findMany<T extends ActionFindManyArgs>(args?: SelectSubset<T, ActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Action.
     * @param {ActionCreateArgs} args - Arguments to create a Action.
     * @example
     * // Create one Action
     * const Action = await prisma.action.create({
     *   data: {
     *     // ... data to create a Action
     *   }
     * })
     * 
     */
    create<T extends ActionCreateArgs>(args: SelectSubset<T, ActionCreateArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Actions.
     * @param {ActionCreateManyArgs} args - Arguments to create many Actions.
     * @example
     * // Create many Actions
     * const action = await prisma.action.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActionCreateManyArgs>(args?: SelectSubset<T, ActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Actions and returns the data saved in the database.
     * @param {ActionCreateManyAndReturnArgs} args - Arguments to create many Actions.
     * @example
     * // Create many Actions
     * const action = await prisma.action.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Actions and only return the `description`
     * const actionWithDescriptionOnly = await prisma.action.createManyAndReturn({
     *   select: { description: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActionCreateManyAndReturnArgs>(args?: SelectSubset<T, ActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Action.
     * @param {ActionDeleteArgs} args - Arguments to delete one Action.
     * @example
     * // Delete one Action
     * const Action = await prisma.action.delete({
     *   where: {
     *     // ... filter to delete one Action
     *   }
     * })
     * 
     */
    delete<T extends ActionDeleteArgs>(args: SelectSubset<T, ActionDeleteArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Action.
     * @param {ActionUpdateArgs} args - Arguments to update one Action.
     * @example
     * // Update one Action
     * const action = await prisma.action.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActionUpdateArgs>(args: SelectSubset<T, ActionUpdateArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Actions.
     * @param {ActionDeleteManyArgs} args - Arguments to filter Actions to delete.
     * @example
     * // Delete a few Actions
     * const { count } = await prisma.action.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActionDeleteManyArgs>(args?: SelectSubset<T, ActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Actions
     * const action = await prisma.action.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActionUpdateManyArgs>(args: SelectSubset<T, ActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actions and returns the data updated in the database.
     * @param {ActionUpdateManyAndReturnArgs} args - Arguments to update many Actions.
     * @example
     * // Update many Actions
     * const action = await prisma.action.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Actions and only return the `description`
     * const actionWithDescriptionOnly = await prisma.action.updateManyAndReturn({
     *   select: { description: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActionUpdateManyAndReturnArgs>(args: SelectSubset<T, ActionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Action.
     * @param {ActionUpsertArgs} args - Arguments to update or create a Action.
     * @example
     * // Update or create a Action
     * const action = await prisma.action.upsert({
     *   create: {
     *     // ... data to create a Action
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Action we want to update
     *   }
     * })
     */
    upsert<T extends ActionUpsertArgs>(args: SelectSubset<T, ActionUpsertArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionCountArgs} args - Arguments to filter Actions to count.
     * @example
     * // Count the number of Actions
     * const count = await prisma.action.count({
     *   where: {
     *     // ... the filter for the Actions we want to count
     *   }
     * })
    **/
    count<T extends ActionCountArgs>(
      args?: Subset<T, ActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Action.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActionAggregateArgs>(args: Subset<T, ActionAggregateArgs>): Prisma.PrismaPromise<GetActionAggregateType<T>>

    /**
     * Group by Action.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActionGroupByArgs['orderBy'] }
        : { orderBy?: ActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Action model
   */
  readonly fields: ActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Action.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resourceLinks<T extends Action$resourceLinksArgs<ExtArgs> = {}>(args?: Subset<T, Action$resourceLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Action model
   */
  interface ActionFieldRefs {
    readonly name: FieldRef<"Action", 'Actions'>
    readonly description: FieldRef<"Action", 'String'>
    readonly deleted: FieldRef<"Action", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Action findUnique
   */
  export type ActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action findUniqueOrThrow
   */
  export type ActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action findFirst
   */
  export type ActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actions.
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actions.
     */
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Action findFirstOrThrow
   */
  export type ActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actions.
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actions.
     */
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Action findMany
   */
  export type ActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Actions to fetch.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Actions.
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Action create
   */
  export type ActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * The data needed to create a Action.
     */
    data: XOR<ActionCreateInput, ActionUncheckedCreateInput>
  }

  /**
   * Action createMany
   */
  export type ActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Actions.
     */
    data: ActionCreateManyInput | ActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Action createManyAndReturn
   */
  export type ActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * The data used to create many Actions.
     */
    data: ActionCreateManyInput | ActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Action update
   */
  export type ActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * The data needed to update a Action.
     */
    data: XOR<ActionUpdateInput, ActionUncheckedUpdateInput>
    /**
     * Choose, which Action to update.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action updateMany
   */
  export type ActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Actions.
     */
    data: XOR<ActionUpdateManyMutationInput, ActionUncheckedUpdateManyInput>
    /**
     * Filter which Actions to update
     */
    where?: ActionWhereInput
    /**
     * Limit how many Actions to update.
     */
    limit?: number
  }

  /**
   * Action updateManyAndReturn
   */
  export type ActionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * The data used to update Actions.
     */
    data: XOR<ActionUpdateManyMutationInput, ActionUncheckedUpdateManyInput>
    /**
     * Filter which Actions to update
     */
    where?: ActionWhereInput
    /**
     * Limit how many Actions to update.
     */
    limit?: number
  }

  /**
   * Action upsert
   */
  export type ActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * The filter to search for the Action to update in case it exists.
     */
    where: ActionWhereUniqueInput
    /**
     * In case the Action found by the `where` argument doesn't exist, create a new Action with this data.
     */
    create: XOR<ActionCreateInput, ActionUncheckedCreateInput>
    /**
     * In case the Action was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActionUpdateInput, ActionUncheckedUpdateInput>
  }

  /**
   * Action delete
   */
  export type ActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter which Action to delete.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action deleteMany
   */
  export type ActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Actions to delete
     */
    where?: ActionWhereInput
    /**
     * Limit how many Actions to delete.
     */
    limit?: number
  }

  /**
   * Action.resourceLinks
   */
  export type Action$resourceLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceAction
     */
    select?: ResourceActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceAction
     */
    omit?: ResourceActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceActionInclude<ExtArgs> | null
    where?: ResourceActionWhereInput
    orderBy?: ResourceActionOrderByWithRelationInput | ResourceActionOrderByWithRelationInput[]
    cursor?: ResourceActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceActionScalarFieldEnum | ResourceActionScalarFieldEnum[]
  }

  /**
   * Action without action
   */
  export type ActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
  }


  /**
   * Model Ressource
   */

  export type AggregateRessource = {
    _count: RessourceCountAggregateOutputType | null
    _min: RessourceMinAggregateOutputType | null
    _max: RessourceMaxAggregateOutputType | null
  }

  export type RessourceMinAggregateOutputType = {
    name: $Enums.Ressources | null
    description: string | null
    deleted: boolean | null
  }

  export type RessourceMaxAggregateOutputType = {
    name: $Enums.Ressources | null
    description: string | null
    deleted: boolean | null
  }

  export type RessourceCountAggregateOutputType = {
    name: number
    description: number
    deleted: number
    _all: number
  }


  export type RessourceMinAggregateInputType = {
    name?: true
    description?: true
    deleted?: true
  }

  export type RessourceMaxAggregateInputType = {
    name?: true
    description?: true
    deleted?: true
  }

  export type RessourceCountAggregateInputType = {
    name?: true
    description?: true
    deleted?: true
    _all?: true
  }

  export type RessourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ressource to aggregate.
     */
    where?: RessourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ressources to fetch.
     */
    orderBy?: RessourceOrderByWithRelationInput | RessourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RessourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ressources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ressources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ressources
    **/
    _count?: true | RessourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RessourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RessourceMaxAggregateInputType
  }

  export type GetRessourceAggregateType<T extends RessourceAggregateArgs> = {
        [P in keyof T & keyof AggregateRessource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRessource[P]>
      : GetScalarType<T[P], AggregateRessource[P]>
  }




  export type RessourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RessourceWhereInput
    orderBy?: RessourceOrderByWithAggregationInput | RessourceOrderByWithAggregationInput[]
    by: RessourceScalarFieldEnum[] | RessourceScalarFieldEnum
    having?: RessourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RessourceCountAggregateInputType | true
    _min?: RessourceMinAggregateInputType
    _max?: RessourceMaxAggregateInputType
  }

  export type RessourceGroupByOutputType = {
    name: $Enums.Ressources
    description: string | null
    deleted: boolean
    _count: RessourceCountAggregateOutputType | null
    _min: RessourceMinAggregateOutputType | null
    _max: RessourceMaxAggregateOutputType | null
  }

  type GetRessourceGroupByPayload<T extends RessourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RessourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RessourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RessourceGroupByOutputType[P]>
            : GetScalarType<T[P], RessourceGroupByOutputType[P]>
        }
      >
    >


  export type RessourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    deleted?: boolean
    actionLinks?: boolean | Ressource$actionLinksArgs<ExtArgs>
    _count?: boolean | RessourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ressource"]>

  export type RessourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["ressource"]>

  export type RessourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["ressource"]>

  export type RessourceSelectScalar = {
    name?: boolean
    description?: boolean
    deleted?: boolean
  }

  export type RessourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"name" | "description" | "deleted", ExtArgs["result"]["ressource"]>
  export type RessourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actionLinks?: boolean | Ressource$actionLinksArgs<ExtArgs>
    _count?: boolean | RessourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RessourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RessourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RessourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ressource"
    objects: {
      actionLinks: Prisma.$ResourceActionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      name: $Enums.Ressources
      description: string | null
      deleted: boolean
    }, ExtArgs["result"]["ressource"]>
    composites: {}
  }

  type RessourceGetPayload<S extends boolean | null | undefined | RessourceDefaultArgs> = $Result.GetResult<Prisma.$RessourcePayload, S>

  type RessourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RessourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RessourceCountAggregateInputType | true
    }

  export interface RessourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ressource'], meta: { name: 'Ressource' } }
    /**
     * Find zero or one Ressource that matches the filter.
     * @param {RessourceFindUniqueArgs} args - Arguments to find a Ressource
     * @example
     * // Get one Ressource
     * const ressource = await prisma.ressource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RessourceFindUniqueArgs>(args: SelectSubset<T, RessourceFindUniqueArgs<ExtArgs>>): Prisma__RessourceClient<$Result.GetResult<Prisma.$RessourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ressource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RessourceFindUniqueOrThrowArgs} args - Arguments to find a Ressource
     * @example
     * // Get one Ressource
     * const ressource = await prisma.ressource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RessourceFindUniqueOrThrowArgs>(args: SelectSubset<T, RessourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RessourceClient<$Result.GetResult<Prisma.$RessourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ressource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RessourceFindFirstArgs} args - Arguments to find a Ressource
     * @example
     * // Get one Ressource
     * const ressource = await prisma.ressource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RessourceFindFirstArgs>(args?: SelectSubset<T, RessourceFindFirstArgs<ExtArgs>>): Prisma__RessourceClient<$Result.GetResult<Prisma.$RessourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ressource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RessourceFindFirstOrThrowArgs} args - Arguments to find a Ressource
     * @example
     * // Get one Ressource
     * const ressource = await prisma.ressource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RessourceFindFirstOrThrowArgs>(args?: SelectSubset<T, RessourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__RessourceClient<$Result.GetResult<Prisma.$RessourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ressources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RessourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ressources
     * const ressources = await prisma.ressource.findMany()
     * 
     * // Get first 10 Ressources
     * const ressources = await prisma.ressource.findMany({ take: 10 })
     * 
     * // Only select the `description`
     * const ressourceWithDescriptionOnly = await prisma.ressource.findMany({ select: { description: true } })
     * 
     */
    findMany<T extends RessourceFindManyArgs>(args?: SelectSubset<T, RessourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RessourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ressource.
     * @param {RessourceCreateArgs} args - Arguments to create a Ressource.
     * @example
     * // Create one Ressource
     * const Ressource = await prisma.ressource.create({
     *   data: {
     *     // ... data to create a Ressource
     *   }
     * })
     * 
     */
    create<T extends RessourceCreateArgs>(args: SelectSubset<T, RessourceCreateArgs<ExtArgs>>): Prisma__RessourceClient<$Result.GetResult<Prisma.$RessourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ressources.
     * @param {RessourceCreateManyArgs} args - Arguments to create many Ressources.
     * @example
     * // Create many Ressources
     * const ressource = await prisma.ressource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RessourceCreateManyArgs>(args?: SelectSubset<T, RessourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ressources and returns the data saved in the database.
     * @param {RessourceCreateManyAndReturnArgs} args - Arguments to create many Ressources.
     * @example
     * // Create many Ressources
     * const ressource = await prisma.ressource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ressources and only return the `description`
     * const ressourceWithDescriptionOnly = await prisma.ressource.createManyAndReturn({
     *   select: { description: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RessourceCreateManyAndReturnArgs>(args?: SelectSubset<T, RessourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RessourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ressource.
     * @param {RessourceDeleteArgs} args - Arguments to delete one Ressource.
     * @example
     * // Delete one Ressource
     * const Ressource = await prisma.ressource.delete({
     *   where: {
     *     // ... filter to delete one Ressource
     *   }
     * })
     * 
     */
    delete<T extends RessourceDeleteArgs>(args: SelectSubset<T, RessourceDeleteArgs<ExtArgs>>): Prisma__RessourceClient<$Result.GetResult<Prisma.$RessourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ressource.
     * @param {RessourceUpdateArgs} args - Arguments to update one Ressource.
     * @example
     * // Update one Ressource
     * const ressource = await prisma.ressource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RessourceUpdateArgs>(args: SelectSubset<T, RessourceUpdateArgs<ExtArgs>>): Prisma__RessourceClient<$Result.GetResult<Prisma.$RessourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ressources.
     * @param {RessourceDeleteManyArgs} args - Arguments to filter Ressources to delete.
     * @example
     * // Delete a few Ressources
     * const { count } = await prisma.ressource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RessourceDeleteManyArgs>(args?: SelectSubset<T, RessourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ressources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RessourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ressources
     * const ressource = await prisma.ressource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RessourceUpdateManyArgs>(args: SelectSubset<T, RessourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ressources and returns the data updated in the database.
     * @param {RessourceUpdateManyAndReturnArgs} args - Arguments to update many Ressources.
     * @example
     * // Update many Ressources
     * const ressource = await prisma.ressource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ressources and only return the `description`
     * const ressourceWithDescriptionOnly = await prisma.ressource.updateManyAndReturn({
     *   select: { description: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RessourceUpdateManyAndReturnArgs>(args: SelectSubset<T, RessourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RessourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ressource.
     * @param {RessourceUpsertArgs} args - Arguments to update or create a Ressource.
     * @example
     * // Update or create a Ressource
     * const ressource = await prisma.ressource.upsert({
     *   create: {
     *     // ... data to create a Ressource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ressource we want to update
     *   }
     * })
     */
    upsert<T extends RessourceUpsertArgs>(args: SelectSubset<T, RessourceUpsertArgs<ExtArgs>>): Prisma__RessourceClient<$Result.GetResult<Prisma.$RessourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ressources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RessourceCountArgs} args - Arguments to filter Ressources to count.
     * @example
     * // Count the number of Ressources
     * const count = await prisma.ressource.count({
     *   where: {
     *     // ... the filter for the Ressources we want to count
     *   }
     * })
    **/
    count<T extends RessourceCountArgs>(
      args?: Subset<T, RessourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RessourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ressource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RessourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RessourceAggregateArgs>(args: Subset<T, RessourceAggregateArgs>): Prisma.PrismaPromise<GetRessourceAggregateType<T>>

    /**
     * Group by Ressource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RessourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RessourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RessourceGroupByArgs['orderBy'] }
        : { orderBy?: RessourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RessourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRessourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ressource model
   */
  readonly fields: RessourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ressource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RessourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actionLinks<T extends Ressource$actionLinksArgs<ExtArgs> = {}>(args?: Subset<T, Ressource$actionLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ressource model
   */
  interface RessourceFieldRefs {
    readonly name: FieldRef<"Ressource", 'Ressources'>
    readonly description: FieldRef<"Ressource", 'String'>
    readonly deleted: FieldRef<"Ressource", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Ressource findUnique
   */
  export type RessourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ressource
     */
    select?: RessourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ressource
     */
    omit?: RessourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RessourceInclude<ExtArgs> | null
    /**
     * Filter, which Ressource to fetch.
     */
    where: RessourceWhereUniqueInput
  }

  /**
   * Ressource findUniqueOrThrow
   */
  export type RessourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ressource
     */
    select?: RessourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ressource
     */
    omit?: RessourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RessourceInclude<ExtArgs> | null
    /**
     * Filter, which Ressource to fetch.
     */
    where: RessourceWhereUniqueInput
  }

  /**
   * Ressource findFirst
   */
  export type RessourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ressource
     */
    select?: RessourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ressource
     */
    omit?: RessourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RessourceInclude<ExtArgs> | null
    /**
     * Filter, which Ressource to fetch.
     */
    where?: RessourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ressources to fetch.
     */
    orderBy?: RessourceOrderByWithRelationInput | RessourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ressources.
     */
    cursor?: RessourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ressources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ressources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ressources.
     */
    distinct?: RessourceScalarFieldEnum | RessourceScalarFieldEnum[]
  }

  /**
   * Ressource findFirstOrThrow
   */
  export type RessourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ressource
     */
    select?: RessourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ressource
     */
    omit?: RessourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RessourceInclude<ExtArgs> | null
    /**
     * Filter, which Ressource to fetch.
     */
    where?: RessourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ressources to fetch.
     */
    orderBy?: RessourceOrderByWithRelationInput | RessourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ressources.
     */
    cursor?: RessourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ressources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ressources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ressources.
     */
    distinct?: RessourceScalarFieldEnum | RessourceScalarFieldEnum[]
  }

  /**
   * Ressource findMany
   */
  export type RessourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ressource
     */
    select?: RessourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ressource
     */
    omit?: RessourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RessourceInclude<ExtArgs> | null
    /**
     * Filter, which Ressources to fetch.
     */
    where?: RessourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ressources to fetch.
     */
    orderBy?: RessourceOrderByWithRelationInput | RessourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ressources.
     */
    cursor?: RessourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ressources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ressources.
     */
    skip?: number
    distinct?: RessourceScalarFieldEnum | RessourceScalarFieldEnum[]
  }

  /**
   * Ressource create
   */
  export type RessourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ressource
     */
    select?: RessourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ressource
     */
    omit?: RessourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RessourceInclude<ExtArgs> | null
    /**
     * The data needed to create a Ressource.
     */
    data: XOR<RessourceCreateInput, RessourceUncheckedCreateInput>
  }

  /**
   * Ressource createMany
   */
  export type RessourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ressources.
     */
    data: RessourceCreateManyInput | RessourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ressource createManyAndReturn
   */
  export type RessourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ressource
     */
    select?: RessourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ressource
     */
    omit?: RessourceOmit<ExtArgs> | null
    /**
     * The data used to create many Ressources.
     */
    data: RessourceCreateManyInput | RessourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ressource update
   */
  export type RessourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ressource
     */
    select?: RessourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ressource
     */
    omit?: RessourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RessourceInclude<ExtArgs> | null
    /**
     * The data needed to update a Ressource.
     */
    data: XOR<RessourceUpdateInput, RessourceUncheckedUpdateInput>
    /**
     * Choose, which Ressource to update.
     */
    where: RessourceWhereUniqueInput
  }

  /**
   * Ressource updateMany
   */
  export type RessourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ressources.
     */
    data: XOR<RessourceUpdateManyMutationInput, RessourceUncheckedUpdateManyInput>
    /**
     * Filter which Ressources to update
     */
    where?: RessourceWhereInput
    /**
     * Limit how many Ressources to update.
     */
    limit?: number
  }

  /**
   * Ressource updateManyAndReturn
   */
  export type RessourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ressource
     */
    select?: RessourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ressource
     */
    omit?: RessourceOmit<ExtArgs> | null
    /**
     * The data used to update Ressources.
     */
    data: XOR<RessourceUpdateManyMutationInput, RessourceUncheckedUpdateManyInput>
    /**
     * Filter which Ressources to update
     */
    where?: RessourceWhereInput
    /**
     * Limit how many Ressources to update.
     */
    limit?: number
  }

  /**
   * Ressource upsert
   */
  export type RessourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ressource
     */
    select?: RessourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ressource
     */
    omit?: RessourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RessourceInclude<ExtArgs> | null
    /**
     * The filter to search for the Ressource to update in case it exists.
     */
    where: RessourceWhereUniqueInput
    /**
     * In case the Ressource found by the `where` argument doesn't exist, create a new Ressource with this data.
     */
    create: XOR<RessourceCreateInput, RessourceUncheckedCreateInput>
    /**
     * In case the Ressource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RessourceUpdateInput, RessourceUncheckedUpdateInput>
  }

  /**
   * Ressource delete
   */
  export type RessourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ressource
     */
    select?: RessourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ressource
     */
    omit?: RessourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RessourceInclude<ExtArgs> | null
    /**
     * Filter which Ressource to delete.
     */
    where: RessourceWhereUniqueInput
  }

  /**
   * Ressource deleteMany
   */
  export type RessourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ressources to delete
     */
    where?: RessourceWhereInput
    /**
     * Limit how many Ressources to delete.
     */
    limit?: number
  }

  /**
   * Ressource.actionLinks
   */
  export type Ressource$actionLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceAction
     */
    select?: ResourceActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceAction
     */
    omit?: ResourceActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceActionInclude<ExtArgs> | null
    where?: ResourceActionWhereInput
    orderBy?: ResourceActionOrderByWithRelationInput | ResourceActionOrderByWithRelationInput[]
    cursor?: ResourceActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceActionScalarFieldEnum | ResourceActionScalarFieldEnum[]
  }

  /**
   * Ressource without action
   */
  export type RessourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ressource
     */
    select?: RessourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ressource
     */
    omit?: RessourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RessourceInclude<ExtArgs> | null
  }


  /**
   * Model ResourceAction
   */

  export type AggregateResourceAction = {
    _count: ResourceActionCountAggregateOutputType | null
    _min: ResourceActionMinAggregateOutputType | null
    _max: ResourceActionMaxAggregateOutputType | null
  }

  export type ResourceActionMinAggregateOutputType = {
    action: $Enums.Actions | null
    resource: $Enums.Ressources | null
  }

  export type ResourceActionMaxAggregateOutputType = {
    action: $Enums.Actions | null
    resource: $Enums.Ressources | null
  }

  export type ResourceActionCountAggregateOutputType = {
    action: number
    resource: number
    _all: number
  }


  export type ResourceActionMinAggregateInputType = {
    action?: true
    resource?: true
  }

  export type ResourceActionMaxAggregateInputType = {
    action?: true
    resource?: true
  }

  export type ResourceActionCountAggregateInputType = {
    action?: true
    resource?: true
    _all?: true
  }

  export type ResourceActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResourceAction to aggregate.
     */
    where?: ResourceActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceActions to fetch.
     */
    orderBy?: ResourceActionOrderByWithRelationInput | ResourceActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResourceActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResourceActions
    **/
    _count?: true | ResourceActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceActionMaxAggregateInputType
  }

  export type GetResourceActionAggregateType<T extends ResourceActionAggregateArgs> = {
        [P in keyof T & keyof AggregateResourceAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResourceAction[P]>
      : GetScalarType<T[P], AggregateResourceAction[P]>
  }




  export type ResourceActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceActionWhereInput
    orderBy?: ResourceActionOrderByWithAggregationInput | ResourceActionOrderByWithAggregationInput[]
    by: ResourceActionScalarFieldEnum[] | ResourceActionScalarFieldEnum
    having?: ResourceActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceActionCountAggregateInputType | true
    _min?: ResourceActionMinAggregateInputType
    _max?: ResourceActionMaxAggregateInputType
  }

  export type ResourceActionGroupByOutputType = {
    action: $Enums.Actions
    resource: $Enums.Ressources
    _count: ResourceActionCountAggregateOutputType | null
    _min: ResourceActionMinAggregateOutputType | null
    _max: ResourceActionMaxAggregateOutputType | null
  }

  type GetResourceActionGroupByPayload<T extends ResourceActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceActionGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceActionGroupByOutputType[P]>
        }
      >
    >


  export type ResourceActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    action?: boolean
    resource?: boolean
    Action?: boolean | ActionDefaultArgs<ExtArgs>
    Ressource?: boolean | RessourceDefaultArgs<ExtArgs>
    permissions?: boolean | ResourceAction$permissionsArgs<ExtArgs>
    _count?: boolean | ResourceActionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resourceAction"]>

  export type ResourceActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    action?: boolean
    resource?: boolean
    Action?: boolean | ActionDefaultArgs<ExtArgs>
    Ressource?: boolean | RessourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resourceAction"]>

  export type ResourceActionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    action?: boolean
    resource?: boolean
    Action?: boolean | ActionDefaultArgs<ExtArgs>
    Ressource?: boolean | RessourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resourceAction"]>

  export type ResourceActionSelectScalar = {
    action?: boolean
    resource?: boolean
  }

  export type ResourceActionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"action" | "resource", ExtArgs["result"]["resourceAction"]>
  export type ResourceActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Action?: boolean | ActionDefaultArgs<ExtArgs>
    Ressource?: boolean | RessourceDefaultArgs<ExtArgs>
    permissions?: boolean | ResourceAction$permissionsArgs<ExtArgs>
    _count?: boolean | ResourceActionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ResourceActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Action?: boolean | ActionDefaultArgs<ExtArgs>
    Ressource?: boolean | RessourceDefaultArgs<ExtArgs>
  }
  export type ResourceActionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Action?: boolean | ActionDefaultArgs<ExtArgs>
    Ressource?: boolean | RessourceDefaultArgs<ExtArgs>
  }

  export type $ResourceActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResourceAction"
    objects: {
      Action: Prisma.$ActionPayload<ExtArgs>
      Ressource: Prisma.$RessourcePayload<ExtArgs>
      permissions: Prisma.$PermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      action: $Enums.Actions
      resource: $Enums.Ressources
    }, ExtArgs["result"]["resourceAction"]>
    composites: {}
  }

  type ResourceActionGetPayload<S extends boolean | null | undefined | ResourceActionDefaultArgs> = $Result.GetResult<Prisma.$ResourceActionPayload, S>

  type ResourceActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResourceActionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResourceActionCountAggregateInputType | true
    }

  export interface ResourceActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResourceAction'], meta: { name: 'ResourceAction' } }
    /**
     * Find zero or one ResourceAction that matches the filter.
     * @param {ResourceActionFindUniqueArgs} args - Arguments to find a ResourceAction
     * @example
     * // Get one ResourceAction
     * const resourceAction = await prisma.resourceAction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResourceActionFindUniqueArgs>(args: SelectSubset<T, ResourceActionFindUniqueArgs<ExtArgs>>): Prisma__ResourceActionClient<$Result.GetResult<Prisma.$ResourceActionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResourceAction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResourceActionFindUniqueOrThrowArgs} args - Arguments to find a ResourceAction
     * @example
     * // Get one ResourceAction
     * const resourceAction = await prisma.resourceAction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResourceActionFindUniqueOrThrowArgs>(args: SelectSubset<T, ResourceActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResourceActionClient<$Result.GetResult<Prisma.$ResourceActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResourceAction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceActionFindFirstArgs} args - Arguments to find a ResourceAction
     * @example
     * // Get one ResourceAction
     * const resourceAction = await prisma.resourceAction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResourceActionFindFirstArgs>(args?: SelectSubset<T, ResourceActionFindFirstArgs<ExtArgs>>): Prisma__ResourceActionClient<$Result.GetResult<Prisma.$ResourceActionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResourceAction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceActionFindFirstOrThrowArgs} args - Arguments to find a ResourceAction
     * @example
     * // Get one ResourceAction
     * const resourceAction = await prisma.resourceAction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResourceActionFindFirstOrThrowArgs>(args?: SelectSubset<T, ResourceActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResourceActionClient<$Result.GetResult<Prisma.$ResourceActionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResourceActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResourceActions
     * const resourceActions = await prisma.resourceAction.findMany()
     * 
     * // Get first 10 ResourceActions
     * const resourceActions = await prisma.resourceAction.findMany({ take: 10 })
     * 
     * 
     */
    findMany<T extends ResourceActionFindManyArgs>(args?: SelectSubset<T, ResourceActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResourceAction.
     * @param {ResourceActionCreateArgs} args - Arguments to create a ResourceAction.
     * @example
     * // Create one ResourceAction
     * const ResourceAction = await prisma.resourceAction.create({
     *   data: {
     *     // ... data to create a ResourceAction
     *   }
     * })
     * 
     */
    create<T extends ResourceActionCreateArgs>(args: SelectSubset<T, ResourceActionCreateArgs<ExtArgs>>): Prisma__ResourceActionClient<$Result.GetResult<Prisma.$ResourceActionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResourceActions.
     * @param {ResourceActionCreateManyArgs} args - Arguments to create many ResourceActions.
     * @example
     * // Create many ResourceActions
     * const resourceAction = await prisma.resourceAction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResourceActionCreateManyArgs>(args?: SelectSubset<T, ResourceActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResourceActions and returns the data saved in the database.
     * @param {ResourceActionCreateManyAndReturnArgs} args - Arguments to create many ResourceActions.
     * @example
     * // Create many ResourceActions
     * const resourceAction = await prisma.resourceAction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResourceActionCreateManyAndReturnArgs>(args?: SelectSubset<T, ResourceActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceActionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResourceAction.
     * @param {ResourceActionDeleteArgs} args - Arguments to delete one ResourceAction.
     * @example
     * // Delete one ResourceAction
     * const ResourceAction = await prisma.resourceAction.delete({
     *   where: {
     *     // ... filter to delete one ResourceAction
     *   }
     * })
     * 
     */
    delete<T extends ResourceActionDeleteArgs>(args: SelectSubset<T, ResourceActionDeleteArgs<ExtArgs>>): Prisma__ResourceActionClient<$Result.GetResult<Prisma.$ResourceActionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResourceAction.
     * @param {ResourceActionUpdateArgs} args - Arguments to update one ResourceAction.
     * @example
     * // Update one ResourceAction
     * const resourceAction = await prisma.resourceAction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResourceActionUpdateArgs>(args: SelectSubset<T, ResourceActionUpdateArgs<ExtArgs>>): Prisma__ResourceActionClient<$Result.GetResult<Prisma.$ResourceActionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResourceActions.
     * @param {ResourceActionDeleteManyArgs} args - Arguments to filter ResourceActions to delete.
     * @example
     * // Delete a few ResourceActions
     * const { count } = await prisma.resourceAction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResourceActionDeleteManyArgs>(args?: SelectSubset<T, ResourceActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResourceActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResourceActions
     * const resourceAction = await prisma.resourceAction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResourceActionUpdateManyArgs>(args: SelectSubset<T, ResourceActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResourceActions and returns the data updated in the database.
     * @param {ResourceActionUpdateManyAndReturnArgs} args - Arguments to update many ResourceActions.
     * @example
     * // Update many ResourceActions
     * const resourceAction = await prisma.resourceAction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResourceActionUpdateManyAndReturnArgs>(args: SelectSubset<T, ResourceActionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceActionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResourceAction.
     * @param {ResourceActionUpsertArgs} args - Arguments to update or create a ResourceAction.
     * @example
     * // Update or create a ResourceAction
     * const resourceAction = await prisma.resourceAction.upsert({
     *   create: {
     *     // ... data to create a ResourceAction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResourceAction we want to update
     *   }
     * })
     */
    upsert<T extends ResourceActionUpsertArgs>(args: SelectSubset<T, ResourceActionUpsertArgs<ExtArgs>>): Prisma__ResourceActionClient<$Result.GetResult<Prisma.$ResourceActionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResourceActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceActionCountArgs} args - Arguments to filter ResourceActions to count.
     * @example
     * // Count the number of ResourceActions
     * const count = await prisma.resourceAction.count({
     *   where: {
     *     // ... the filter for the ResourceActions we want to count
     *   }
     * })
    **/
    count<T extends ResourceActionCountArgs>(
      args?: Subset<T, ResourceActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResourceAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceActionAggregateArgs>(args: Subset<T, ResourceActionAggregateArgs>): Prisma.PrismaPromise<GetResourceActionAggregateType<T>>

    /**
     * Group by ResourceAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceActionGroupByArgs['orderBy'] }
        : { orderBy?: ResourceActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResourceAction model
   */
  readonly fields: ResourceActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResourceAction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResourceActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Action<T extends ActionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActionDefaultArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Ressource<T extends RessourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RessourceDefaultArgs<ExtArgs>>): Prisma__RessourceClient<$Result.GetResult<Prisma.$RessourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    permissions<T extends ResourceAction$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, ResourceAction$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResourceAction model
   */
  interface ResourceActionFieldRefs {
    readonly action: FieldRef<"ResourceAction", 'Actions'>
    readonly resource: FieldRef<"ResourceAction", 'Ressources'>
  }
    

  // Custom InputTypes
  /**
   * ResourceAction findUnique
   */
  export type ResourceActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceAction
     */
    select?: ResourceActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceAction
     */
    omit?: ResourceActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceActionInclude<ExtArgs> | null
    /**
     * Filter, which ResourceAction to fetch.
     */
    where: ResourceActionWhereUniqueInput
  }

  /**
   * ResourceAction findUniqueOrThrow
   */
  export type ResourceActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceAction
     */
    select?: ResourceActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceAction
     */
    omit?: ResourceActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceActionInclude<ExtArgs> | null
    /**
     * Filter, which ResourceAction to fetch.
     */
    where: ResourceActionWhereUniqueInput
  }

  /**
   * ResourceAction findFirst
   */
  export type ResourceActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceAction
     */
    select?: ResourceActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceAction
     */
    omit?: ResourceActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceActionInclude<ExtArgs> | null
    /**
     * Filter, which ResourceAction to fetch.
     */
    where?: ResourceActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceActions to fetch.
     */
    orderBy?: ResourceActionOrderByWithRelationInput | ResourceActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResourceActions.
     */
    cursor?: ResourceActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResourceActions.
     */
    distinct?: ResourceActionScalarFieldEnum | ResourceActionScalarFieldEnum[]
  }

  /**
   * ResourceAction findFirstOrThrow
   */
  export type ResourceActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceAction
     */
    select?: ResourceActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceAction
     */
    omit?: ResourceActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceActionInclude<ExtArgs> | null
    /**
     * Filter, which ResourceAction to fetch.
     */
    where?: ResourceActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceActions to fetch.
     */
    orderBy?: ResourceActionOrderByWithRelationInput | ResourceActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResourceActions.
     */
    cursor?: ResourceActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResourceActions.
     */
    distinct?: ResourceActionScalarFieldEnum | ResourceActionScalarFieldEnum[]
  }

  /**
   * ResourceAction findMany
   */
  export type ResourceActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceAction
     */
    select?: ResourceActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceAction
     */
    omit?: ResourceActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceActionInclude<ExtArgs> | null
    /**
     * Filter, which ResourceActions to fetch.
     */
    where?: ResourceActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceActions to fetch.
     */
    orderBy?: ResourceActionOrderByWithRelationInput | ResourceActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResourceActions.
     */
    cursor?: ResourceActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceActions.
     */
    skip?: number
    distinct?: ResourceActionScalarFieldEnum | ResourceActionScalarFieldEnum[]
  }

  /**
   * ResourceAction create
   */
  export type ResourceActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceAction
     */
    select?: ResourceActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceAction
     */
    omit?: ResourceActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceActionInclude<ExtArgs> | null
    /**
     * The data needed to create a ResourceAction.
     */
    data: XOR<ResourceActionCreateInput, ResourceActionUncheckedCreateInput>
  }

  /**
   * ResourceAction createMany
   */
  export type ResourceActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResourceActions.
     */
    data: ResourceActionCreateManyInput | ResourceActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResourceAction createManyAndReturn
   */
  export type ResourceActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceAction
     */
    select?: ResourceActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceAction
     */
    omit?: ResourceActionOmit<ExtArgs> | null
    /**
     * The data used to create many ResourceActions.
     */
    data: ResourceActionCreateManyInput | ResourceActionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceActionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResourceAction update
   */
  export type ResourceActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceAction
     */
    select?: ResourceActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceAction
     */
    omit?: ResourceActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceActionInclude<ExtArgs> | null
    /**
     * The data needed to update a ResourceAction.
     */
    data: XOR<ResourceActionUpdateInput, ResourceActionUncheckedUpdateInput>
    /**
     * Choose, which ResourceAction to update.
     */
    where: ResourceActionWhereUniqueInput
  }

  /**
   * ResourceAction updateMany
   */
  export type ResourceActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResourceActions.
     */
    data: XOR<ResourceActionUpdateManyMutationInput, ResourceActionUncheckedUpdateManyInput>
    /**
     * Filter which ResourceActions to update
     */
    where?: ResourceActionWhereInput
    /**
     * Limit how many ResourceActions to update.
     */
    limit?: number
  }

  /**
   * ResourceAction updateManyAndReturn
   */
  export type ResourceActionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceAction
     */
    select?: ResourceActionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceAction
     */
    omit?: ResourceActionOmit<ExtArgs> | null
    /**
     * The data used to update ResourceActions.
     */
    data: XOR<ResourceActionUpdateManyMutationInput, ResourceActionUncheckedUpdateManyInput>
    /**
     * Filter which ResourceActions to update
     */
    where?: ResourceActionWhereInput
    /**
     * Limit how many ResourceActions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceActionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResourceAction upsert
   */
  export type ResourceActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceAction
     */
    select?: ResourceActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceAction
     */
    omit?: ResourceActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceActionInclude<ExtArgs> | null
    /**
     * The filter to search for the ResourceAction to update in case it exists.
     */
    where: ResourceActionWhereUniqueInput
    /**
     * In case the ResourceAction found by the `where` argument doesn't exist, create a new ResourceAction with this data.
     */
    create: XOR<ResourceActionCreateInput, ResourceActionUncheckedCreateInput>
    /**
     * In case the ResourceAction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResourceActionUpdateInput, ResourceActionUncheckedUpdateInput>
  }

  /**
   * ResourceAction delete
   */
  export type ResourceActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceAction
     */
    select?: ResourceActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceAction
     */
    omit?: ResourceActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceActionInclude<ExtArgs> | null
    /**
     * Filter which ResourceAction to delete.
     */
    where: ResourceActionWhereUniqueInput
  }

  /**
   * ResourceAction deleteMany
   */
  export type ResourceActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResourceActions to delete
     */
    where?: ResourceActionWhereInput
    /**
     * Limit how many ResourceActions to delete.
     */
    limit?: number
  }

  /**
   * ResourceAction.permissions
   */
  export type ResourceAction$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    cursor?: PermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * ResourceAction without action
   */
  export type ResourceActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceAction
     */
    select?: ResourceActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceAction
     */
    omit?: ResourceActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceActionInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    name: string | null
    description: string | null
    deleted: boolean | null
  }

  export type RoleMaxAggregateOutputType = {
    name: string | null
    description: string | null
    deleted: boolean | null
  }

  export type RoleCountAggregateOutputType = {
    name: number
    description: number
    deleted: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    name?: true
    description?: true
    deleted?: true
  }

  export type RoleMaxAggregateInputType = {
    name?: true
    description?: true
    deleted?: true
  }

  export type RoleCountAggregateInputType = {
    name?: true
    description?: true
    deleted?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    name: string
    description: string | null
    deleted: boolean
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    deleted?: boolean
    employees?: boolean | Role$employeesArgs<ExtArgs>
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    name?: boolean
    description?: boolean
    deleted?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"name" | "description" | "deleted", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | Role$employeesArgs<ExtArgs>
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      employees: Prisma.$EmployeesPayload<ExtArgs>[]
      permissions: Prisma.$PermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string
      description: string | null
      deleted: boolean
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const roleWithNameOnly = await prisma.role.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `name`
     * const roleWithNameOnly = await prisma.role.createManyAndReturn({
     *   select: { name: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `name`
     * const roleWithNameOnly = await prisma.role.updateManyAndReturn({
     *   select: { name: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends Role$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Role$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    permissions<T extends Role$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Role$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly deleted: FieldRef<"Role", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data?: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.employees
   */
  export type Role$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employees
     */
    select?: EmployeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employees
     */
    omit?: EmployeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeesInclude<ExtArgs> | null
    where?: EmployeesWhereInput
    orderBy?: EmployeesOrderByWithRelationInput | EmployeesOrderByWithRelationInput[]
    cursor?: EmployeesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeesScalarFieldEnum | EmployeesScalarFieldEnum[]
  }

  /**
   * Role.permissions
   */
  export type Role$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    cursor?: PermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    role: string | null
    action: $Enums.Actions | null
    resource: $Enums.Ressources | null
    allowed: boolean | null
    createdAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    role: string | null
    action: $Enums.Actions | null
    resource: $Enums.Ressources | null
    allowed: boolean | null
    createdAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    role: number
    action: number
    resource: number
    allowed: number
    createdAt: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    role?: true
    action?: true
    resource?: true
    allowed?: true
    createdAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    role?: true
    action?: true
    resource?: true
    allowed?: true
    createdAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    role?: true
    action?: true
    resource?: true
    allowed?: true
    createdAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    role: string
    action: $Enums.Actions
    resource: $Enums.Ressources
    allowed: boolean
    createdAt: Date
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    action?: boolean
    resource?: boolean
    allowed?: boolean
    createdAt?: boolean
    Role?: boolean | RoleDefaultArgs<ExtArgs>
    resourceAction?: boolean | ResourceActionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    action?: boolean
    resource?: boolean
    allowed?: boolean
    createdAt?: boolean
    Role?: boolean | RoleDefaultArgs<ExtArgs>
    resourceAction?: boolean | ResourceActionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    action?: boolean
    resource?: boolean
    allowed?: boolean
    createdAt?: boolean
    Role?: boolean | RoleDefaultArgs<ExtArgs>
    resourceAction?: boolean | ResourceActionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    role?: boolean
    action?: boolean
    resource?: boolean
    allowed?: boolean
    createdAt?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "role" | "action" | "resource" | "allowed" | "createdAt", ExtArgs["result"]["permission"]>
  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Role?: boolean | RoleDefaultArgs<ExtArgs>
    resourceAction?: boolean | ResourceActionDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Role?: boolean | RoleDefaultArgs<ExtArgs>
    resourceAction?: boolean | ResourceActionDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Role?: boolean | RoleDefaultArgs<ExtArgs>
    resourceAction?: boolean | ResourceActionDefaultArgs<ExtArgs>
  }

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      Role: Prisma.$RolePayload<ExtArgs>
      resourceAction: Prisma.$ResourceActionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      role: string
      action: $Enums.Actions
      resource: $Enums.Ressources
      allowed: boolean
      createdAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {PermissionUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, PermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    resourceAction<T extends ResourceActionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResourceActionDefaultArgs<ExtArgs>>): Prisma__ResourceActionClient<$Result.GetResult<Prisma.$ResourceActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly role: FieldRef<"Permission", 'String'>
    readonly action: FieldRef<"Permission", 'Actions'>
    readonly resource: FieldRef<"Permission", 'Ressources'>
    readonly allowed: FieldRef<"Permission", 'Boolean'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission updateManyAndReturn
   */
  export type PermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model CartOnProducts
   */

  export type AggregateCartOnProducts = {
    _count: CartOnProductsCountAggregateOutputType | null
    _avg: CartOnProductsAvgAggregateOutputType | null
    _sum: CartOnProductsSumAggregateOutputType | null
    _min: CartOnProductsMinAggregateOutputType | null
    _max: CartOnProductsMaxAggregateOutputType | null
  }

  export type CartOnProductsAvgAggregateOutputType = {
    quantity: number | null
  }

  export type CartOnProductsSumAggregateOutputType = {
    quantity: number | null
  }

  export type CartOnProductsMinAggregateOutputType = {
    cartId: string | null
    productId: string | null
    quantity: number | null
  }

  export type CartOnProductsMaxAggregateOutputType = {
    cartId: string | null
    productId: string | null
    quantity: number | null
  }

  export type CartOnProductsCountAggregateOutputType = {
    cartId: number
    productId: number
    quantity: number
    _all: number
  }


  export type CartOnProductsAvgAggregateInputType = {
    quantity?: true
  }

  export type CartOnProductsSumAggregateInputType = {
    quantity?: true
  }

  export type CartOnProductsMinAggregateInputType = {
    cartId?: true
    productId?: true
    quantity?: true
  }

  export type CartOnProductsMaxAggregateInputType = {
    cartId?: true
    productId?: true
    quantity?: true
  }

  export type CartOnProductsCountAggregateInputType = {
    cartId?: true
    productId?: true
    quantity?: true
    _all?: true
  }

  export type CartOnProductsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartOnProducts to aggregate.
     */
    where?: CartOnProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartOnProducts to fetch.
     */
    orderBy?: CartOnProductsOrderByWithRelationInput | CartOnProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartOnProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartOnProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartOnProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CartOnProducts
    **/
    _count?: true | CartOnProductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartOnProductsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartOnProductsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartOnProductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartOnProductsMaxAggregateInputType
  }

  export type GetCartOnProductsAggregateType<T extends CartOnProductsAggregateArgs> = {
        [P in keyof T & keyof AggregateCartOnProducts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCartOnProducts[P]>
      : GetScalarType<T[P], AggregateCartOnProducts[P]>
  }




  export type CartOnProductsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartOnProductsWhereInput
    orderBy?: CartOnProductsOrderByWithAggregationInput | CartOnProductsOrderByWithAggregationInput[]
    by: CartOnProductsScalarFieldEnum[] | CartOnProductsScalarFieldEnum
    having?: CartOnProductsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartOnProductsCountAggregateInputType | true
    _avg?: CartOnProductsAvgAggregateInputType
    _sum?: CartOnProductsSumAggregateInputType
    _min?: CartOnProductsMinAggregateInputType
    _max?: CartOnProductsMaxAggregateInputType
  }

  export type CartOnProductsGroupByOutputType = {
    cartId: string
    productId: string
    quantity: number
    _count: CartOnProductsCountAggregateOutputType | null
    _avg: CartOnProductsAvgAggregateOutputType | null
    _sum: CartOnProductsSumAggregateOutputType | null
    _min: CartOnProductsMinAggregateOutputType | null
    _max: CartOnProductsMaxAggregateOutputType | null
  }

  type GetCartOnProductsGroupByPayload<T extends CartOnProductsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartOnProductsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartOnProductsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartOnProductsGroupByOutputType[P]>
            : GetScalarType<T[P], CartOnProductsGroupByOutputType[P]>
        }
      >
    >


  export type CartOnProductsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cartId?: boolean
    productId?: boolean
    quantity?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartOnProducts"]>

  export type CartOnProductsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cartId?: boolean
    productId?: boolean
    quantity?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartOnProducts"]>

  export type CartOnProductsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cartId?: boolean
    productId?: boolean
    quantity?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartOnProducts"]>

  export type CartOnProductsSelectScalar = {
    cartId?: boolean
    productId?: boolean
    quantity?: boolean
  }

  export type CartOnProductsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cartId" | "productId" | "quantity", ExtArgs["result"]["cartOnProducts"]>
  export type CartOnProductsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type CartOnProductsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type CartOnProductsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $CartOnProductsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CartOnProducts"
    objects: {
      cart: Prisma.$CartPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cartId: string
      productId: string
      quantity: number
    }, ExtArgs["result"]["cartOnProducts"]>
    composites: {}
  }

  type CartOnProductsGetPayload<S extends boolean | null | undefined | CartOnProductsDefaultArgs> = $Result.GetResult<Prisma.$CartOnProductsPayload, S>

  type CartOnProductsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartOnProductsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartOnProductsCountAggregateInputType | true
    }

  export interface CartOnProductsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CartOnProducts'], meta: { name: 'CartOnProducts' } }
    /**
     * Find zero or one CartOnProducts that matches the filter.
     * @param {CartOnProductsFindUniqueArgs} args - Arguments to find a CartOnProducts
     * @example
     * // Get one CartOnProducts
     * const cartOnProducts = await prisma.cartOnProducts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartOnProductsFindUniqueArgs>(args: SelectSubset<T, CartOnProductsFindUniqueArgs<ExtArgs>>): Prisma__CartOnProductsClient<$Result.GetResult<Prisma.$CartOnProductsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CartOnProducts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartOnProductsFindUniqueOrThrowArgs} args - Arguments to find a CartOnProducts
     * @example
     * // Get one CartOnProducts
     * const cartOnProducts = await prisma.cartOnProducts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartOnProductsFindUniqueOrThrowArgs>(args: SelectSubset<T, CartOnProductsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartOnProductsClient<$Result.GetResult<Prisma.$CartOnProductsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartOnProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartOnProductsFindFirstArgs} args - Arguments to find a CartOnProducts
     * @example
     * // Get one CartOnProducts
     * const cartOnProducts = await prisma.cartOnProducts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartOnProductsFindFirstArgs>(args?: SelectSubset<T, CartOnProductsFindFirstArgs<ExtArgs>>): Prisma__CartOnProductsClient<$Result.GetResult<Prisma.$CartOnProductsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartOnProducts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartOnProductsFindFirstOrThrowArgs} args - Arguments to find a CartOnProducts
     * @example
     * // Get one CartOnProducts
     * const cartOnProducts = await prisma.cartOnProducts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartOnProductsFindFirstOrThrowArgs>(args?: SelectSubset<T, CartOnProductsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartOnProductsClient<$Result.GetResult<Prisma.$CartOnProductsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CartOnProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartOnProductsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CartOnProducts
     * const cartOnProducts = await prisma.cartOnProducts.findMany()
     * 
     * // Get first 10 CartOnProducts
     * const cartOnProducts = await prisma.cartOnProducts.findMany({ take: 10 })
     * 
     * // Only select the `cartId`
     * const cartOnProductsWithCartIdOnly = await prisma.cartOnProducts.findMany({ select: { cartId: true } })
     * 
     */
    findMany<T extends CartOnProductsFindManyArgs>(args?: SelectSubset<T, CartOnProductsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartOnProductsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CartOnProducts.
     * @param {CartOnProductsCreateArgs} args - Arguments to create a CartOnProducts.
     * @example
     * // Create one CartOnProducts
     * const CartOnProducts = await prisma.cartOnProducts.create({
     *   data: {
     *     // ... data to create a CartOnProducts
     *   }
     * })
     * 
     */
    create<T extends CartOnProductsCreateArgs>(args: SelectSubset<T, CartOnProductsCreateArgs<ExtArgs>>): Prisma__CartOnProductsClient<$Result.GetResult<Prisma.$CartOnProductsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CartOnProducts.
     * @param {CartOnProductsCreateManyArgs} args - Arguments to create many CartOnProducts.
     * @example
     * // Create many CartOnProducts
     * const cartOnProducts = await prisma.cartOnProducts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartOnProductsCreateManyArgs>(args?: SelectSubset<T, CartOnProductsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CartOnProducts and returns the data saved in the database.
     * @param {CartOnProductsCreateManyAndReturnArgs} args - Arguments to create many CartOnProducts.
     * @example
     * // Create many CartOnProducts
     * const cartOnProducts = await prisma.cartOnProducts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CartOnProducts and only return the `cartId`
     * const cartOnProductsWithCartIdOnly = await prisma.cartOnProducts.createManyAndReturn({
     *   select: { cartId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CartOnProductsCreateManyAndReturnArgs>(args?: SelectSubset<T, CartOnProductsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartOnProductsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CartOnProducts.
     * @param {CartOnProductsDeleteArgs} args - Arguments to delete one CartOnProducts.
     * @example
     * // Delete one CartOnProducts
     * const CartOnProducts = await prisma.cartOnProducts.delete({
     *   where: {
     *     // ... filter to delete one CartOnProducts
     *   }
     * })
     * 
     */
    delete<T extends CartOnProductsDeleteArgs>(args: SelectSubset<T, CartOnProductsDeleteArgs<ExtArgs>>): Prisma__CartOnProductsClient<$Result.GetResult<Prisma.$CartOnProductsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CartOnProducts.
     * @param {CartOnProductsUpdateArgs} args - Arguments to update one CartOnProducts.
     * @example
     * // Update one CartOnProducts
     * const cartOnProducts = await prisma.cartOnProducts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartOnProductsUpdateArgs>(args: SelectSubset<T, CartOnProductsUpdateArgs<ExtArgs>>): Prisma__CartOnProductsClient<$Result.GetResult<Prisma.$CartOnProductsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CartOnProducts.
     * @param {CartOnProductsDeleteManyArgs} args - Arguments to filter CartOnProducts to delete.
     * @example
     * // Delete a few CartOnProducts
     * const { count } = await prisma.cartOnProducts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartOnProductsDeleteManyArgs>(args?: SelectSubset<T, CartOnProductsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CartOnProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartOnProductsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CartOnProducts
     * const cartOnProducts = await prisma.cartOnProducts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartOnProductsUpdateManyArgs>(args: SelectSubset<T, CartOnProductsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CartOnProducts and returns the data updated in the database.
     * @param {CartOnProductsUpdateManyAndReturnArgs} args - Arguments to update many CartOnProducts.
     * @example
     * // Update many CartOnProducts
     * const cartOnProducts = await prisma.cartOnProducts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CartOnProducts and only return the `cartId`
     * const cartOnProductsWithCartIdOnly = await prisma.cartOnProducts.updateManyAndReturn({
     *   select: { cartId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CartOnProductsUpdateManyAndReturnArgs>(args: SelectSubset<T, CartOnProductsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartOnProductsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CartOnProducts.
     * @param {CartOnProductsUpsertArgs} args - Arguments to update or create a CartOnProducts.
     * @example
     * // Update or create a CartOnProducts
     * const cartOnProducts = await prisma.cartOnProducts.upsert({
     *   create: {
     *     // ... data to create a CartOnProducts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CartOnProducts we want to update
     *   }
     * })
     */
    upsert<T extends CartOnProductsUpsertArgs>(args: SelectSubset<T, CartOnProductsUpsertArgs<ExtArgs>>): Prisma__CartOnProductsClient<$Result.GetResult<Prisma.$CartOnProductsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CartOnProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartOnProductsCountArgs} args - Arguments to filter CartOnProducts to count.
     * @example
     * // Count the number of CartOnProducts
     * const count = await prisma.cartOnProducts.count({
     *   where: {
     *     // ... the filter for the CartOnProducts we want to count
     *   }
     * })
    **/
    count<T extends CartOnProductsCountArgs>(
      args?: Subset<T, CartOnProductsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartOnProductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CartOnProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartOnProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartOnProductsAggregateArgs>(args: Subset<T, CartOnProductsAggregateArgs>): Prisma.PrismaPromise<GetCartOnProductsAggregateType<T>>

    /**
     * Group by CartOnProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartOnProductsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartOnProductsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartOnProductsGroupByArgs['orderBy'] }
        : { orderBy?: CartOnProductsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartOnProductsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartOnProductsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CartOnProducts model
   */
  readonly fields: CartOnProductsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CartOnProducts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartOnProductsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cart<T extends CartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CartDefaultArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CartOnProducts model
   */
  interface CartOnProductsFieldRefs {
    readonly cartId: FieldRef<"CartOnProducts", 'String'>
    readonly productId: FieldRef<"CartOnProducts", 'String'>
    readonly quantity: FieldRef<"CartOnProducts", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CartOnProducts findUnique
   */
  export type CartOnProductsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartOnProducts
     */
    select?: CartOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartOnProducts
     */
    omit?: CartOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartOnProductsInclude<ExtArgs> | null
    /**
     * Filter, which CartOnProducts to fetch.
     */
    where: CartOnProductsWhereUniqueInput
  }

  /**
   * CartOnProducts findUniqueOrThrow
   */
  export type CartOnProductsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartOnProducts
     */
    select?: CartOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartOnProducts
     */
    omit?: CartOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartOnProductsInclude<ExtArgs> | null
    /**
     * Filter, which CartOnProducts to fetch.
     */
    where: CartOnProductsWhereUniqueInput
  }

  /**
   * CartOnProducts findFirst
   */
  export type CartOnProductsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartOnProducts
     */
    select?: CartOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartOnProducts
     */
    omit?: CartOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartOnProductsInclude<ExtArgs> | null
    /**
     * Filter, which CartOnProducts to fetch.
     */
    where?: CartOnProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartOnProducts to fetch.
     */
    orderBy?: CartOnProductsOrderByWithRelationInput | CartOnProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartOnProducts.
     */
    cursor?: CartOnProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartOnProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartOnProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartOnProducts.
     */
    distinct?: CartOnProductsScalarFieldEnum | CartOnProductsScalarFieldEnum[]
  }

  /**
   * CartOnProducts findFirstOrThrow
   */
  export type CartOnProductsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartOnProducts
     */
    select?: CartOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartOnProducts
     */
    omit?: CartOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartOnProductsInclude<ExtArgs> | null
    /**
     * Filter, which CartOnProducts to fetch.
     */
    where?: CartOnProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartOnProducts to fetch.
     */
    orderBy?: CartOnProductsOrderByWithRelationInput | CartOnProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartOnProducts.
     */
    cursor?: CartOnProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartOnProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartOnProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartOnProducts.
     */
    distinct?: CartOnProductsScalarFieldEnum | CartOnProductsScalarFieldEnum[]
  }

  /**
   * CartOnProducts findMany
   */
  export type CartOnProductsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartOnProducts
     */
    select?: CartOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartOnProducts
     */
    omit?: CartOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartOnProductsInclude<ExtArgs> | null
    /**
     * Filter, which CartOnProducts to fetch.
     */
    where?: CartOnProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartOnProducts to fetch.
     */
    orderBy?: CartOnProductsOrderByWithRelationInput | CartOnProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CartOnProducts.
     */
    cursor?: CartOnProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartOnProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartOnProducts.
     */
    skip?: number
    distinct?: CartOnProductsScalarFieldEnum | CartOnProductsScalarFieldEnum[]
  }

  /**
   * CartOnProducts create
   */
  export type CartOnProductsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartOnProducts
     */
    select?: CartOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartOnProducts
     */
    omit?: CartOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartOnProductsInclude<ExtArgs> | null
    /**
     * The data needed to create a CartOnProducts.
     */
    data: XOR<CartOnProductsCreateInput, CartOnProductsUncheckedCreateInput>
  }

  /**
   * CartOnProducts createMany
   */
  export type CartOnProductsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CartOnProducts.
     */
    data: CartOnProductsCreateManyInput | CartOnProductsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CartOnProducts createManyAndReturn
   */
  export type CartOnProductsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartOnProducts
     */
    select?: CartOnProductsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CartOnProducts
     */
    omit?: CartOnProductsOmit<ExtArgs> | null
    /**
     * The data used to create many CartOnProducts.
     */
    data: CartOnProductsCreateManyInput | CartOnProductsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartOnProductsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CartOnProducts update
   */
  export type CartOnProductsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartOnProducts
     */
    select?: CartOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartOnProducts
     */
    omit?: CartOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartOnProductsInclude<ExtArgs> | null
    /**
     * The data needed to update a CartOnProducts.
     */
    data: XOR<CartOnProductsUpdateInput, CartOnProductsUncheckedUpdateInput>
    /**
     * Choose, which CartOnProducts to update.
     */
    where: CartOnProductsWhereUniqueInput
  }

  /**
   * CartOnProducts updateMany
   */
  export type CartOnProductsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CartOnProducts.
     */
    data: XOR<CartOnProductsUpdateManyMutationInput, CartOnProductsUncheckedUpdateManyInput>
    /**
     * Filter which CartOnProducts to update
     */
    where?: CartOnProductsWhereInput
    /**
     * Limit how many CartOnProducts to update.
     */
    limit?: number
  }

  /**
   * CartOnProducts updateManyAndReturn
   */
  export type CartOnProductsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartOnProducts
     */
    select?: CartOnProductsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CartOnProducts
     */
    omit?: CartOnProductsOmit<ExtArgs> | null
    /**
     * The data used to update CartOnProducts.
     */
    data: XOR<CartOnProductsUpdateManyMutationInput, CartOnProductsUncheckedUpdateManyInput>
    /**
     * Filter which CartOnProducts to update
     */
    where?: CartOnProductsWhereInput
    /**
     * Limit how many CartOnProducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartOnProductsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CartOnProducts upsert
   */
  export type CartOnProductsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartOnProducts
     */
    select?: CartOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartOnProducts
     */
    omit?: CartOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartOnProductsInclude<ExtArgs> | null
    /**
     * The filter to search for the CartOnProducts to update in case it exists.
     */
    where: CartOnProductsWhereUniqueInput
    /**
     * In case the CartOnProducts found by the `where` argument doesn't exist, create a new CartOnProducts with this data.
     */
    create: XOR<CartOnProductsCreateInput, CartOnProductsUncheckedCreateInput>
    /**
     * In case the CartOnProducts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartOnProductsUpdateInput, CartOnProductsUncheckedUpdateInput>
  }

  /**
   * CartOnProducts delete
   */
  export type CartOnProductsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartOnProducts
     */
    select?: CartOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartOnProducts
     */
    omit?: CartOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartOnProductsInclude<ExtArgs> | null
    /**
     * Filter which CartOnProducts to delete.
     */
    where: CartOnProductsWhereUniqueInput
  }

  /**
   * CartOnProducts deleteMany
   */
  export type CartOnProductsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartOnProducts to delete
     */
    where?: CartOnProductsWhereInput
    /**
     * Limit how many CartOnProducts to delete.
     */
    limit?: number
  }

  /**
   * CartOnProducts without action
   */
  export type CartOnProductsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartOnProducts
     */
    select?: CartOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartOnProducts
     */
    omit?: CartOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartOnProductsInclude<ExtArgs> | null
  }


  /**
   * Model OrderOnProducts
   */

  export type AggregateOrderOnProducts = {
    _count: OrderOnProductsCountAggregateOutputType | null
    _avg: OrderOnProductsAvgAggregateOutputType | null
    _sum: OrderOnProductsSumAggregateOutputType | null
    _min: OrderOnProductsMinAggregateOutputType | null
    _max: OrderOnProductsMaxAggregateOutputType | null
  }

  export type OrderOnProductsAvgAggregateOutputType = {
    productAmount: number | null
  }

  export type OrderOnProductsSumAggregateOutputType = {
    productAmount: number | null
  }

  export type OrderOnProductsMinAggregateOutputType = {
    orderId: string | null
    productId: string | null
    orderDate: Date | null
    productAmount: number | null
  }

  export type OrderOnProductsMaxAggregateOutputType = {
    orderId: string | null
    productId: string | null
    orderDate: Date | null
    productAmount: number | null
  }

  export type OrderOnProductsCountAggregateOutputType = {
    orderId: number
    productId: number
    orderDate: number
    productAmount: number
    _all: number
  }


  export type OrderOnProductsAvgAggregateInputType = {
    productAmount?: true
  }

  export type OrderOnProductsSumAggregateInputType = {
    productAmount?: true
  }

  export type OrderOnProductsMinAggregateInputType = {
    orderId?: true
    productId?: true
    orderDate?: true
    productAmount?: true
  }

  export type OrderOnProductsMaxAggregateInputType = {
    orderId?: true
    productId?: true
    orderDate?: true
    productAmount?: true
  }

  export type OrderOnProductsCountAggregateInputType = {
    orderId?: true
    productId?: true
    orderDate?: true
    productAmount?: true
    _all?: true
  }

  export type OrderOnProductsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderOnProducts to aggregate.
     */
    where?: OrderOnProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderOnProducts to fetch.
     */
    orderBy?: OrderOnProductsOrderByWithRelationInput | OrderOnProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderOnProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderOnProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderOnProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderOnProducts
    **/
    _count?: true | OrderOnProductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderOnProductsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderOnProductsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderOnProductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderOnProductsMaxAggregateInputType
  }

  export type GetOrderOnProductsAggregateType<T extends OrderOnProductsAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderOnProducts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderOnProducts[P]>
      : GetScalarType<T[P], AggregateOrderOnProducts[P]>
  }




  export type OrderOnProductsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderOnProductsWhereInput
    orderBy?: OrderOnProductsOrderByWithAggregationInput | OrderOnProductsOrderByWithAggregationInput[]
    by: OrderOnProductsScalarFieldEnum[] | OrderOnProductsScalarFieldEnum
    having?: OrderOnProductsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderOnProductsCountAggregateInputType | true
    _avg?: OrderOnProductsAvgAggregateInputType
    _sum?: OrderOnProductsSumAggregateInputType
    _min?: OrderOnProductsMinAggregateInputType
    _max?: OrderOnProductsMaxAggregateInputType
  }

  export type OrderOnProductsGroupByOutputType = {
    orderId: string
    productId: string
    orderDate: Date
    productAmount: number
    _count: OrderOnProductsCountAggregateOutputType | null
    _avg: OrderOnProductsAvgAggregateOutputType | null
    _sum: OrderOnProductsSumAggregateOutputType | null
    _min: OrderOnProductsMinAggregateOutputType | null
    _max: OrderOnProductsMaxAggregateOutputType | null
  }

  type GetOrderOnProductsGroupByPayload<T extends OrderOnProductsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderOnProductsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderOnProductsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderOnProductsGroupByOutputType[P]>
            : GetScalarType<T[P], OrderOnProductsGroupByOutputType[P]>
        }
      >
    >


  export type OrderOnProductsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    orderId?: boolean
    productId?: boolean
    orderDate?: boolean
    productAmount?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderOnProducts"]>

  export type OrderOnProductsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    orderId?: boolean
    productId?: boolean
    orderDate?: boolean
    productAmount?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderOnProducts"]>

  export type OrderOnProductsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    orderId?: boolean
    productId?: boolean
    orderDate?: boolean
    productAmount?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderOnProducts"]>

  export type OrderOnProductsSelectScalar = {
    orderId?: boolean
    productId?: boolean
    orderDate?: boolean
    productAmount?: boolean
  }

  export type OrderOnProductsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"orderId" | "productId" | "orderDate" | "productAmount", ExtArgs["result"]["orderOnProducts"]>
  export type OrderOnProductsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type OrderOnProductsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type OrderOnProductsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $OrderOnProductsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderOnProducts"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      orderId: string
      productId: string
      orderDate: Date
      productAmount: number
    }, ExtArgs["result"]["orderOnProducts"]>
    composites: {}
  }

  type OrderOnProductsGetPayload<S extends boolean | null | undefined | OrderOnProductsDefaultArgs> = $Result.GetResult<Prisma.$OrderOnProductsPayload, S>

  type OrderOnProductsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderOnProductsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderOnProductsCountAggregateInputType | true
    }

  export interface OrderOnProductsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderOnProducts'], meta: { name: 'OrderOnProducts' } }
    /**
     * Find zero or one OrderOnProducts that matches the filter.
     * @param {OrderOnProductsFindUniqueArgs} args - Arguments to find a OrderOnProducts
     * @example
     * // Get one OrderOnProducts
     * const orderOnProducts = await prisma.orderOnProducts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderOnProductsFindUniqueArgs>(args: SelectSubset<T, OrderOnProductsFindUniqueArgs<ExtArgs>>): Prisma__OrderOnProductsClient<$Result.GetResult<Prisma.$OrderOnProductsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderOnProducts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderOnProductsFindUniqueOrThrowArgs} args - Arguments to find a OrderOnProducts
     * @example
     * // Get one OrderOnProducts
     * const orderOnProducts = await prisma.orderOnProducts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderOnProductsFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderOnProductsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderOnProductsClient<$Result.GetResult<Prisma.$OrderOnProductsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderOnProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderOnProductsFindFirstArgs} args - Arguments to find a OrderOnProducts
     * @example
     * // Get one OrderOnProducts
     * const orderOnProducts = await prisma.orderOnProducts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderOnProductsFindFirstArgs>(args?: SelectSubset<T, OrderOnProductsFindFirstArgs<ExtArgs>>): Prisma__OrderOnProductsClient<$Result.GetResult<Prisma.$OrderOnProductsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderOnProducts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderOnProductsFindFirstOrThrowArgs} args - Arguments to find a OrderOnProducts
     * @example
     * // Get one OrderOnProducts
     * const orderOnProducts = await prisma.orderOnProducts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderOnProductsFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderOnProductsFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderOnProductsClient<$Result.GetResult<Prisma.$OrderOnProductsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderOnProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderOnProductsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderOnProducts
     * const orderOnProducts = await prisma.orderOnProducts.findMany()
     * 
     * // Get first 10 OrderOnProducts
     * const orderOnProducts = await prisma.orderOnProducts.findMany({ take: 10 })
     * 
     * // Only select the `orderId`
     * const orderOnProductsWithOrderIdOnly = await prisma.orderOnProducts.findMany({ select: { orderId: true } })
     * 
     */
    findMany<T extends OrderOnProductsFindManyArgs>(args?: SelectSubset<T, OrderOnProductsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderOnProductsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderOnProducts.
     * @param {OrderOnProductsCreateArgs} args - Arguments to create a OrderOnProducts.
     * @example
     * // Create one OrderOnProducts
     * const OrderOnProducts = await prisma.orderOnProducts.create({
     *   data: {
     *     // ... data to create a OrderOnProducts
     *   }
     * })
     * 
     */
    create<T extends OrderOnProductsCreateArgs>(args: SelectSubset<T, OrderOnProductsCreateArgs<ExtArgs>>): Prisma__OrderOnProductsClient<$Result.GetResult<Prisma.$OrderOnProductsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderOnProducts.
     * @param {OrderOnProductsCreateManyArgs} args - Arguments to create many OrderOnProducts.
     * @example
     * // Create many OrderOnProducts
     * const orderOnProducts = await prisma.orderOnProducts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderOnProductsCreateManyArgs>(args?: SelectSubset<T, OrderOnProductsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderOnProducts and returns the data saved in the database.
     * @param {OrderOnProductsCreateManyAndReturnArgs} args - Arguments to create many OrderOnProducts.
     * @example
     * // Create many OrderOnProducts
     * const orderOnProducts = await prisma.orderOnProducts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderOnProducts and only return the `orderId`
     * const orderOnProductsWithOrderIdOnly = await prisma.orderOnProducts.createManyAndReturn({
     *   select: { orderId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderOnProductsCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderOnProductsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderOnProductsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderOnProducts.
     * @param {OrderOnProductsDeleteArgs} args - Arguments to delete one OrderOnProducts.
     * @example
     * // Delete one OrderOnProducts
     * const OrderOnProducts = await prisma.orderOnProducts.delete({
     *   where: {
     *     // ... filter to delete one OrderOnProducts
     *   }
     * })
     * 
     */
    delete<T extends OrderOnProductsDeleteArgs>(args: SelectSubset<T, OrderOnProductsDeleteArgs<ExtArgs>>): Prisma__OrderOnProductsClient<$Result.GetResult<Prisma.$OrderOnProductsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderOnProducts.
     * @param {OrderOnProductsUpdateArgs} args - Arguments to update one OrderOnProducts.
     * @example
     * // Update one OrderOnProducts
     * const orderOnProducts = await prisma.orderOnProducts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderOnProductsUpdateArgs>(args: SelectSubset<T, OrderOnProductsUpdateArgs<ExtArgs>>): Prisma__OrderOnProductsClient<$Result.GetResult<Prisma.$OrderOnProductsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderOnProducts.
     * @param {OrderOnProductsDeleteManyArgs} args - Arguments to filter OrderOnProducts to delete.
     * @example
     * // Delete a few OrderOnProducts
     * const { count } = await prisma.orderOnProducts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderOnProductsDeleteManyArgs>(args?: SelectSubset<T, OrderOnProductsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderOnProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderOnProductsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderOnProducts
     * const orderOnProducts = await prisma.orderOnProducts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderOnProductsUpdateManyArgs>(args: SelectSubset<T, OrderOnProductsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderOnProducts and returns the data updated in the database.
     * @param {OrderOnProductsUpdateManyAndReturnArgs} args - Arguments to update many OrderOnProducts.
     * @example
     * // Update many OrderOnProducts
     * const orderOnProducts = await prisma.orderOnProducts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderOnProducts and only return the `orderId`
     * const orderOnProductsWithOrderIdOnly = await prisma.orderOnProducts.updateManyAndReturn({
     *   select: { orderId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderOnProductsUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderOnProductsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderOnProductsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderOnProducts.
     * @param {OrderOnProductsUpsertArgs} args - Arguments to update or create a OrderOnProducts.
     * @example
     * // Update or create a OrderOnProducts
     * const orderOnProducts = await prisma.orderOnProducts.upsert({
     *   create: {
     *     // ... data to create a OrderOnProducts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderOnProducts we want to update
     *   }
     * })
     */
    upsert<T extends OrderOnProductsUpsertArgs>(args: SelectSubset<T, OrderOnProductsUpsertArgs<ExtArgs>>): Prisma__OrderOnProductsClient<$Result.GetResult<Prisma.$OrderOnProductsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderOnProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderOnProductsCountArgs} args - Arguments to filter OrderOnProducts to count.
     * @example
     * // Count the number of OrderOnProducts
     * const count = await prisma.orderOnProducts.count({
     *   where: {
     *     // ... the filter for the OrderOnProducts we want to count
     *   }
     * })
    **/
    count<T extends OrderOnProductsCountArgs>(
      args?: Subset<T, OrderOnProductsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderOnProductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderOnProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderOnProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderOnProductsAggregateArgs>(args: Subset<T, OrderOnProductsAggregateArgs>): Prisma.PrismaPromise<GetOrderOnProductsAggregateType<T>>

    /**
     * Group by OrderOnProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderOnProductsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderOnProductsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderOnProductsGroupByArgs['orderBy'] }
        : { orderBy?: OrderOnProductsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderOnProductsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderOnProductsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderOnProducts model
   */
  readonly fields: OrderOnProductsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderOnProducts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderOnProductsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderOnProducts model
   */
  interface OrderOnProductsFieldRefs {
    readonly orderId: FieldRef<"OrderOnProducts", 'String'>
    readonly productId: FieldRef<"OrderOnProducts", 'String'>
    readonly orderDate: FieldRef<"OrderOnProducts", 'DateTime'>
    readonly productAmount: FieldRef<"OrderOnProducts", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OrderOnProducts findUnique
   */
  export type OrderOnProductsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderOnProducts
     */
    select?: OrderOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderOnProducts
     */
    omit?: OrderOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderOnProductsInclude<ExtArgs> | null
    /**
     * Filter, which OrderOnProducts to fetch.
     */
    where: OrderOnProductsWhereUniqueInput
  }

  /**
   * OrderOnProducts findUniqueOrThrow
   */
  export type OrderOnProductsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderOnProducts
     */
    select?: OrderOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderOnProducts
     */
    omit?: OrderOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderOnProductsInclude<ExtArgs> | null
    /**
     * Filter, which OrderOnProducts to fetch.
     */
    where: OrderOnProductsWhereUniqueInput
  }

  /**
   * OrderOnProducts findFirst
   */
  export type OrderOnProductsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderOnProducts
     */
    select?: OrderOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderOnProducts
     */
    omit?: OrderOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderOnProductsInclude<ExtArgs> | null
    /**
     * Filter, which OrderOnProducts to fetch.
     */
    where?: OrderOnProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderOnProducts to fetch.
     */
    orderBy?: OrderOnProductsOrderByWithRelationInput | OrderOnProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderOnProducts.
     */
    cursor?: OrderOnProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderOnProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderOnProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderOnProducts.
     */
    distinct?: OrderOnProductsScalarFieldEnum | OrderOnProductsScalarFieldEnum[]
  }

  /**
   * OrderOnProducts findFirstOrThrow
   */
  export type OrderOnProductsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderOnProducts
     */
    select?: OrderOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderOnProducts
     */
    omit?: OrderOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderOnProductsInclude<ExtArgs> | null
    /**
     * Filter, which OrderOnProducts to fetch.
     */
    where?: OrderOnProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderOnProducts to fetch.
     */
    orderBy?: OrderOnProductsOrderByWithRelationInput | OrderOnProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderOnProducts.
     */
    cursor?: OrderOnProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderOnProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderOnProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderOnProducts.
     */
    distinct?: OrderOnProductsScalarFieldEnum | OrderOnProductsScalarFieldEnum[]
  }

  /**
   * OrderOnProducts findMany
   */
  export type OrderOnProductsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderOnProducts
     */
    select?: OrderOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderOnProducts
     */
    omit?: OrderOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderOnProductsInclude<ExtArgs> | null
    /**
     * Filter, which OrderOnProducts to fetch.
     */
    where?: OrderOnProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderOnProducts to fetch.
     */
    orderBy?: OrderOnProductsOrderByWithRelationInput | OrderOnProductsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderOnProducts.
     */
    cursor?: OrderOnProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderOnProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderOnProducts.
     */
    skip?: number
    distinct?: OrderOnProductsScalarFieldEnum | OrderOnProductsScalarFieldEnum[]
  }

  /**
   * OrderOnProducts create
   */
  export type OrderOnProductsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderOnProducts
     */
    select?: OrderOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderOnProducts
     */
    omit?: OrderOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderOnProductsInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderOnProducts.
     */
    data: XOR<OrderOnProductsCreateInput, OrderOnProductsUncheckedCreateInput>
  }

  /**
   * OrderOnProducts createMany
   */
  export type OrderOnProductsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderOnProducts.
     */
    data: OrderOnProductsCreateManyInput | OrderOnProductsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderOnProducts createManyAndReturn
   */
  export type OrderOnProductsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderOnProducts
     */
    select?: OrderOnProductsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderOnProducts
     */
    omit?: OrderOnProductsOmit<ExtArgs> | null
    /**
     * The data used to create many OrderOnProducts.
     */
    data: OrderOnProductsCreateManyInput | OrderOnProductsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderOnProductsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderOnProducts update
   */
  export type OrderOnProductsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderOnProducts
     */
    select?: OrderOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderOnProducts
     */
    omit?: OrderOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderOnProductsInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderOnProducts.
     */
    data: XOR<OrderOnProductsUpdateInput, OrderOnProductsUncheckedUpdateInput>
    /**
     * Choose, which OrderOnProducts to update.
     */
    where: OrderOnProductsWhereUniqueInput
  }

  /**
   * OrderOnProducts updateMany
   */
  export type OrderOnProductsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderOnProducts.
     */
    data: XOR<OrderOnProductsUpdateManyMutationInput, OrderOnProductsUncheckedUpdateManyInput>
    /**
     * Filter which OrderOnProducts to update
     */
    where?: OrderOnProductsWhereInput
    /**
     * Limit how many OrderOnProducts to update.
     */
    limit?: number
  }

  /**
   * OrderOnProducts updateManyAndReturn
   */
  export type OrderOnProductsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderOnProducts
     */
    select?: OrderOnProductsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderOnProducts
     */
    omit?: OrderOnProductsOmit<ExtArgs> | null
    /**
     * The data used to update OrderOnProducts.
     */
    data: XOR<OrderOnProductsUpdateManyMutationInput, OrderOnProductsUncheckedUpdateManyInput>
    /**
     * Filter which OrderOnProducts to update
     */
    where?: OrderOnProductsWhereInput
    /**
     * Limit how many OrderOnProducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderOnProductsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderOnProducts upsert
   */
  export type OrderOnProductsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderOnProducts
     */
    select?: OrderOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderOnProducts
     */
    omit?: OrderOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderOnProductsInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderOnProducts to update in case it exists.
     */
    where: OrderOnProductsWhereUniqueInput
    /**
     * In case the OrderOnProducts found by the `where` argument doesn't exist, create a new OrderOnProducts with this data.
     */
    create: XOR<OrderOnProductsCreateInput, OrderOnProductsUncheckedCreateInput>
    /**
     * In case the OrderOnProducts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderOnProductsUpdateInput, OrderOnProductsUncheckedUpdateInput>
  }

  /**
   * OrderOnProducts delete
   */
  export type OrderOnProductsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderOnProducts
     */
    select?: OrderOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderOnProducts
     */
    omit?: OrderOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderOnProductsInclude<ExtArgs> | null
    /**
     * Filter which OrderOnProducts to delete.
     */
    where: OrderOnProductsWhereUniqueInput
  }

  /**
   * OrderOnProducts deleteMany
   */
  export type OrderOnProductsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderOnProducts to delete
     */
    where?: OrderOnProductsWhereInput
    /**
     * Limit how many OrderOnProducts to delete.
     */
    limit?: number
  }

  /**
   * OrderOnProducts without action
   */
  export type OrderOnProductsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderOnProducts
     */
    select?: OrderOnProductsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderOnProducts
     */
    omit?: OrderOnProductsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderOnProductsInclude<ExtArgs> | null
  }


  /**
   * Model RoutesOnOrders
   */

  export type AggregateRoutesOnOrders = {
    _count: RoutesOnOrdersCountAggregateOutputType | null
    _min: RoutesOnOrdersMinAggregateOutputType | null
    _max: RoutesOnOrdersMaxAggregateOutputType | null
  }

  export type RoutesOnOrdersMinAggregateOutputType = {
    routeId: string | null
    orderId: string | null
  }

  export type RoutesOnOrdersMaxAggregateOutputType = {
    routeId: string | null
    orderId: string | null
  }

  export type RoutesOnOrdersCountAggregateOutputType = {
    routeId: number
    orderId: number
    _all: number
  }


  export type RoutesOnOrdersMinAggregateInputType = {
    routeId?: true
    orderId?: true
  }

  export type RoutesOnOrdersMaxAggregateInputType = {
    routeId?: true
    orderId?: true
  }

  export type RoutesOnOrdersCountAggregateInputType = {
    routeId?: true
    orderId?: true
    _all?: true
  }

  export type RoutesOnOrdersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoutesOnOrders to aggregate.
     */
    where?: RoutesOnOrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoutesOnOrders to fetch.
     */
    orderBy?: RoutesOnOrdersOrderByWithRelationInput | RoutesOnOrdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoutesOnOrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoutesOnOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoutesOnOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoutesOnOrders
    **/
    _count?: true | RoutesOnOrdersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoutesOnOrdersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoutesOnOrdersMaxAggregateInputType
  }

  export type GetRoutesOnOrdersAggregateType<T extends RoutesOnOrdersAggregateArgs> = {
        [P in keyof T & keyof AggregateRoutesOnOrders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoutesOnOrders[P]>
      : GetScalarType<T[P], AggregateRoutesOnOrders[P]>
  }




  export type RoutesOnOrdersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoutesOnOrdersWhereInput
    orderBy?: RoutesOnOrdersOrderByWithAggregationInput | RoutesOnOrdersOrderByWithAggregationInput[]
    by: RoutesOnOrdersScalarFieldEnum[] | RoutesOnOrdersScalarFieldEnum
    having?: RoutesOnOrdersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoutesOnOrdersCountAggregateInputType | true
    _min?: RoutesOnOrdersMinAggregateInputType
    _max?: RoutesOnOrdersMaxAggregateInputType
  }

  export type RoutesOnOrdersGroupByOutputType = {
    routeId: string
    orderId: string
    _count: RoutesOnOrdersCountAggregateOutputType | null
    _min: RoutesOnOrdersMinAggregateOutputType | null
    _max: RoutesOnOrdersMaxAggregateOutputType | null
  }

  type GetRoutesOnOrdersGroupByPayload<T extends RoutesOnOrdersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoutesOnOrdersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoutesOnOrdersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoutesOnOrdersGroupByOutputType[P]>
            : GetScalarType<T[P], RoutesOnOrdersGroupByOutputType[P]>
        }
      >
    >


  export type RoutesOnOrdersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    routeId?: boolean
    orderId?: boolean
    route?: boolean | RouteDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routesOnOrders"]>

  export type RoutesOnOrdersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    routeId?: boolean
    orderId?: boolean
    route?: boolean | RouteDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routesOnOrders"]>

  export type RoutesOnOrdersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    routeId?: boolean
    orderId?: boolean
    route?: boolean | RouteDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routesOnOrders"]>

  export type RoutesOnOrdersSelectScalar = {
    routeId?: boolean
    orderId?: boolean
  }

  export type RoutesOnOrdersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"routeId" | "orderId", ExtArgs["result"]["routesOnOrders"]>
  export type RoutesOnOrdersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    route?: boolean | RouteDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type RoutesOnOrdersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    route?: boolean | RouteDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type RoutesOnOrdersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    route?: boolean | RouteDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $RoutesOnOrdersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoutesOnOrders"
    objects: {
      route: Prisma.$RoutePayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      routeId: string
      orderId: string
    }, ExtArgs["result"]["routesOnOrders"]>
    composites: {}
  }

  type RoutesOnOrdersGetPayload<S extends boolean | null | undefined | RoutesOnOrdersDefaultArgs> = $Result.GetResult<Prisma.$RoutesOnOrdersPayload, S>

  type RoutesOnOrdersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoutesOnOrdersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoutesOnOrdersCountAggregateInputType | true
    }

  export interface RoutesOnOrdersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoutesOnOrders'], meta: { name: 'RoutesOnOrders' } }
    /**
     * Find zero or one RoutesOnOrders that matches the filter.
     * @param {RoutesOnOrdersFindUniqueArgs} args - Arguments to find a RoutesOnOrders
     * @example
     * // Get one RoutesOnOrders
     * const routesOnOrders = await prisma.routesOnOrders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoutesOnOrdersFindUniqueArgs>(args: SelectSubset<T, RoutesOnOrdersFindUniqueArgs<ExtArgs>>): Prisma__RoutesOnOrdersClient<$Result.GetResult<Prisma.$RoutesOnOrdersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoutesOnOrders that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoutesOnOrdersFindUniqueOrThrowArgs} args - Arguments to find a RoutesOnOrders
     * @example
     * // Get one RoutesOnOrders
     * const routesOnOrders = await prisma.routesOnOrders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoutesOnOrdersFindUniqueOrThrowArgs>(args: SelectSubset<T, RoutesOnOrdersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoutesOnOrdersClient<$Result.GetResult<Prisma.$RoutesOnOrdersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoutesOnOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutesOnOrdersFindFirstArgs} args - Arguments to find a RoutesOnOrders
     * @example
     * // Get one RoutesOnOrders
     * const routesOnOrders = await prisma.routesOnOrders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoutesOnOrdersFindFirstArgs>(args?: SelectSubset<T, RoutesOnOrdersFindFirstArgs<ExtArgs>>): Prisma__RoutesOnOrdersClient<$Result.GetResult<Prisma.$RoutesOnOrdersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoutesOnOrders that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutesOnOrdersFindFirstOrThrowArgs} args - Arguments to find a RoutesOnOrders
     * @example
     * // Get one RoutesOnOrders
     * const routesOnOrders = await prisma.routesOnOrders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoutesOnOrdersFindFirstOrThrowArgs>(args?: SelectSubset<T, RoutesOnOrdersFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoutesOnOrdersClient<$Result.GetResult<Prisma.$RoutesOnOrdersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoutesOnOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutesOnOrdersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoutesOnOrders
     * const routesOnOrders = await prisma.routesOnOrders.findMany()
     * 
     * // Get first 10 RoutesOnOrders
     * const routesOnOrders = await prisma.routesOnOrders.findMany({ take: 10 })
     * 
     * // Only select the `routeId`
     * const routesOnOrdersWithRouteIdOnly = await prisma.routesOnOrders.findMany({ select: { routeId: true } })
     * 
     */
    findMany<T extends RoutesOnOrdersFindManyArgs>(args?: SelectSubset<T, RoutesOnOrdersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutesOnOrdersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoutesOnOrders.
     * @param {RoutesOnOrdersCreateArgs} args - Arguments to create a RoutesOnOrders.
     * @example
     * // Create one RoutesOnOrders
     * const RoutesOnOrders = await prisma.routesOnOrders.create({
     *   data: {
     *     // ... data to create a RoutesOnOrders
     *   }
     * })
     * 
     */
    create<T extends RoutesOnOrdersCreateArgs>(args: SelectSubset<T, RoutesOnOrdersCreateArgs<ExtArgs>>): Prisma__RoutesOnOrdersClient<$Result.GetResult<Prisma.$RoutesOnOrdersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoutesOnOrders.
     * @param {RoutesOnOrdersCreateManyArgs} args - Arguments to create many RoutesOnOrders.
     * @example
     * // Create many RoutesOnOrders
     * const routesOnOrders = await prisma.routesOnOrders.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoutesOnOrdersCreateManyArgs>(args?: SelectSubset<T, RoutesOnOrdersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoutesOnOrders and returns the data saved in the database.
     * @param {RoutesOnOrdersCreateManyAndReturnArgs} args - Arguments to create many RoutesOnOrders.
     * @example
     * // Create many RoutesOnOrders
     * const routesOnOrders = await prisma.routesOnOrders.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoutesOnOrders and only return the `routeId`
     * const routesOnOrdersWithRouteIdOnly = await prisma.routesOnOrders.createManyAndReturn({
     *   select: { routeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoutesOnOrdersCreateManyAndReturnArgs>(args?: SelectSubset<T, RoutesOnOrdersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutesOnOrdersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoutesOnOrders.
     * @param {RoutesOnOrdersDeleteArgs} args - Arguments to delete one RoutesOnOrders.
     * @example
     * // Delete one RoutesOnOrders
     * const RoutesOnOrders = await prisma.routesOnOrders.delete({
     *   where: {
     *     // ... filter to delete one RoutesOnOrders
     *   }
     * })
     * 
     */
    delete<T extends RoutesOnOrdersDeleteArgs>(args: SelectSubset<T, RoutesOnOrdersDeleteArgs<ExtArgs>>): Prisma__RoutesOnOrdersClient<$Result.GetResult<Prisma.$RoutesOnOrdersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoutesOnOrders.
     * @param {RoutesOnOrdersUpdateArgs} args - Arguments to update one RoutesOnOrders.
     * @example
     * // Update one RoutesOnOrders
     * const routesOnOrders = await prisma.routesOnOrders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoutesOnOrdersUpdateArgs>(args: SelectSubset<T, RoutesOnOrdersUpdateArgs<ExtArgs>>): Prisma__RoutesOnOrdersClient<$Result.GetResult<Prisma.$RoutesOnOrdersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoutesOnOrders.
     * @param {RoutesOnOrdersDeleteManyArgs} args - Arguments to filter RoutesOnOrders to delete.
     * @example
     * // Delete a few RoutesOnOrders
     * const { count } = await prisma.routesOnOrders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoutesOnOrdersDeleteManyArgs>(args?: SelectSubset<T, RoutesOnOrdersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoutesOnOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutesOnOrdersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoutesOnOrders
     * const routesOnOrders = await prisma.routesOnOrders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoutesOnOrdersUpdateManyArgs>(args: SelectSubset<T, RoutesOnOrdersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoutesOnOrders and returns the data updated in the database.
     * @param {RoutesOnOrdersUpdateManyAndReturnArgs} args - Arguments to update many RoutesOnOrders.
     * @example
     * // Update many RoutesOnOrders
     * const routesOnOrders = await prisma.routesOnOrders.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoutesOnOrders and only return the `routeId`
     * const routesOnOrdersWithRouteIdOnly = await prisma.routesOnOrders.updateManyAndReturn({
     *   select: { routeId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoutesOnOrdersUpdateManyAndReturnArgs>(args: SelectSubset<T, RoutesOnOrdersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutesOnOrdersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoutesOnOrders.
     * @param {RoutesOnOrdersUpsertArgs} args - Arguments to update or create a RoutesOnOrders.
     * @example
     * // Update or create a RoutesOnOrders
     * const routesOnOrders = await prisma.routesOnOrders.upsert({
     *   create: {
     *     // ... data to create a RoutesOnOrders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoutesOnOrders we want to update
     *   }
     * })
     */
    upsert<T extends RoutesOnOrdersUpsertArgs>(args: SelectSubset<T, RoutesOnOrdersUpsertArgs<ExtArgs>>): Prisma__RoutesOnOrdersClient<$Result.GetResult<Prisma.$RoutesOnOrdersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoutesOnOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutesOnOrdersCountArgs} args - Arguments to filter RoutesOnOrders to count.
     * @example
     * // Count the number of RoutesOnOrders
     * const count = await prisma.routesOnOrders.count({
     *   where: {
     *     // ... the filter for the RoutesOnOrders we want to count
     *   }
     * })
    **/
    count<T extends RoutesOnOrdersCountArgs>(
      args?: Subset<T, RoutesOnOrdersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoutesOnOrdersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoutesOnOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutesOnOrdersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoutesOnOrdersAggregateArgs>(args: Subset<T, RoutesOnOrdersAggregateArgs>): Prisma.PrismaPromise<GetRoutesOnOrdersAggregateType<T>>

    /**
     * Group by RoutesOnOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutesOnOrdersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoutesOnOrdersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoutesOnOrdersGroupByArgs['orderBy'] }
        : { orderBy?: RoutesOnOrdersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoutesOnOrdersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoutesOnOrdersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoutesOnOrders model
   */
  readonly fields: RoutesOnOrdersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoutesOnOrders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoutesOnOrdersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    route<T extends RouteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RouteDefaultArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoutesOnOrders model
   */
  interface RoutesOnOrdersFieldRefs {
    readonly routeId: FieldRef<"RoutesOnOrders", 'String'>
    readonly orderId: FieldRef<"RoutesOnOrders", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RoutesOnOrders findUnique
   */
  export type RoutesOnOrdersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutesOnOrders
     */
    select?: RoutesOnOrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoutesOnOrders
     */
    omit?: RoutesOnOrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutesOnOrdersInclude<ExtArgs> | null
    /**
     * Filter, which RoutesOnOrders to fetch.
     */
    where: RoutesOnOrdersWhereUniqueInput
  }

  /**
   * RoutesOnOrders findUniqueOrThrow
   */
  export type RoutesOnOrdersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutesOnOrders
     */
    select?: RoutesOnOrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoutesOnOrders
     */
    omit?: RoutesOnOrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutesOnOrdersInclude<ExtArgs> | null
    /**
     * Filter, which RoutesOnOrders to fetch.
     */
    where: RoutesOnOrdersWhereUniqueInput
  }

  /**
   * RoutesOnOrders findFirst
   */
  export type RoutesOnOrdersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutesOnOrders
     */
    select?: RoutesOnOrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoutesOnOrders
     */
    omit?: RoutesOnOrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutesOnOrdersInclude<ExtArgs> | null
    /**
     * Filter, which RoutesOnOrders to fetch.
     */
    where?: RoutesOnOrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoutesOnOrders to fetch.
     */
    orderBy?: RoutesOnOrdersOrderByWithRelationInput | RoutesOnOrdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoutesOnOrders.
     */
    cursor?: RoutesOnOrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoutesOnOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoutesOnOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoutesOnOrders.
     */
    distinct?: RoutesOnOrdersScalarFieldEnum | RoutesOnOrdersScalarFieldEnum[]
  }

  /**
   * RoutesOnOrders findFirstOrThrow
   */
  export type RoutesOnOrdersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutesOnOrders
     */
    select?: RoutesOnOrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoutesOnOrders
     */
    omit?: RoutesOnOrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutesOnOrdersInclude<ExtArgs> | null
    /**
     * Filter, which RoutesOnOrders to fetch.
     */
    where?: RoutesOnOrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoutesOnOrders to fetch.
     */
    orderBy?: RoutesOnOrdersOrderByWithRelationInput | RoutesOnOrdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoutesOnOrders.
     */
    cursor?: RoutesOnOrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoutesOnOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoutesOnOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoutesOnOrders.
     */
    distinct?: RoutesOnOrdersScalarFieldEnum | RoutesOnOrdersScalarFieldEnum[]
  }

  /**
   * RoutesOnOrders findMany
   */
  export type RoutesOnOrdersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutesOnOrders
     */
    select?: RoutesOnOrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoutesOnOrders
     */
    omit?: RoutesOnOrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutesOnOrdersInclude<ExtArgs> | null
    /**
     * Filter, which RoutesOnOrders to fetch.
     */
    where?: RoutesOnOrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoutesOnOrders to fetch.
     */
    orderBy?: RoutesOnOrdersOrderByWithRelationInput | RoutesOnOrdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoutesOnOrders.
     */
    cursor?: RoutesOnOrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoutesOnOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoutesOnOrders.
     */
    skip?: number
    distinct?: RoutesOnOrdersScalarFieldEnum | RoutesOnOrdersScalarFieldEnum[]
  }

  /**
   * RoutesOnOrders create
   */
  export type RoutesOnOrdersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutesOnOrders
     */
    select?: RoutesOnOrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoutesOnOrders
     */
    omit?: RoutesOnOrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutesOnOrdersInclude<ExtArgs> | null
    /**
     * The data needed to create a RoutesOnOrders.
     */
    data: XOR<RoutesOnOrdersCreateInput, RoutesOnOrdersUncheckedCreateInput>
  }

  /**
   * RoutesOnOrders createMany
   */
  export type RoutesOnOrdersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoutesOnOrders.
     */
    data: RoutesOnOrdersCreateManyInput | RoutesOnOrdersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoutesOnOrders createManyAndReturn
   */
  export type RoutesOnOrdersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutesOnOrders
     */
    select?: RoutesOnOrdersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoutesOnOrders
     */
    omit?: RoutesOnOrdersOmit<ExtArgs> | null
    /**
     * The data used to create many RoutesOnOrders.
     */
    data: RoutesOnOrdersCreateManyInput | RoutesOnOrdersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutesOnOrdersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoutesOnOrders update
   */
  export type RoutesOnOrdersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutesOnOrders
     */
    select?: RoutesOnOrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoutesOnOrders
     */
    omit?: RoutesOnOrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutesOnOrdersInclude<ExtArgs> | null
    /**
     * The data needed to update a RoutesOnOrders.
     */
    data: XOR<RoutesOnOrdersUpdateInput, RoutesOnOrdersUncheckedUpdateInput>
    /**
     * Choose, which RoutesOnOrders to update.
     */
    where: RoutesOnOrdersWhereUniqueInput
  }

  /**
   * RoutesOnOrders updateMany
   */
  export type RoutesOnOrdersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoutesOnOrders.
     */
    data: XOR<RoutesOnOrdersUpdateManyMutationInput, RoutesOnOrdersUncheckedUpdateManyInput>
    /**
     * Filter which RoutesOnOrders to update
     */
    where?: RoutesOnOrdersWhereInput
    /**
     * Limit how many RoutesOnOrders to update.
     */
    limit?: number
  }

  /**
   * RoutesOnOrders updateManyAndReturn
   */
  export type RoutesOnOrdersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutesOnOrders
     */
    select?: RoutesOnOrdersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoutesOnOrders
     */
    omit?: RoutesOnOrdersOmit<ExtArgs> | null
    /**
     * The data used to update RoutesOnOrders.
     */
    data: XOR<RoutesOnOrdersUpdateManyMutationInput, RoutesOnOrdersUncheckedUpdateManyInput>
    /**
     * Filter which RoutesOnOrders to update
     */
    where?: RoutesOnOrdersWhereInput
    /**
     * Limit how many RoutesOnOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutesOnOrdersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoutesOnOrders upsert
   */
  export type RoutesOnOrdersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutesOnOrders
     */
    select?: RoutesOnOrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoutesOnOrders
     */
    omit?: RoutesOnOrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutesOnOrdersInclude<ExtArgs> | null
    /**
     * The filter to search for the RoutesOnOrders to update in case it exists.
     */
    where: RoutesOnOrdersWhereUniqueInput
    /**
     * In case the RoutesOnOrders found by the `where` argument doesn't exist, create a new RoutesOnOrders with this data.
     */
    create: XOR<RoutesOnOrdersCreateInput, RoutesOnOrdersUncheckedCreateInput>
    /**
     * In case the RoutesOnOrders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoutesOnOrdersUpdateInput, RoutesOnOrdersUncheckedUpdateInput>
  }

  /**
   * RoutesOnOrders delete
   */
  export type RoutesOnOrdersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutesOnOrders
     */
    select?: RoutesOnOrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoutesOnOrders
     */
    omit?: RoutesOnOrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutesOnOrdersInclude<ExtArgs> | null
    /**
     * Filter which RoutesOnOrders to delete.
     */
    where: RoutesOnOrdersWhereUniqueInput
  }

  /**
   * RoutesOnOrders deleteMany
   */
  export type RoutesOnOrdersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoutesOnOrders to delete
     */
    where?: RoutesOnOrdersWhereInput
    /**
     * Limit how many RoutesOnOrders to delete.
     */
    limit?: number
  }

  /**
   * RoutesOnOrders without action
   */
  export type RoutesOnOrdersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutesOnOrders
     */
    select?: RoutesOnOrdersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoutesOnOrders
     */
    omit?: RoutesOnOrdersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutesOnOrdersInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CustomerScalarFieldEnum: {
    customerId: 'customerId',
    customerReference: 'customerReference',
    email: 'email',
    phoneNumber: 'phoneNumber',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    companyNumber: 'companyNumber',
    modifiedAt: 'modifiedAt',
    deleted: 'deleted',
    signedUp: 'signedUp',
    avatarPath: 'avatarPath',
    addressId: 'addressId',
    businessSector: 'businessSector'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const CustomerHistoryScalarFieldEnum: {
    historyId: 'historyId',
    customerReference: 'customerReference',
    email: 'email',
    phoneNumber: 'phoneNumber',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    companyNumber: 'companyNumber',
    modifiedAt: 'modifiedAt',
    deleted: 'deleted',
    signedUp: 'signedUp',
    avatarPath: 'avatarPath',
    addressId: 'addressId',
    businessSector: 'businessSector'
  };

  export type CustomerHistoryScalarFieldEnum = (typeof CustomerHistoryScalarFieldEnum)[keyof typeof CustomerHistoryScalarFieldEnum]


  export const CartScalarFieldEnum: {
    cartId: 'cartId',
    customerReference: 'customerReference'
  };

  export type CartScalarFieldEnum = (typeof CartScalarFieldEnum)[keyof typeof CartScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    addressId: 'addressId',
    city: 'city',
    country: 'country',
    postCode: 'postCode',
    state: 'state',
    streetName: 'streetName',
    streetNumber: 'streetNumber',
    modifiedAt: 'modifiedAt',
    deleted: 'deleted'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    productId: 'productId',
    name: 'name',
    price: 'price',
    description: 'description',
    stock: 'stock',
    imagePath: 'imagePath',
    createdAt: 'createdAt',
    modifiedAt: 'modifiedAt',
    deleted: 'deleted',
    categoryId: 'categoryId'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductHistoryScalarFieldEnum: {
    historyId: 'historyId',
    productId: 'productId',
    name: 'name',
    price: 'price',
    description: 'description',
    stock: 'stock',
    imagePath: 'imagePath',
    createdAt: 'createdAt',
    modifiedAt: 'modifiedAt',
    deleted: 'deleted',
    categoryId: 'categoryId'
  };

  export type ProductHistoryScalarFieldEnum = (typeof ProductHistoryScalarFieldEnum)[keyof typeof ProductHistoryScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    categoryId: 'categoryId',
    name: 'name',
    imagePath: 'imagePath',
    deleted: 'deleted'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    orderId: 'orderId',
    customerReference: 'customerReference',
    orderDate: 'orderDate',
    deliveryDate: 'deliveryDate',
    deleted: 'deleted',
    orderState: 'orderState',
    selfCollect: 'selfCollect'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    invoiceId: 'invoiceId',
    orderId: 'orderId',
    invoiceAmount: 'invoiceAmount',
    paymentDate: 'paymentDate',
    pdfUrl: 'pdfUrl',
    deleted: 'deleted'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const RouteScalarFieldEnum: {
    routeId: 'routeId',
    name: 'name',
    deleted: 'deleted'
  };

  export type RouteScalarFieldEnum = (typeof RouteScalarFieldEnum)[keyof typeof RouteScalarFieldEnum]


  export const EmployeesScalarFieldEnum: {
    employeeId: 'employeeId',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    deleted: 'deleted',
    role: 'role'
  };

  export type EmployeesScalarFieldEnum = (typeof EmployeesScalarFieldEnum)[keyof typeof EmployeesScalarFieldEnum]


  export const SiteConfigScalarFieldEnum: {
    siteConfigId: 'siteConfigId',
    companyName: 'companyName',
    logoPath: 'logoPath',
    email: 'email',
    phoneNumber: 'phoneNumber',
    iban: 'iban',
    companyNumber: 'companyNumber',
    addressId: 'addressId',
    modifiedAt: 'modifiedAt',
    isPremium: 'isPremium',
    deleted: 'deleted',
    stripeCustomerId: 'stripeCustomerId',
    stripeAccountId: 'stripeAccountId',
    stripeConfigured: 'stripeConfigured'
  };

  export type SiteConfigScalarFieldEnum = (typeof SiteConfigScalarFieldEnum)[keyof typeof SiteConfigScalarFieldEnum]


  export const ActionScalarFieldEnum: {
    name: 'name',
    description: 'description',
    deleted: 'deleted'
  };

  export type ActionScalarFieldEnum = (typeof ActionScalarFieldEnum)[keyof typeof ActionScalarFieldEnum]


  export const RessourceScalarFieldEnum: {
    name: 'name',
    description: 'description',
    deleted: 'deleted'
  };

  export type RessourceScalarFieldEnum = (typeof RessourceScalarFieldEnum)[keyof typeof RessourceScalarFieldEnum]


  export const ResourceActionScalarFieldEnum: {
    action: 'action',
    resource: 'resource'
  };

  export type ResourceActionScalarFieldEnum = (typeof ResourceActionScalarFieldEnum)[keyof typeof ResourceActionScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    name: 'name',
    description: 'description',
    deleted: 'deleted'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    role: 'role',
    action: 'action',
    resource: 'resource',
    allowed: 'allowed',
    createdAt: 'createdAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const CartOnProductsScalarFieldEnum: {
    cartId: 'cartId',
    productId: 'productId',
    quantity: 'quantity'
  };

  export type CartOnProductsScalarFieldEnum = (typeof CartOnProductsScalarFieldEnum)[keyof typeof CartOnProductsScalarFieldEnum]


  export const OrderOnProductsScalarFieldEnum: {
    orderId: 'orderId',
    productId: 'productId',
    orderDate: 'orderDate',
    productAmount: 'productAmount'
  };

  export type OrderOnProductsScalarFieldEnum = (typeof OrderOnProductsScalarFieldEnum)[keyof typeof OrderOnProductsScalarFieldEnum]


  export const RoutesOnOrdersScalarFieldEnum: {
    routeId: 'routeId',
    orderId: 'orderId'
  };

  export type RoutesOnOrdersScalarFieldEnum = (typeof RoutesOnOrdersScalarFieldEnum)[keyof typeof RoutesOnOrdersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'BusinessSector'
   */
  export type EnumBusinessSectorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BusinessSector'>
    


  /**
   * Reference to a field of type 'BusinessSector[]'
   */
  export type ListEnumBusinessSectorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BusinessSector[]'>
    


  /**
   * Reference to a field of type 'OrderState'
   */
  export type EnumOrderStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderState'>
    


  /**
   * Reference to a field of type 'OrderState[]'
   */
  export type ListEnumOrderStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderState[]'>
    


  /**
   * Reference to a field of type 'Actions'
   */
  export type EnumActionsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Actions'>
    


  /**
   * Reference to a field of type 'Actions[]'
   */
  export type ListEnumActionsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Actions[]'>
    


  /**
   * Reference to a field of type 'Ressources'
   */
  export type EnumRessourcesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Ressources'>
    


  /**
   * Reference to a field of type 'Ressources[]'
   */
  export type ListEnumRessourcesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Ressources[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    customerId?: UuidFilter<"Customer"> | string
    customerReference?: IntFilter<"Customer"> | number
    email?: StringFilter<"Customer"> | string
    phoneNumber?: StringFilter<"Customer"> | string
    password?: StringFilter<"Customer"> | string
    firstName?: StringNullableFilter<"Customer"> | string | null
    lastName?: StringFilter<"Customer"> | string
    companyNumber?: StringNullableFilter<"Customer"> | string | null
    modifiedAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    deleted?: BoolFilter<"Customer"> | boolean
    signedUp?: DateTimeFilter<"Customer"> | Date | string
    avatarPath?: StringNullableFilter<"Customer"> | string | null
    addressId?: UuidFilter<"Customer"> | string
    businessSector?: EnumBusinessSectorNullableFilter<"Customer"> | $Enums.BusinessSector | null
    address?: XOR<AddressScalarRelationFilter, AddressWhereInput>
    cart?: XOR<CartNullableScalarRelationFilter, CartWhereInput> | null
    orders?: OrderListRelationFilter
    history?: CustomerHistoryListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    customerId?: SortOrder
    customerReference?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    companyNumber?: SortOrderInput | SortOrder
    modifiedAt?: SortOrderInput | SortOrder
    deleted?: SortOrder
    signedUp?: SortOrder
    avatarPath?: SortOrderInput | SortOrder
    addressId?: SortOrder
    businessSector?: SortOrderInput | SortOrder
    address?: AddressOrderByWithRelationInput
    cart?: CartOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
    history?: CustomerHistoryOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    customerId?: string
    customerReference?: number
    email?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    phoneNumber?: StringFilter<"Customer"> | string
    password?: StringFilter<"Customer"> | string
    firstName?: StringNullableFilter<"Customer"> | string | null
    lastName?: StringFilter<"Customer"> | string
    companyNumber?: StringNullableFilter<"Customer"> | string | null
    modifiedAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    deleted?: BoolFilter<"Customer"> | boolean
    signedUp?: DateTimeFilter<"Customer"> | Date | string
    avatarPath?: StringNullableFilter<"Customer"> | string | null
    addressId?: UuidFilter<"Customer"> | string
    businessSector?: EnumBusinessSectorNullableFilter<"Customer"> | $Enums.BusinessSector | null
    address?: XOR<AddressScalarRelationFilter, AddressWhereInput>
    cart?: XOR<CartNullableScalarRelationFilter, CartWhereInput> | null
    orders?: OrderListRelationFilter
    history?: CustomerHistoryListRelationFilter
  }, "customerId" | "customerReference" | "email">

  export type CustomerOrderByWithAggregationInput = {
    customerId?: SortOrder
    customerReference?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    companyNumber?: SortOrderInput | SortOrder
    modifiedAt?: SortOrderInput | SortOrder
    deleted?: SortOrder
    signedUp?: SortOrder
    avatarPath?: SortOrderInput | SortOrder
    addressId?: SortOrder
    businessSector?: SortOrderInput | SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    customerId?: UuidWithAggregatesFilter<"Customer"> | string
    customerReference?: IntWithAggregatesFilter<"Customer"> | number
    email?: StringWithAggregatesFilter<"Customer"> | string
    phoneNumber?: StringWithAggregatesFilter<"Customer"> | string
    password?: StringWithAggregatesFilter<"Customer"> | string
    firstName?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    lastName?: StringWithAggregatesFilter<"Customer"> | string
    companyNumber?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    modifiedAt?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    deleted?: BoolWithAggregatesFilter<"Customer"> | boolean
    signedUp?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    avatarPath?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    addressId?: UuidWithAggregatesFilter<"Customer"> | string
    businessSector?: EnumBusinessSectorNullableWithAggregatesFilter<"Customer"> | $Enums.BusinessSector | null
  }

  export type CustomerHistoryWhereInput = {
    AND?: CustomerHistoryWhereInput | CustomerHistoryWhereInput[]
    OR?: CustomerHistoryWhereInput[]
    NOT?: CustomerHistoryWhereInput | CustomerHistoryWhereInput[]
    historyId?: UuidFilter<"CustomerHistory"> | string
    customerReference?: IntFilter<"CustomerHistory"> | number
    email?: StringFilter<"CustomerHistory"> | string
    phoneNumber?: StringFilter<"CustomerHistory"> | string
    password?: StringFilter<"CustomerHistory"> | string
    firstName?: StringNullableFilter<"CustomerHistory"> | string | null
    lastName?: StringFilter<"CustomerHistory"> | string
    companyNumber?: StringNullableFilter<"CustomerHistory"> | string | null
    modifiedAt?: DateTimeNullableFilter<"CustomerHistory"> | Date | string | null
    deleted?: BoolFilter<"CustomerHistory"> | boolean
    signedUp?: DateTimeFilter<"CustomerHistory"> | Date | string
    avatarPath?: StringNullableFilter<"CustomerHistory"> | string | null
    addressId?: UuidFilter<"CustomerHistory"> | string
    businessSector?: EnumBusinessSectorNullableFilter<"CustomerHistory"> | $Enums.BusinessSector | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type CustomerHistoryOrderByWithRelationInput = {
    historyId?: SortOrder
    customerReference?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    companyNumber?: SortOrderInput | SortOrder
    modifiedAt?: SortOrderInput | SortOrder
    deleted?: SortOrder
    signedUp?: SortOrder
    avatarPath?: SortOrderInput | SortOrder
    addressId?: SortOrder
    businessSector?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
  }

  export type CustomerHistoryWhereUniqueInput = Prisma.AtLeast<{
    historyId?: string
    AND?: CustomerHistoryWhereInput | CustomerHistoryWhereInput[]
    OR?: CustomerHistoryWhereInput[]
    NOT?: CustomerHistoryWhereInput | CustomerHistoryWhereInput[]
    customerReference?: IntFilter<"CustomerHistory"> | number
    email?: StringFilter<"CustomerHistory"> | string
    phoneNumber?: StringFilter<"CustomerHistory"> | string
    password?: StringFilter<"CustomerHistory"> | string
    firstName?: StringNullableFilter<"CustomerHistory"> | string | null
    lastName?: StringFilter<"CustomerHistory"> | string
    companyNumber?: StringNullableFilter<"CustomerHistory"> | string | null
    modifiedAt?: DateTimeNullableFilter<"CustomerHistory"> | Date | string | null
    deleted?: BoolFilter<"CustomerHistory"> | boolean
    signedUp?: DateTimeFilter<"CustomerHistory"> | Date | string
    avatarPath?: StringNullableFilter<"CustomerHistory"> | string | null
    addressId?: UuidFilter<"CustomerHistory"> | string
    businessSector?: EnumBusinessSectorNullableFilter<"CustomerHistory"> | $Enums.BusinessSector | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "historyId">

  export type CustomerHistoryOrderByWithAggregationInput = {
    historyId?: SortOrder
    customerReference?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    companyNumber?: SortOrderInput | SortOrder
    modifiedAt?: SortOrderInput | SortOrder
    deleted?: SortOrder
    signedUp?: SortOrder
    avatarPath?: SortOrderInput | SortOrder
    addressId?: SortOrder
    businessSector?: SortOrderInput | SortOrder
    _count?: CustomerHistoryCountOrderByAggregateInput
    _avg?: CustomerHistoryAvgOrderByAggregateInput
    _max?: CustomerHistoryMaxOrderByAggregateInput
    _min?: CustomerHistoryMinOrderByAggregateInput
    _sum?: CustomerHistorySumOrderByAggregateInput
  }

  export type CustomerHistoryScalarWhereWithAggregatesInput = {
    AND?: CustomerHistoryScalarWhereWithAggregatesInput | CustomerHistoryScalarWhereWithAggregatesInput[]
    OR?: CustomerHistoryScalarWhereWithAggregatesInput[]
    NOT?: CustomerHistoryScalarWhereWithAggregatesInput | CustomerHistoryScalarWhereWithAggregatesInput[]
    historyId?: UuidWithAggregatesFilter<"CustomerHistory"> | string
    customerReference?: IntWithAggregatesFilter<"CustomerHistory"> | number
    email?: StringWithAggregatesFilter<"CustomerHistory"> | string
    phoneNumber?: StringWithAggregatesFilter<"CustomerHistory"> | string
    password?: StringWithAggregatesFilter<"CustomerHistory"> | string
    firstName?: StringNullableWithAggregatesFilter<"CustomerHistory"> | string | null
    lastName?: StringWithAggregatesFilter<"CustomerHistory"> | string
    companyNumber?: StringNullableWithAggregatesFilter<"CustomerHistory"> | string | null
    modifiedAt?: DateTimeNullableWithAggregatesFilter<"CustomerHistory"> | Date | string | null
    deleted?: BoolWithAggregatesFilter<"CustomerHistory"> | boolean
    signedUp?: DateTimeWithAggregatesFilter<"CustomerHistory"> | Date | string
    avatarPath?: StringNullableWithAggregatesFilter<"CustomerHistory"> | string | null
    addressId?: UuidWithAggregatesFilter<"CustomerHistory"> | string
    businessSector?: EnumBusinessSectorNullableWithAggregatesFilter<"CustomerHistory"> | $Enums.BusinessSector | null
  }

  export type CartWhereInput = {
    AND?: CartWhereInput | CartWhereInput[]
    OR?: CartWhereInput[]
    NOT?: CartWhereInput | CartWhereInput[]
    cartId?: UuidFilter<"Cart"> | string
    customerReference?: IntNullableFilter<"Cart"> | number | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    products?: CartOnProductsListRelationFilter
  }

  export type CartOrderByWithRelationInput = {
    cartId?: SortOrder
    customerReference?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    products?: CartOnProductsOrderByRelationAggregateInput
  }

  export type CartWhereUniqueInput = Prisma.AtLeast<{
    cartId?: string
    customerReference?: number
    AND?: CartWhereInput | CartWhereInput[]
    OR?: CartWhereInput[]
    NOT?: CartWhereInput | CartWhereInput[]
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    products?: CartOnProductsListRelationFilter
  }, "cartId" | "customerReference">

  export type CartOrderByWithAggregationInput = {
    cartId?: SortOrder
    customerReference?: SortOrderInput | SortOrder
    _count?: CartCountOrderByAggregateInput
    _avg?: CartAvgOrderByAggregateInput
    _max?: CartMaxOrderByAggregateInput
    _min?: CartMinOrderByAggregateInput
    _sum?: CartSumOrderByAggregateInput
  }

  export type CartScalarWhereWithAggregatesInput = {
    AND?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
    OR?: CartScalarWhereWithAggregatesInput[]
    NOT?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
    cartId?: UuidWithAggregatesFilter<"Cart"> | string
    customerReference?: IntNullableWithAggregatesFilter<"Cart"> | number | null
  }

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    addressId?: UuidFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    postCode?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    streetName?: StringFilter<"Address"> | string
    streetNumber?: StringFilter<"Address"> | string
    modifiedAt?: DateTimeNullableFilter<"Address"> | Date | string | null
    deleted?: BoolFilter<"Address"> | boolean
    customers?: CustomerListRelationFilter
    siteConfig?: SiteConfigListRelationFilter
  }

  export type AddressOrderByWithRelationInput = {
    addressId?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postCode?: SortOrder
    state?: SortOrder
    streetName?: SortOrder
    streetNumber?: SortOrder
    modifiedAt?: SortOrderInput | SortOrder
    deleted?: SortOrder
    customers?: CustomerOrderByRelationAggregateInput
    siteConfig?: SiteConfigOrderByRelationAggregateInput
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    addressId?: string
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    city?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    postCode?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    streetName?: StringFilter<"Address"> | string
    streetNumber?: StringFilter<"Address"> | string
    modifiedAt?: DateTimeNullableFilter<"Address"> | Date | string | null
    deleted?: BoolFilter<"Address"> | boolean
    customers?: CustomerListRelationFilter
    siteConfig?: SiteConfigListRelationFilter
  }, "addressId">

  export type AddressOrderByWithAggregationInput = {
    addressId?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postCode?: SortOrder
    state?: SortOrder
    streetName?: SortOrder
    streetNumber?: SortOrder
    modifiedAt?: SortOrderInput | SortOrder
    deleted?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    addressId?: UuidWithAggregatesFilter<"Address"> | string
    city?: StringWithAggregatesFilter<"Address"> | string
    country?: StringWithAggregatesFilter<"Address"> | string
    postCode?: StringWithAggregatesFilter<"Address"> | string
    state?: StringWithAggregatesFilter<"Address"> | string
    streetName?: StringWithAggregatesFilter<"Address"> | string
    streetNumber?: StringWithAggregatesFilter<"Address"> | string
    modifiedAt?: DateTimeNullableWithAggregatesFilter<"Address"> | Date | string | null
    deleted?: BoolWithAggregatesFilter<"Address"> | boolean
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    productId?: UuidFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    price?: IntFilter<"Product"> | number
    description?: StringFilter<"Product"> | string
    stock?: IntFilter<"Product"> | number
    imagePath?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    modifiedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    deleted?: BoolFilter<"Product"> | boolean
    categoryId?: UuidFilter<"Product"> | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    carts?: CartOnProductsListRelationFilter
    orders?: OrderOnProductsListRelationFilter
    ProductHistory?: ProductHistoryListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    productId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrder
    stock?: SortOrder
    imagePath?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrderInput | SortOrder
    deleted?: SortOrder
    categoryId?: SortOrder
    category?: CategoryOrderByWithRelationInput
    carts?: CartOnProductsOrderByRelationAggregateInput
    orders?: OrderOnProductsOrderByRelationAggregateInput
    ProductHistory?: ProductHistoryOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    productId?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    price?: IntFilter<"Product"> | number
    description?: StringFilter<"Product"> | string
    stock?: IntFilter<"Product"> | number
    imagePath?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    modifiedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    deleted?: BoolFilter<"Product"> | boolean
    categoryId?: UuidFilter<"Product"> | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    carts?: CartOnProductsListRelationFilter
    orders?: OrderOnProductsListRelationFilter
    ProductHistory?: ProductHistoryListRelationFilter
  }, "productId">

  export type ProductOrderByWithAggregationInput = {
    productId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrder
    stock?: SortOrder
    imagePath?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrderInput | SortOrder
    deleted?: SortOrder
    categoryId?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    productId?: UuidWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    price?: IntWithAggregatesFilter<"Product"> | number
    description?: StringWithAggregatesFilter<"Product"> | string
    stock?: IntWithAggregatesFilter<"Product"> | number
    imagePath?: StringNullableWithAggregatesFilter<"Product"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    modifiedAt?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    deleted?: BoolWithAggregatesFilter<"Product"> | boolean
    categoryId?: UuidWithAggregatesFilter<"Product"> | string
  }

  export type ProductHistoryWhereInput = {
    AND?: ProductHistoryWhereInput | ProductHistoryWhereInput[]
    OR?: ProductHistoryWhereInput[]
    NOT?: ProductHistoryWhereInput | ProductHistoryWhereInput[]
    historyId?: UuidFilter<"ProductHistory"> | string
    productId?: UuidFilter<"ProductHistory"> | string
    name?: StringFilter<"ProductHistory"> | string
    price?: IntFilter<"ProductHistory"> | number
    description?: StringFilter<"ProductHistory"> | string
    stock?: IntFilter<"ProductHistory"> | number
    imagePath?: StringNullableFilter<"ProductHistory"> | string | null
    createdAt?: DateTimeFilter<"ProductHistory"> | Date | string
    modifiedAt?: DateTimeNullableFilter<"ProductHistory"> | Date | string | null
    deleted?: BoolFilter<"ProductHistory"> | boolean
    categoryId?: UuidFilter<"ProductHistory"> | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductHistoryOrderByWithRelationInput = {
    historyId?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrder
    stock?: SortOrder
    imagePath?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrderInput | SortOrder
    deleted?: SortOrder
    categoryId?: SortOrder
    category?: CategoryOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type ProductHistoryWhereUniqueInput = Prisma.AtLeast<{
    historyId?: string
    AND?: ProductHistoryWhereInput | ProductHistoryWhereInput[]
    OR?: ProductHistoryWhereInput[]
    NOT?: ProductHistoryWhereInput | ProductHistoryWhereInput[]
    productId?: UuidFilter<"ProductHistory"> | string
    name?: StringFilter<"ProductHistory"> | string
    price?: IntFilter<"ProductHistory"> | number
    description?: StringFilter<"ProductHistory"> | string
    stock?: IntFilter<"ProductHistory"> | number
    imagePath?: StringNullableFilter<"ProductHistory"> | string | null
    createdAt?: DateTimeFilter<"ProductHistory"> | Date | string
    modifiedAt?: DateTimeNullableFilter<"ProductHistory"> | Date | string | null
    deleted?: BoolFilter<"ProductHistory"> | boolean
    categoryId?: UuidFilter<"ProductHistory"> | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "historyId">

  export type ProductHistoryOrderByWithAggregationInput = {
    historyId?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrder
    stock?: SortOrder
    imagePath?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrderInput | SortOrder
    deleted?: SortOrder
    categoryId?: SortOrder
    _count?: ProductHistoryCountOrderByAggregateInput
    _avg?: ProductHistoryAvgOrderByAggregateInput
    _max?: ProductHistoryMaxOrderByAggregateInput
    _min?: ProductHistoryMinOrderByAggregateInput
    _sum?: ProductHistorySumOrderByAggregateInput
  }

  export type ProductHistoryScalarWhereWithAggregatesInput = {
    AND?: ProductHistoryScalarWhereWithAggregatesInput | ProductHistoryScalarWhereWithAggregatesInput[]
    OR?: ProductHistoryScalarWhereWithAggregatesInput[]
    NOT?: ProductHistoryScalarWhereWithAggregatesInput | ProductHistoryScalarWhereWithAggregatesInput[]
    historyId?: UuidWithAggregatesFilter<"ProductHistory"> | string
    productId?: UuidWithAggregatesFilter<"ProductHistory"> | string
    name?: StringWithAggregatesFilter<"ProductHistory"> | string
    price?: IntWithAggregatesFilter<"ProductHistory"> | number
    description?: StringWithAggregatesFilter<"ProductHistory"> | string
    stock?: IntWithAggregatesFilter<"ProductHistory"> | number
    imagePath?: StringNullableWithAggregatesFilter<"ProductHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductHistory"> | Date | string
    modifiedAt?: DateTimeNullableWithAggregatesFilter<"ProductHistory"> | Date | string | null
    deleted?: BoolWithAggregatesFilter<"ProductHistory"> | boolean
    categoryId?: UuidWithAggregatesFilter<"ProductHistory"> | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    categoryId?: UuidFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    imagePath?: StringNullableFilter<"Category"> | string | null
    deleted?: BoolFilter<"Category"> | boolean
    products?: ProductListRelationFilter
    ProductHistory?: ProductHistoryListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    categoryId?: SortOrder
    name?: SortOrder
    imagePath?: SortOrderInput | SortOrder
    deleted?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    ProductHistory?: ProductHistoryOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    categoryId?: string
    name?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    imagePath?: StringNullableFilter<"Category"> | string | null
    deleted?: BoolFilter<"Category"> | boolean
    products?: ProductListRelationFilter
    ProductHistory?: ProductHistoryListRelationFilter
  }, "categoryId" | "name">

  export type CategoryOrderByWithAggregationInput = {
    categoryId?: SortOrder
    name?: SortOrder
    imagePath?: SortOrderInput | SortOrder
    deleted?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    categoryId?: UuidWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    imagePath?: StringNullableWithAggregatesFilter<"Category"> | string | null
    deleted?: BoolWithAggregatesFilter<"Category"> | boolean
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    orderId?: UuidFilter<"Order"> | string
    customerReference?: IntFilter<"Order"> | number
    orderDate?: DateTimeFilter<"Order"> | Date | string
    deliveryDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    deleted?: BoolFilter<"Order"> | boolean
    orderState?: EnumOrderStateFilter<"Order"> | $Enums.OrderState
    selfCollect?: BoolFilter<"Order"> | boolean
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    products?: OrderOnProductsListRelationFilter
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    route?: RoutesOnOrdersListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    orderId?: SortOrder
    customerReference?: SortOrder
    orderDate?: SortOrder
    deliveryDate?: SortOrderInput | SortOrder
    deleted?: SortOrder
    orderState?: SortOrder
    selfCollect?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    products?: OrderOnProductsOrderByRelationAggregateInput
    invoice?: InvoiceOrderByWithRelationInput
    route?: RoutesOnOrdersOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    orderId?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    customerReference?: IntFilter<"Order"> | number
    orderDate?: DateTimeFilter<"Order"> | Date | string
    deliveryDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    deleted?: BoolFilter<"Order"> | boolean
    orderState?: EnumOrderStateFilter<"Order"> | $Enums.OrderState
    selfCollect?: BoolFilter<"Order"> | boolean
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    products?: OrderOnProductsListRelationFilter
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    route?: RoutesOnOrdersListRelationFilter
  }, "orderId">

  export type OrderOrderByWithAggregationInput = {
    orderId?: SortOrder
    customerReference?: SortOrder
    orderDate?: SortOrder
    deliveryDate?: SortOrderInput | SortOrder
    deleted?: SortOrder
    orderState?: SortOrder
    selfCollect?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    orderId?: UuidWithAggregatesFilter<"Order"> | string
    customerReference?: IntWithAggregatesFilter<"Order"> | number
    orderDate?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    deliveryDate?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    deleted?: BoolWithAggregatesFilter<"Order"> | boolean
    orderState?: EnumOrderStateWithAggregatesFilter<"Order"> | $Enums.OrderState
    selfCollect?: BoolWithAggregatesFilter<"Order"> | boolean
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    invoiceId?: UuidFilter<"Invoice"> | string
    orderId?: UuidFilter<"Invoice"> | string
    invoiceAmount?: IntFilter<"Invoice"> | number
    paymentDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    pdfUrl?: StringFilter<"Invoice"> | string
    deleted?: BoolFilter<"Invoice"> | boolean
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }

  export type InvoiceOrderByWithRelationInput = {
    invoiceId?: SortOrder
    orderId?: SortOrder
    invoiceAmount?: SortOrder
    paymentDate?: SortOrderInput | SortOrder
    pdfUrl?: SortOrder
    deleted?: SortOrder
    order?: OrderOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    invoiceId?: string
    orderId?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    invoiceAmount?: IntFilter<"Invoice"> | number
    paymentDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    pdfUrl?: StringFilter<"Invoice"> | string
    deleted?: BoolFilter<"Invoice"> | boolean
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }, "invoiceId" | "orderId">

  export type InvoiceOrderByWithAggregationInput = {
    invoiceId?: SortOrder
    orderId?: SortOrder
    invoiceAmount?: SortOrder
    paymentDate?: SortOrderInput | SortOrder
    pdfUrl?: SortOrder
    deleted?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    invoiceId?: UuidWithAggregatesFilter<"Invoice"> | string
    orderId?: UuidWithAggregatesFilter<"Invoice"> | string
    invoiceAmount?: IntWithAggregatesFilter<"Invoice"> | number
    paymentDate?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    pdfUrl?: StringWithAggregatesFilter<"Invoice"> | string
    deleted?: BoolWithAggregatesFilter<"Invoice"> | boolean
  }

  export type RouteWhereInput = {
    AND?: RouteWhereInput | RouteWhereInput[]
    OR?: RouteWhereInput[]
    NOT?: RouteWhereInput | RouteWhereInput[]
    routeId?: UuidFilter<"Route"> | string
    name?: StringFilter<"Route"> | string
    deleted?: BoolFilter<"Route"> | boolean
    order?: RoutesOnOrdersListRelationFilter
  }

  export type RouteOrderByWithRelationInput = {
    routeId?: SortOrder
    name?: SortOrder
    deleted?: SortOrder
    order?: RoutesOnOrdersOrderByRelationAggregateInput
  }

  export type RouteWhereUniqueInput = Prisma.AtLeast<{
    routeId?: string
    AND?: RouteWhereInput | RouteWhereInput[]
    OR?: RouteWhereInput[]
    NOT?: RouteWhereInput | RouteWhereInput[]
    name?: StringFilter<"Route"> | string
    deleted?: BoolFilter<"Route"> | boolean
    order?: RoutesOnOrdersListRelationFilter
  }, "routeId">

  export type RouteOrderByWithAggregationInput = {
    routeId?: SortOrder
    name?: SortOrder
    deleted?: SortOrder
    _count?: RouteCountOrderByAggregateInput
    _max?: RouteMaxOrderByAggregateInput
    _min?: RouteMinOrderByAggregateInput
  }

  export type RouteScalarWhereWithAggregatesInput = {
    AND?: RouteScalarWhereWithAggregatesInput | RouteScalarWhereWithAggregatesInput[]
    OR?: RouteScalarWhereWithAggregatesInput[]
    NOT?: RouteScalarWhereWithAggregatesInput | RouteScalarWhereWithAggregatesInput[]
    routeId?: UuidWithAggregatesFilter<"Route"> | string
    name?: StringWithAggregatesFilter<"Route"> | string
    deleted?: BoolWithAggregatesFilter<"Route"> | boolean
  }

  export type EmployeesWhereInput = {
    AND?: EmployeesWhereInput | EmployeesWhereInput[]
    OR?: EmployeesWhereInput[]
    NOT?: EmployeesWhereInput | EmployeesWhereInput[]
    employeeId?: UuidFilter<"Employees"> | string
    email?: StringFilter<"Employees"> | string
    password?: StringFilter<"Employees"> | string
    firstName?: StringFilter<"Employees"> | string
    lastName?: StringFilter<"Employees"> | string
    deleted?: BoolFilter<"Employees"> | boolean
    role?: StringFilter<"Employees"> | string
    Role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }

  export type EmployeesOrderByWithRelationInput = {
    employeeId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    deleted?: SortOrder
    role?: SortOrder
    Role?: RoleOrderByWithRelationInput
  }

  export type EmployeesWhereUniqueInput = Prisma.AtLeast<{
    employeeId?: string
    email?: string
    AND?: EmployeesWhereInput | EmployeesWhereInput[]
    OR?: EmployeesWhereInput[]
    NOT?: EmployeesWhereInput | EmployeesWhereInput[]
    password?: StringFilter<"Employees"> | string
    firstName?: StringFilter<"Employees"> | string
    lastName?: StringFilter<"Employees"> | string
    deleted?: BoolFilter<"Employees"> | boolean
    role?: StringFilter<"Employees"> | string
    Role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }, "employeeId" | "email">

  export type EmployeesOrderByWithAggregationInput = {
    employeeId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    deleted?: SortOrder
    role?: SortOrder
    _count?: EmployeesCountOrderByAggregateInput
    _max?: EmployeesMaxOrderByAggregateInput
    _min?: EmployeesMinOrderByAggregateInput
  }

  export type EmployeesScalarWhereWithAggregatesInput = {
    AND?: EmployeesScalarWhereWithAggregatesInput | EmployeesScalarWhereWithAggregatesInput[]
    OR?: EmployeesScalarWhereWithAggregatesInput[]
    NOT?: EmployeesScalarWhereWithAggregatesInput | EmployeesScalarWhereWithAggregatesInput[]
    employeeId?: UuidWithAggregatesFilter<"Employees"> | string
    email?: StringWithAggregatesFilter<"Employees"> | string
    password?: StringWithAggregatesFilter<"Employees"> | string
    firstName?: StringWithAggregatesFilter<"Employees"> | string
    lastName?: StringWithAggregatesFilter<"Employees"> | string
    deleted?: BoolWithAggregatesFilter<"Employees"> | boolean
    role?: StringWithAggregatesFilter<"Employees"> | string
  }

  export type SiteConfigWhereInput = {
    AND?: SiteConfigWhereInput | SiteConfigWhereInput[]
    OR?: SiteConfigWhereInput[]
    NOT?: SiteConfigWhereInput | SiteConfigWhereInput[]
    siteConfigId?: UuidFilter<"SiteConfig"> | string
    companyName?: StringFilter<"SiteConfig"> | string
    logoPath?: StringFilter<"SiteConfig"> | string
    email?: StringFilter<"SiteConfig"> | string
    phoneNumber?: StringFilter<"SiteConfig"> | string
    iban?: StringFilter<"SiteConfig"> | string
    companyNumber?: StringFilter<"SiteConfig"> | string
    addressId?: UuidFilter<"SiteConfig"> | string
    modifiedAt?: DateTimeNullableFilter<"SiteConfig"> | Date | string | null
    isPremium?: BoolFilter<"SiteConfig"> | boolean
    deleted?: BoolFilter<"SiteConfig"> | boolean
    stripeCustomerId?: StringNullableFilter<"SiteConfig"> | string | null
    stripeAccountId?: StringNullableFilter<"SiteConfig"> | string | null
    stripeConfigured?: BoolFilter<"SiteConfig"> | boolean
    address?: XOR<AddressScalarRelationFilter, AddressWhereInput>
  }

  export type SiteConfigOrderByWithRelationInput = {
    siteConfigId?: SortOrder
    companyName?: SortOrder
    logoPath?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    iban?: SortOrder
    companyNumber?: SortOrder
    addressId?: SortOrder
    modifiedAt?: SortOrderInput | SortOrder
    isPremium?: SortOrder
    deleted?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeAccountId?: SortOrderInput | SortOrder
    stripeConfigured?: SortOrder
    address?: AddressOrderByWithRelationInput
  }

  export type SiteConfigWhereUniqueInput = Prisma.AtLeast<{
    siteConfigId?: string
    email?: string
    AND?: SiteConfigWhereInput | SiteConfigWhereInput[]
    OR?: SiteConfigWhereInput[]
    NOT?: SiteConfigWhereInput | SiteConfigWhereInput[]
    companyName?: StringFilter<"SiteConfig"> | string
    logoPath?: StringFilter<"SiteConfig"> | string
    phoneNumber?: StringFilter<"SiteConfig"> | string
    iban?: StringFilter<"SiteConfig"> | string
    companyNumber?: StringFilter<"SiteConfig"> | string
    addressId?: UuidFilter<"SiteConfig"> | string
    modifiedAt?: DateTimeNullableFilter<"SiteConfig"> | Date | string | null
    isPremium?: BoolFilter<"SiteConfig"> | boolean
    deleted?: BoolFilter<"SiteConfig"> | boolean
    stripeCustomerId?: StringNullableFilter<"SiteConfig"> | string | null
    stripeAccountId?: StringNullableFilter<"SiteConfig"> | string | null
    stripeConfigured?: BoolFilter<"SiteConfig"> | boolean
    address?: XOR<AddressScalarRelationFilter, AddressWhereInput>
  }, "siteConfigId" | "email">

  export type SiteConfigOrderByWithAggregationInput = {
    siteConfigId?: SortOrder
    companyName?: SortOrder
    logoPath?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    iban?: SortOrder
    companyNumber?: SortOrder
    addressId?: SortOrder
    modifiedAt?: SortOrderInput | SortOrder
    isPremium?: SortOrder
    deleted?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeAccountId?: SortOrderInput | SortOrder
    stripeConfigured?: SortOrder
    _count?: SiteConfigCountOrderByAggregateInput
    _max?: SiteConfigMaxOrderByAggregateInput
    _min?: SiteConfigMinOrderByAggregateInput
  }

  export type SiteConfigScalarWhereWithAggregatesInput = {
    AND?: SiteConfigScalarWhereWithAggregatesInput | SiteConfigScalarWhereWithAggregatesInput[]
    OR?: SiteConfigScalarWhereWithAggregatesInput[]
    NOT?: SiteConfigScalarWhereWithAggregatesInput | SiteConfigScalarWhereWithAggregatesInput[]
    siteConfigId?: UuidWithAggregatesFilter<"SiteConfig"> | string
    companyName?: StringWithAggregatesFilter<"SiteConfig"> | string
    logoPath?: StringWithAggregatesFilter<"SiteConfig"> | string
    email?: StringWithAggregatesFilter<"SiteConfig"> | string
    phoneNumber?: StringWithAggregatesFilter<"SiteConfig"> | string
    iban?: StringWithAggregatesFilter<"SiteConfig"> | string
    companyNumber?: StringWithAggregatesFilter<"SiteConfig"> | string
    addressId?: UuidWithAggregatesFilter<"SiteConfig"> | string
    modifiedAt?: DateTimeNullableWithAggregatesFilter<"SiteConfig"> | Date | string | null
    isPremium?: BoolWithAggregatesFilter<"SiteConfig"> | boolean
    deleted?: BoolWithAggregatesFilter<"SiteConfig"> | boolean
    stripeCustomerId?: StringNullableWithAggregatesFilter<"SiteConfig"> | string | null
    stripeAccountId?: StringNullableWithAggregatesFilter<"SiteConfig"> | string | null
    stripeConfigured?: BoolWithAggregatesFilter<"SiteConfig"> | boolean
  }

  export type ActionWhereInput = {
    AND?: ActionWhereInput | ActionWhereInput[]
    OR?: ActionWhereInput[]
    NOT?: ActionWhereInput | ActionWhereInput[]
    name?: EnumActionsFilter<"Action"> | $Enums.Actions
    description?: StringNullableFilter<"Action"> | string | null
    deleted?: BoolFilter<"Action"> | boolean
    resourceLinks?: ResourceActionListRelationFilter
  }

  export type ActionOrderByWithRelationInput = {
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    deleted?: SortOrder
    resourceLinks?: ResourceActionOrderByRelationAggregateInput
  }

  export type ActionWhereUniqueInput = Prisma.AtLeast<{
    name?: $Enums.Actions
    AND?: ActionWhereInput | ActionWhereInput[]
    OR?: ActionWhereInput[]
    NOT?: ActionWhereInput | ActionWhereInput[]
    description?: StringNullableFilter<"Action"> | string | null
    deleted?: BoolFilter<"Action"> | boolean
    resourceLinks?: ResourceActionListRelationFilter
  }, "name">

  export type ActionOrderByWithAggregationInput = {
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    deleted?: SortOrder
    _count?: ActionCountOrderByAggregateInput
    _max?: ActionMaxOrderByAggregateInput
    _min?: ActionMinOrderByAggregateInput
  }

  export type ActionScalarWhereWithAggregatesInput = {
    AND?: ActionScalarWhereWithAggregatesInput | ActionScalarWhereWithAggregatesInput[]
    OR?: ActionScalarWhereWithAggregatesInput[]
    NOT?: ActionScalarWhereWithAggregatesInput | ActionScalarWhereWithAggregatesInput[]
    name?: EnumActionsWithAggregatesFilter<"Action"> | $Enums.Actions
    description?: StringNullableWithAggregatesFilter<"Action"> | string | null
    deleted?: BoolWithAggregatesFilter<"Action"> | boolean
  }

  export type RessourceWhereInput = {
    AND?: RessourceWhereInput | RessourceWhereInput[]
    OR?: RessourceWhereInput[]
    NOT?: RessourceWhereInput | RessourceWhereInput[]
    name?: EnumRessourcesFilter<"Ressource"> | $Enums.Ressources
    description?: StringNullableFilter<"Ressource"> | string | null
    deleted?: BoolFilter<"Ressource"> | boolean
    actionLinks?: ResourceActionListRelationFilter
  }

  export type RessourceOrderByWithRelationInput = {
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    deleted?: SortOrder
    actionLinks?: ResourceActionOrderByRelationAggregateInput
  }

  export type RessourceWhereUniqueInput = Prisma.AtLeast<{
    name?: $Enums.Ressources
    AND?: RessourceWhereInput | RessourceWhereInput[]
    OR?: RessourceWhereInput[]
    NOT?: RessourceWhereInput | RessourceWhereInput[]
    description?: StringNullableFilter<"Ressource"> | string | null
    deleted?: BoolFilter<"Ressource"> | boolean
    actionLinks?: ResourceActionListRelationFilter
  }, "name">

  export type RessourceOrderByWithAggregationInput = {
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    deleted?: SortOrder
    _count?: RessourceCountOrderByAggregateInput
    _max?: RessourceMaxOrderByAggregateInput
    _min?: RessourceMinOrderByAggregateInput
  }

  export type RessourceScalarWhereWithAggregatesInput = {
    AND?: RessourceScalarWhereWithAggregatesInput | RessourceScalarWhereWithAggregatesInput[]
    OR?: RessourceScalarWhereWithAggregatesInput[]
    NOT?: RessourceScalarWhereWithAggregatesInput | RessourceScalarWhereWithAggregatesInput[]
    name?: EnumRessourcesWithAggregatesFilter<"Ressource"> | $Enums.Ressources
    description?: StringNullableWithAggregatesFilter<"Ressource"> | string | null
    deleted?: BoolWithAggregatesFilter<"Ressource"> | boolean
  }

  export type ResourceActionWhereInput = {
    AND?: ResourceActionWhereInput | ResourceActionWhereInput[]
    OR?: ResourceActionWhereInput[]
    NOT?: ResourceActionWhereInput | ResourceActionWhereInput[]
    action?: EnumActionsFilter<"ResourceAction"> | $Enums.Actions
    resource?: EnumRessourcesFilter<"ResourceAction"> | $Enums.Ressources
    Action?: XOR<ActionScalarRelationFilter, ActionWhereInput>
    Ressource?: XOR<RessourceScalarRelationFilter, RessourceWhereInput>
    permissions?: PermissionListRelationFilter
  }

  export type ResourceActionOrderByWithRelationInput = {
    action?: SortOrder
    resource?: SortOrder
    Action?: ActionOrderByWithRelationInput
    Ressource?: RessourceOrderByWithRelationInput
    permissions?: PermissionOrderByRelationAggregateInput
  }

  export type ResourceActionWhereUniqueInput = Prisma.AtLeast<{
    action_resource?: ResourceActionActionResourceCompoundUniqueInput
    AND?: ResourceActionWhereInput | ResourceActionWhereInput[]
    OR?: ResourceActionWhereInput[]
    NOT?: ResourceActionWhereInput | ResourceActionWhereInput[]
    action?: EnumActionsFilter<"ResourceAction"> | $Enums.Actions
    resource?: EnumRessourcesFilter<"ResourceAction"> | $Enums.Ressources
    Action?: XOR<ActionScalarRelationFilter, ActionWhereInput>
    Ressource?: XOR<RessourceScalarRelationFilter, RessourceWhereInput>
    permissions?: PermissionListRelationFilter
  }, "action_resource" | "action_resource">

  export type ResourceActionOrderByWithAggregationInput = {
    action?: SortOrder
    resource?: SortOrder
    _count?: ResourceActionCountOrderByAggregateInput
    _max?: ResourceActionMaxOrderByAggregateInput
    _min?: ResourceActionMinOrderByAggregateInput
  }

  export type ResourceActionScalarWhereWithAggregatesInput = {
    AND?: ResourceActionScalarWhereWithAggregatesInput | ResourceActionScalarWhereWithAggregatesInput[]
    OR?: ResourceActionScalarWhereWithAggregatesInput[]
    NOT?: ResourceActionScalarWhereWithAggregatesInput | ResourceActionScalarWhereWithAggregatesInput[]
    action?: EnumActionsWithAggregatesFilter<"ResourceAction"> | $Enums.Actions
    resource?: EnumRessourcesWithAggregatesFilter<"ResourceAction"> | $Enums.Ressources
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    deleted?: BoolFilter<"Role"> | boolean
    employees?: EmployeesListRelationFilter
    permissions?: PermissionListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    deleted?: SortOrder
    employees?: EmployeesOrderByRelationAggregateInput
    permissions?: PermissionOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    deleted?: BoolFilter<"Role"> | boolean
    employees?: EmployeesListRelationFilter
    permissions?: PermissionListRelationFilter
  }, "name" | "name">

  export type RoleOrderByWithAggregationInput = {
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    deleted?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    deleted?: BoolWithAggregatesFilter<"Role"> | boolean
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: UuidFilter<"Permission"> | string
    role?: StringFilter<"Permission"> | string
    action?: EnumActionsFilter<"Permission"> | $Enums.Actions
    resource?: EnumRessourcesFilter<"Permission"> | $Enums.Ressources
    allowed?: BoolFilter<"Permission"> | boolean
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    Role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    resourceAction?: XOR<ResourceActionScalarRelationFilter, ResourceActionWhereInput>
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    allowed?: SortOrder
    createdAt?: SortOrder
    Role?: RoleOrderByWithRelationInput
    resourceAction?: ResourceActionOrderByWithRelationInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    role_action_resource?: PermissionRoleActionResourceCompoundUniqueInput
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    role?: StringFilter<"Permission"> | string
    action?: EnumActionsFilter<"Permission"> | $Enums.Actions
    resource?: EnumRessourcesFilter<"Permission"> | $Enums.Ressources
    allowed?: BoolFilter<"Permission"> | boolean
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    Role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    resourceAction?: XOR<ResourceActionScalarRelationFilter, ResourceActionWhereInput>
  }, "id" | "role_action_resource">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    allowed?: SortOrder
    createdAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Permission"> | string
    role?: StringWithAggregatesFilter<"Permission"> | string
    action?: EnumActionsWithAggregatesFilter<"Permission"> | $Enums.Actions
    resource?: EnumRessourcesWithAggregatesFilter<"Permission"> | $Enums.Ressources
    allowed?: BoolWithAggregatesFilter<"Permission"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type CartOnProductsWhereInput = {
    AND?: CartOnProductsWhereInput | CartOnProductsWhereInput[]
    OR?: CartOnProductsWhereInput[]
    NOT?: CartOnProductsWhereInput | CartOnProductsWhereInput[]
    cartId?: UuidFilter<"CartOnProducts"> | string
    productId?: UuidFilter<"CartOnProducts"> | string
    quantity?: IntFilter<"CartOnProducts"> | number
    cart?: XOR<CartScalarRelationFilter, CartWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type CartOnProductsOrderByWithRelationInput = {
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    cart?: CartOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type CartOnProductsWhereUniqueInput = Prisma.AtLeast<{
    cartId_productId?: CartOnProductsCartIdProductIdCompoundUniqueInput
    AND?: CartOnProductsWhereInput | CartOnProductsWhereInput[]
    OR?: CartOnProductsWhereInput[]
    NOT?: CartOnProductsWhereInput | CartOnProductsWhereInput[]
    cartId?: UuidFilter<"CartOnProducts"> | string
    productId?: UuidFilter<"CartOnProducts"> | string
    quantity?: IntFilter<"CartOnProducts"> | number
    cart?: XOR<CartScalarRelationFilter, CartWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "cartId_productId">

  export type CartOnProductsOrderByWithAggregationInput = {
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    _count?: CartOnProductsCountOrderByAggregateInput
    _avg?: CartOnProductsAvgOrderByAggregateInput
    _max?: CartOnProductsMaxOrderByAggregateInput
    _min?: CartOnProductsMinOrderByAggregateInput
    _sum?: CartOnProductsSumOrderByAggregateInput
  }

  export type CartOnProductsScalarWhereWithAggregatesInput = {
    AND?: CartOnProductsScalarWhereWithAggregatesInput | CartOnProductsScalarWhereWithAggregatesInput[]
    OR?: CartOnProductsScalarWhereWithAggregatesInput[]
    NOT?: CartOnProductsScalarWhereWithAggregatesInput | CartOnProductsScalarWhereWithAggregatesInput[]
    cartId?: UuidWithAggregatesFilter<"CartOnProducts"> | string
    productId?: UuidWithAggregatesFilter<"CartOnProducts"> | string
    quantity?: IntWithAggregatesFilter<"CartOnProducts"> | number
  }

  export type OrderOnProductsWhereInput = {
    AND?: OrderOnProductsWhereInput | OrderOnProductsWhereInput[]
    OR?: OrderOnProductsWhereInput[]
    NOT?: OrderOnProductsWhereInput | OrderOnProductsWhereInput[]
    orderId?: UuidFilter<"OrderOnProducts"> | string
    productId?: UuidFilter<"OrderOnProducts"> | string
    orderDate?: DateTimeFilter<"OrderOnProducts"> | Date | string
    productAmount?: IntFilter<"OrderOnProducts"> | number
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type OrderOnProductsOrderByWithRelationInput = {
    orderId?: SortOrder
    productId?: SortOrder
    orderDate?: SortOrder
    productAmount?: SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type OrderOnProductsWhereUniqueInput = Prisma.AtLeast<{
    orderId_productId?: OrderOnProductsOrderIdProductIdCompoundUniqueInput
    AND?: OrderOnProductsWhereInput | OrderOnProductsWhereInput[]
    OR?: OrderOnProductsWhereInput[]
    NOT?: OrderOnProductsWhereInput | OrderOnProductsWhereInput[]
    orderId?: UuidFilter<"OrderOnProducts"> | string
    productId?: UuidFilter<"OrderOnProducts"> | string
    orderDate?: DateTimeFilter<"OrderOnProducts"> | Date | string
    productAmount?: IntFilter<"OrderOnProducts"> | number
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "orderId_productId">

  export type OrderOnProductsOrderByWithAggregationInput = {
    orderId?: SortOrder
    productId?: SortOrder
    orderDate?: SortOrder
    productAmount?: SortOrder
    _count?: OrderOnProductsCountOrderByAggregateInput
    _avg?: OrderOnProductsAvgOrderByAggregateInput
    _max?: OrderOnProductsMaxOrderByAggregateInput
    _min?: OrderOnProductsMinOrderByAggregateInput
    _sum?: OrderOnProductsSumOrderByAggregateInput
  }

  export type OrderOnProductsScalarWhereWithAggregatesInput = {
    AND?: OrderOnProductsScalarWhereWithAggregatesInput | OrderOnProductsScalarWhereWithAggregatesInput[]
    OR?: OrderOnProductsScalarWhereWithAggregatesInput[]
    NOT?: OrderOnProductsScalarWhereWithAggregatesInput | OrderOnProductsScalarWhereWithAggregatesInput[]
    orderId?: UuidWithAggregatesFilter<"OrderOnProducts"> | string
    productId?: UuidWithAggregatesFilter<"OrderOnProducts"> | string
    orderDate?: DateTimeWithAggregatesFilter<"OrderOnProducts"> | Date | string
    productAmount?: IntWithAggregatesFilter<"OrderOnProducts"> | number
  }

  export type RoutesOnOrdersWhereInput = {
    AND?: RoutesOnOrdersWhereInput | RoutesOnOrdersWhereInput[]
    OR?: RoutesOnOrdersWhereInput[]
    NOT?: RoutesOnOrdersWhereInput | RoutesOnOrdersWhereInput[]
    routeId?: UuidFilter<"RoutesOnOrders"> | string
    orderId?: UuidFilter<"RoutesOnOrders"> | string
    route?: XOR<RouteScalarRelationFilter, RouteWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }

  export type RoutesOnOrdersOrderByWithRelationInput = {
    routeId?: SortOrder
    orderId?: SortOrder
    route?: RouteOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
  }

  export type RoutesOnOrdersWhereUniqueInput = Prisma.AtLeast<{
    routeId_orderId?: RoutesOnOrdersRouteIdOrderIdCompoundUniqueInput
    AND?: RoutesOnOrdersWhereInput | RoutesOnOrdersWhereInput[]
    OR?: RoutesOnOrdersWhereInput[]
    NOT?: RoutesOnOrdersWhereInput | RoutesOnOrdersWhereInput[]
    routeId?: UuidFilter<"RoutesOnOrders"> | string
    orderId?: UuidFilter<"RoutesOnOrders"> | string
    route?: XOR<RouteScalarRelationFilter, RouteWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }, "routeId_orderId">

  export type RoutesOnOrdersOrderByWithAggregationInput = {
    routeId?: SortOrder
    orderId?: SortOrder
    _count?: RoutesOnOrdersCountOrderByAggregateInput
    _max?: RoutesOnOrdersMaxOrderByAggregateInput
    _min?: RoutesOnOrdersMinOrderByAggregateInput
  }

  export type RoutesOnOrdersScalarWhereWithAggregatesInput = {
    AND?: RoutesOnOrdersScalarWhereWithAggregatesInput | RoutesOnOrdersScalarWhereWithAggregatesInput[]
    OR?: RoutesOnOrdersScalarWhereWithAggregatesInput[]
    NOT?: RoutesOnOrdersScalarWhereWithAggregatesInput | RoutesOnOrdersScalarWhereWithAggregatesInput[]
    routeId?: UuidWithAggregatesFilter<"RoutesOnOrders"> | string
    orderId?: UuidWithAggregatesFilter<"RoutesOnOrders"> | string
  }

  export type CustomerCreateInput = {
    customerId?: string
    customerReference: number
    email: string
    phoneNumber: string
    password: string
    firstName?: string | null
    lastName: string
    companyNumber?: string | null
    modifiedAt?: Date | string | null
    deleted?: boolean
    signedUp?: Date | string
    avatarPath?: string | null
    businessSector?: $Enums.BusinessSector | null
    address: AddressCreateNestedOneWithoutCustomersInput
    cart?: CartCreateNestedOneWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    history?: CustomerHistoryCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    customerId?: string
    customerReference: number
    email: string
    phoneNumber: string
    password: string
    firstName?: string | null
    lastName: string
    companyNumber?: string | null
    modifiedAt?: Date | string | null
    deleted?: boolean
    signedUp?: Date | string
    avatarPath?: string | null
    addressId: string
    businessSector?: $Enums.BusinessSector | null
    cart?: CartUncheckedCreateNestedOneWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    history?: CustomerHistoryUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    customerReference?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    signedUp?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    businessSector?: NullableEnumBusinessSectorFieldUpdateOperationsInput | $Enums.BusinessSector | null
    address?: AddressUpdateOneRequiredWithoutCustomersNestedInput
    cart?: CartUpdateOneWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    history?: CustomerHistoryUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    customerReference?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    signedUp?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: StringFieldUpdateOperationsInput | string
    businessSector?: NullableEnumBusinessSectorFieldUpdateOperationsInput | $Enums.BusinessSector | null
    cart?: CartUncheckedUpdateOneWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    history?: CustomerHistoryUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    customerId?: string
    customerReference: number
    email: string
    phoneNumber: string
    password: string
    firstName?: string | null
    lastName: string
    companyNumber?: string | null
    modifiedAt?: Date | string | null
    deleted?: boolean
    signedUp?: Date | string
    avatarPath?: string | null
    addressId: string
    businessSector?: $Enums.BusinessSector | null
  }

  export type CustomerUpdateManyMutationInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    customerReference?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    signedUp?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    businessSector?: NullableEnumBusinessSectorFieldUpdateOperationsInput | $Enums.BusinessSector | null
  }

  export type CustomerUncheckedUpdateManyInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    customerReference?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    signedUp?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: StringFieldUpdateOperationsInput | string
    businessSector?: NullableEnumBusinessSectorFieldUpdateOperationsInput | $Enums.BusinessSector | null
  }

  export type CustomerHistoryCreateInput = {
    historyId?: string
    email: string
    phoneNumber: string
    password: string
    firstName?: string | null
    lastName: string
    companyNumber?: string | null
    modifiedAt?: Date | string | null
    deleted?: boolean
    signedUp?: Date | string
    avatarPath?: string | null
    addressId: string
    businessSector?: $Enums.BusinessSector | null
    customer: CustomerCreateNestedOneWithoutHistoryInput
  }

  export type CustomerHistoryUncheckedCreateInput = {
    historyId?: string
    customerReference: number
    email: string
    phoneNumber: string
    password: string
    firstName?: string | null
    lastName: string
    companyNumber?: string | null
    modifiedAt?: Date | string | null
    deleted?: boolean
    signedUp?: Date | string
    avatarPath?: string | null
    addressId: string
    businessSector?: $Enums.BusinessSector | null
  }

  export type CustomerHistoryUpdateInput = {
    historyId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    signedUp?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: StringFieldUpdateOperationsInput | string
    businessSector?: NullableEnumBusinessSectorFieldUpdateOperationsInput | $Enums.BusinessSector | null
    customer?: CustomerUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type CustomerHistoryUncheckedUpdateInput = {
    historyId?: StringFieldUpdateOperationsInput | string
    customerReference?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    signedUp?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: StringFieldUpdateOperationsInput | string
    businessSector?: NullableEnumBusinessSectorFieldUpdateOperationsInput | $Enums.BusinessSector | null
  }

  export type CustomerHistoryCreateManyInput = {
    historyId?: string
    customerReference: number
    email: string
    phoneNumber: string
    password: string
    firstName?: string | null
    lastName: string
    companyNumber?: string | null
    modifiedAt?: Date | string | null
    deleted?: boolean
    signedUp?: Date | string
    avatarPath?: string | null
    addressId: string
    businessSector?: $Enums.BusinessSector | null
  }

  export type CustomerHistoryUpdateManyMutationInput = {
    historyId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    signedUp?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: StringFieldUpdateOperationsInput | string
    businessSector?: NullableEnumBusinessSectorFieldUpdateOperationsInput | $Enums.BusinessSector | null
  }

  export type CustomerHistoryUncheckedUpdateManyInput = {
    historyId?: StringFieldUpdateOperationsInput | string
    customerReference?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    signedUp?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: StringFieldUpdateOperationsInput | string
    businessSector?: NullableEnumBusinessSectorFieldUpdateOperationsInput | $Enums.BusinessSector | null
  }

  export type CartCreateInput = {
    cartId?: string
    customer?: CustomerCreateNestedOneWithoutCartInput
    products?: CartOnProductsCreateNestedManyWithoutCartInput
  }

  export type CartUncheckedCreateInput = {
    cartId?: string
    customerReference?: number | null
    products?: CartOnProductsUncheckedCreateNestedManyWithoutCartInput
  }

  export type CartUpdateInput = {
    cartId?: StringFieldUpdateOperationsInput | string
    customer?: CustomerUpdateOneWithoutCartNestedInput
    products?: CartOnProductsUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateInput = {
    cartId?: StringFieldUpdateOperationsInput | string
    customerReference?: NullableIntFieldUpdateOperationsInput | number | null
    products?: CartOnProductsUncheckedUpdateManyWithoutCartNestedInput
  }

  export type CartCreateManyInput = {
    cartId?: string
    customerReference?: number | null
  }

  export type CartUpdateManyMutationInput = {
    cartId?: StringFieldUpdateOperationsInput | string
  }

  export type CartUncheckedUpdateManyInput = {
    cartId?: StringFieldUpdateOperationsInput | string
    customerReference?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AddressCreateInput = {
    addressId?: string
    city: string
    country: string
    postCode: string
    state: string
    streetName: string
    streetNumber: string
    modifiedAt?: Date | string | null
    deleted?: boolean
    customers?: CustomerCreateNestedManyWithoutAddressInput
    siteConfig?: SiteConfigCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    addressId?: string
    city: string
    country: string
    postCode: string
    state: string
    streetName: string
    streetNumber: string
    modifiedAt?: Date | string | null
    deleted?: boolean
    customers?: CustomerUncheckedCreateNestedManyWithoutAddressInput
    siteConfig?: SiteConfigUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressUpdateInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    streetName?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    customers?: CustomerUpdateManyWithoutAddressNestedInput
    siteConfig?: SiteConfigUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    streetName?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    customers?: CustomerUncheckedUpdateManyWithoutAddressNestedInput
    siteConfig?: SiteConfigUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AddressCreateManyInput = {
    addressId?: string
    city: string
    country: string
    postCode: string
    state: string
    streetName: string
    streetNumber: string
    modifiedAt?: Date | string | null
    deleted?: boolean
  }

  export type AddressUpdateManyMutationInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    streetName?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AddressUncheckedUpdateManyInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    streetName?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductCreateInput = {
    productId?: string
    name: string
    price: number
    description: string
    stock: number
    imagePath?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string | null
    deleted?: boolean
    category: CategoryCreateNestedOneWithoutProductsInput
    carts?: CartOnProductsCreateNestedManyWithoutProductInput
    orders?: OrderOnProductsCreateNestedManyWithoutProductInput
    ProductHistory?: ProductHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    productId?: string
    name: string
    price: number
    description: string
    stock: number
    imagePath?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string | null
    deleted?: boolean
    categoryId: string
    carts?: CartOnProductsUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderOnProductsUncheckedCreateNestedManyWithoutProductInput
    ProductHistory?: ProductHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    carts?: CartOnProductsUpdateManyWithoutProductNestedInput
    orders?: OrderOnProductsUpdateManyWithoutProductNestedInput
    ProductHistory?: ProductHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: StringFieldUpdateOperationsInput | string
    carts?: CartOnProductsUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderOnProductsUncheckedUpdateManyWithoutProductNestedInput
    ProductHistory?: ProductHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    productId?: string
    name: string
    price: number
    description: string
    stock: number
    imagePath?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string | null
    deleted?: boolean
    categoryId: string
  }

  export type ProductUpdateManyMutationInput = {
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductUncheckedUpdateManyInput = {
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductHistoryCreateInput = {
    historyId?: string
    name: string
    price: number
    description: string
    stock: number
    imagePath?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string | null
    deleted?: boolean
    category: CategoryCreateNestedOneWithoutProductHistoryInput
    product: ProductCreateNestedOneWithoutProductHistoryInput
  }

  export type ProductHistoryUncheckedCreateInput = {
    historyId?: string
    productId: string
    name: string
    price: number
    description: string
    stock: number
    imagePath?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string | null
    deleted?: boolean
    categoryId: string
  }

  export type ProductHistoryUpdateInput = {
    historyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    category?: CategoryUpdateOneRequiredWithoutProductHistoryNestedInput
    product?: ProductUpdateOneRequiredWithoutProductHistoryNestedInput
  }

  export type ProductHistoryUncheckedUpdateInput = {
    historyId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductHistoryCreateManyInput = {
    historyId?: string
    productId: string
    name: string
    price: number
    description: string
    stock: number
    imagePath?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string | null
    deleted?: boolean
    categoryId: string
  }

  export type ProductHistoryUpdateManyMutationInput = {
    historyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductHistoryUncheckedUpdateManyInput = {
    historyId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryCreateInput = {
    categoryId?: string
    name: string
    imagePath?: string | null
    deleted?: boolean
    products?: ProductCreateNestedManyWithoutCategoryInput
    ProductHistory?: ProductHistoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    categoryId?: string
    name: string
    imagePath?: string | null
    deleted?: boolean
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
    ProductHistory?: ProductHistoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductUpdateManyWithoutCategoryNestedInput
    ProductHistory?: ProductHistoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
    ProductHistory?: ProductHistoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    categoryId?: string
    name: string
    imagePath?: string | null
    deleted?: boolean
  }

  export type CategoryUpdateManyMutationInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CategoryUncheckedUpdateManyInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrderCreateInput = {
    orderId?: string
    orderDate?: Date | string
    deliveryDate?: Date | string | null
    deleted?: boolean
    orderState?: $Enums.OrderState
    selfCollect?: boolean
    customer: CustomerCreateNestedOneWithoutOrdersInput
    products?: OrderOnProductsCreateNestedManyWithoutOrderInput
    invoice?: InvoiceCreateNestedOneWithoutOrderInput
    route?: RoutesOnOrdersCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    orderId?: string
    customerReference: number
    orderDate?: Date | string
    deliveryDate?: Date | string | null
    deleted?: boolean
    orderState?: $Enums.OrderState
    selfCollect?: boolean
    products?: OrderOnProductsUncheckedCreateNestedManyWithoutOrderInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutOrderInput
    route?: RoutesOnOrdersUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    orderId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    orderState?: EnumOrderStateFieldUpdateOperationsInput | $Enums.OrderState
    selfCollect?: BoolFieldUpdateOperationsInput | boolean
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    products?: OrderOnProductsUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUpdateOneWithoutOrderNestedInput
    route?: RoutesOnOrdersUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    orderId?: StringFieldUpdateOperationsInput | string
    customerReference?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    orderState?: EnumOrderStateFieldUpdateOperationsInput | $Enums.OrderState
    selfCollect?: BoolFieldUpdateOperationsInput | boolean
    products?: OrderOnProductsUncheckedUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutOrderNestedInput
    route?: RoutesOnOrdersUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    orderId?: string
    customerReference: number
    orderDate?: Date | string
    deliveryDate?: Date | string | null
    deleted?: boolean
    orderState?: $Enums.OrderState
    selfCollect?: boolean
  }

  export type OrderUpdateManyMutationInput = {
    orderId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    orderState?: EnumOrderStateFieldUpdateOperationsInput | $Enums.OrderState
    selfCollect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrderUncheckedUpdateManyInput = {
    orderId?: StringFieldUpdateOperationsInput | string
    customerReference?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    orderState?: EnumOrderStateFieldUpdateOperationsInput | $Enums.OrderState
    selfCollect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceCreateInput = {
    invoiceId?: string
    invoiceAmount: number
    paymentDate?: Date | string | null
    pdfUrl: string
    deleted?: boolean
    order: OrderCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    invoiceId?: string
    orderId: string
    invoiceAmount: number
    paymentDate?: Date | string | null
    pdfUrl: string
    deleted?: boolean
  }

  export type InvoiceUpdateInput = {
    invoiceId?: StringFieldUpdateOperationsInput | string
    invoiceAmount?: IntFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pdfUrl?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    order?: OrderUpdateOneRequiredWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    invoiceId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    invoiceAmount?: IntFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pdfUrl?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceCreateManyInput = {
    invoiceId?: string
    orderId: string
    invoiceAmount: number
    paymentDate?: Date | string | null
    pdfUrl: string
    deleted?: boolean
  }

  export type InvoiceUpdateManyMutationInput = {
    invoiceId?: StringFieldUpdateOperationsInput | string
    invoiceAmount?: IntFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pdfUrl?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceUncheckedUpdateManyInput = {
    invoiceId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    invoiceAmount?: IntFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pdfUrl?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RouteCreateInput = {
    routeId?: string
    name: string
    deleted?: boolean
    order?: RoutesOnOrdersCreateNestedManyWithoutRouteInput
  }

  export type RouteUncheckedCreateInput = {
    routeId?: string
    name: string
    deleted?: boolean
    order?: RoutesOnOrdersUncheckedCreateNestedManyWithoutRouteInput
  }

  export type RouteUpdateInput = {
    routeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    order?: RoutesOnOrdersUpdateManyWithoutRouteNestedInput
  }

  export type RouteUncheckedUpdateInput = {
    routeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    order?: RoutesOnOrdersUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type RouteCreateManyInput = {
    routeId?: string
    name: string
    deleted?: boolean
  }

  export type RouteUpdateManyMutationInput = {
    routeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RouteUncheckedUpdateManyInput = {
    routeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmployeesCreateInput = {
    employeeId?: string
    email: string
    password: string
    firstName: string
    lastName: string
    deleted?: boolean
    Role: RoleCreateNestedOneWithoutEmployeesInput
  }

  export type EmployeesUncheckedCreateInput = {
    employeeId?: string
    email: string
    password: string
    firstName: string
    lastName: string
    deleted?: boolean
    role: string
  }

  export type EmployeesUpdateInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    Role?: RoleUpdateOneRequiredWithoutEmployeesNestedInput
  }

  export type EmployeesUncheckedUpdateInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeesCreateManyInput = {
    employeeId?: string
    email: string
    password: string
    firstName: string
    lastName: string
    deleted?: boolean
    role: string
  }

  export type EmployeesUpdateManyMutationInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmployeesUncheckedUpdateManyInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
  }

  export type SiteConfigCreateInput = {
    siteConfigId?: string
    companyName: string
    logoPath: string
    email: string
    phoneNumber: string
    iban: string
    companyNumber: string
    modifiedAt?: Date | string | null
    isPremium?: boolean
    deleted?: boolean
    stripeCustomerId?: string | null
    stripeAccountId?: string | null
    stripeConfigured?: boolean
    address: AddressCreateNestedOneWithoutSiteConfigInput
  }

  export type SiteConfigUncheckedCreateInput = {
    siteConfigId?: string
    companyName: string
    logoPath: string
    email: string
    phoneNumber: string
    iban: string
    companyNumber: string
    addressId: string
    modifiedAt?: Date | string | null
    isPremium?: boolean
    deleted?: boolean
    stripeCustomerId?: string | null
    stripeAccountId?: string | null
    stripeConfigured?: boolean
  }

  export type SiteConfigUpdateInput = {
    siteConfigId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    logoPath?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    iban?: StringFieldUpdateOperationsInput | string
    companyNumber?: StringFieldUpdateOperationsInput | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConfigured?: BoolFieldUpdateOperationsInput | boolean
    address?: AddressUpdateOneRequiredWithoutSiteConfigNestedInput
  }

  export type SiteConfigUncheckedUpdateInput = {
    siteConfigId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    logoPath?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    iban?: StringFieldUpdateOperationsInput | string
    companyNumber?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConfigured?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SiteConfigCreateManyInput = {
    siteConfigId?: string
    companyName: string
    logoPath: string
    email: string
    phoneNumber: string
    iban: string
    companyNumber: string
    addressId: string
    modifiedAt?: Date | string | null
    isPremium?: boolean
    deleted?: boolean
    stripeCustomerId?: string | null
    stripeAccountId?: string | null
    stripeConfigured?: boolean
  }

  export type SiteConfigUpdateManyMutationInput = {
    siteConfigId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    logoPath?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    iban?: StringFieldUpdateOperationsInput | string
    companyNumber?: StringFieldUpdateOperationsInput | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConfigured?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SiteConfigUncheckedUpdateManyInput = {
    siteConfigId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    logoPath?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    iban?: StringFieldUpdateOperationsInput | string
    companyNumber?: StringFieldUpdateOperationsInput | string
    addressId?: StringFieldUpdateOperationsInput | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConfigured?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ActionCreateInput = {
    name: $Enums.Actions
    description?: string | null
    deleted?: boolean
    resourceLinks?: ResourceActionCreateNestedManyWithoutActionInput
  }

  export type ActionUncheckedCreateInput = {
    name: $Enums.Actions
    description?: string | null
    deleted?: boolean
    resourceLinks?: ResourceActionUncheckedCreateNestedManyWithoutActionInput
  }

  export type ActionUpdateInput = {
    name?: EnumActionsFieldUpdateOperationsInput | $Enums.Actions
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    resourceLinks?: ResourceActionUpdateManyWithoutActionNestedInput
  }

  export type ActionUncheckedUpdateInput = {
    name?: EnumActionsFieldUpdateOperationsInput | $Enums.Actions
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    resourceLinks?: ResourceActionUncheckedUpdateManyWithoutActionNestedInput
  }

  export type ActionCreateManyInput = {
    name: $Enums.Actions
    description?: string | null
    deleted?: boolean
  }

  export type ActionUpdateManyMutationInput = {
    name?: EnumActionsFieldUpdateOperationsInput | $Enums.Actions
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ActionUncheckedUpdateManyInput = {
    name?: EnumActionsFieldUpdateOperationsInput | $Enums.Actions
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RessourceCreateInput = {
    name: $Enums.Ressources
    description?: string | null
    deleted?: boolean
    actionLinks?: ResourceActionCreateNestedManyWithoutRessourceInput
  }

  export type RessourceUncheckedCreateInput = {
    name: $Enums.Ressources
    description?: string | null
    deleted?: boolean
    actionLinks?: ResourceActionUncheckedCreateNestedManyWithoutRessourceInput
  }

  export type RessourceUpdateInput = {
    name?: EnumRessourcesFieldUpdateOperationsInput | $Enums.Ressources
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    actionLinks?: ResourceActionUpdateManyWithoutRessourceNestedInput
  }

  export type RessourceUncheckedUpdateInput = {
    name?: EnumRessourcesFieldUpdateOperationsInput | $Enums.Ressources
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    actionLinks?: ResourceActionUncheckedUpdateManyWithoutRessourceNestedInput
  }

  export type RessourceCreateManyInput = {
    name: $Enums.Ressources
    description?: string | null
    deleted?: boolean
  }

  export type RessourceUpdateManyMutationInput = {
    name?: EnumRessourcesFieldUpdateOperationsInput | $Enums.Ressources
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RessourceUncheckedUpdateManyInput = {
    name?: EnumRessourcesFieldUpdateOperationsInput | $Enums.Ressources
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResourceActionCreateInput = {
    Action: ActionCreateNestedOneWithoutResourceLinksInput
    Ressource: RessourceCreateNestedOneWithoutActionLinksInput
    permissions?: PermissionCreateNestedManyWithoutResourceActionInput
  }

  export type ResourceActionUncheckedCreateInput = {
    action: $Enums.Actions
    resource: $Enums.Ressources
    permissions?: PermissionUncheckedCreateNestedManyWithoutResourceActionInput
  }

  export type ResourceActionUpdateInput = {
    Action?: ActionUpdateOneRequiredWithoutResourceLinksNestedInput
    Ressource?: RessourceUpdateOneRequiredWithoutActionLinksNestedInput
    permissions?: PermissionUpdateManyWithoutResourceActionNestedInput
  }

  export type ResourceActionUncheckedUpdateInput = {
    action?: EnumActionsFieldUpdateOperationsInput | $Enums.Actions
    resource?: EnumRessourcesFieldUpdateOperationsInput | $Enums.Ressources
    permissions?: PermissionUncheckedUpdateManyWithoutResourceActionNestedInput
  }

  export type ResourceActionCreateManyInput = {
    action: $Enums.Actions
    resource: $Enums.Ressources
  }

  export type ResourceActionUpdateManyMutationInput = {

  }

  export type ResourceActionUncheckedUpdateManyInput = {
    action?: EnumActionsFieldUpdateOperationsInput | $Enums.Actions
    resource?: EnumRessourcesFieldUpdateOperationsInput | $Enums.Ressources
  }

  export type RoleCreateInput = {
    name?: string
    description?: string | null
    deleted?: boolean
    employees?: EmployeesCreateNestedManyWithoutRoleInput
    permissions?: PermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    name?: string
    description?: string | null
    deleted?: boolean
    employees?: EmployeesUncheckedCreateNestedManyWithoutRoleInput
    permissions?: PermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    employees?: EmployeesUpdateManyWithoutRoleNestedInput
    permissions?: PermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    employees?: EmployeesUncheckedUpdateManyWithoutRoleNestedInput
    permissions?: PermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    name?: string
    description?: string | null
    deleted?: boolean
  }

  export type RoleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoleUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PermissionCreateInput = {
    id?: string
    allowed?: boolean
    createdAt?: Date | string
    Role: RoleCreateNestedOneWithoutPermissionsInput
    resourceAction: ResourceActionCreateNestedOneWithoutPermissionsInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: string
    role: string
    action: $Enums.Actions
    resource: $Enums.Ressources
    allowed?: boolean
    createdAt?: Date | string
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
    resourceAction?: ResourceActionUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    action?: EnumActionsFieldUpdateOperationsInput | $Enums.Actions
    resource?: EnumRessourcesFieldUpdateOperationsInput | $Enums.Ressources
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateManyInput = {
    id?: string
    role: string
    action: $Enums.Actions
    resource: $Enums.Ressources
    allowed?: boolean
    createdAt?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    action?: EnumActionsFieldUpdateOperationsInput | $Enums.Actions
    resource?: EnumRessourcesFieldUpdateOperationsInput | $Enums.Ressources
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartOnProductsCreateInput = {
    quantity?: number
    cart: CartCreateNestedOneWithoutProductsInput
    product: ProductCreateNestedOneWithoutCartsInput
  }

  export type CartOnProductsUncheckedCreateInput = {
    cartId: string
    productId: string
    quantity?: number
  }

  export type CartOnProductsUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    cart?: CartUpdateOneRequiredWithoutProductsNestedInput
    product?: ProductUpdateOneRequiredWithoutCartsNestedInput
  }

  export type CartOnProductsUncheckedUpdateInput = {
    cartId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type CartOnProductsCreateManyInput = {
    cartId: string
    productId: string
    quantity?: number
  }

  export type CartOnProductsUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type CartOnProductsUncheckedUpdateManyInput = {
    cartId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type OrderOnProductsCreateInput = {
    orderDate?: Date | string
    productAmount?: number
    order: OrderCreateNestedOneWithoutProductsInput
    product: ProductCreateNestedOneWithoutOrdersInput
  }

  export type OrderOnProductsUncheckedCreateInput = {
    orderId: string
    productId: string
    orderDate?: Date | string
    productAmount?: number
  }

  export type OrderOnProductsUpdateInput = {
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    productAmount?: IntFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutProductsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderOnProductsUncheckedUpdateInput = {
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    productAmount?: IntFieldUpdateOperationsInput | number
  }

  export type OrderOnProductsCreateManyInput = {
    orderId: string
    productId: string
    orderDate?: Date | string
    productAmount?: number
  }

  export type OrderOnProductsUpdateManyMutationInput = {
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    productAmount?: IntFieldUpdateOperationsInput | number
  }

  export type OrderOnProductsUncheckedUpdateManyInput = {
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    productAmount?: IntFieldUpdateOperationsInput | number
  }

  export type RoutesOnOrdersCreateInput = {
    route: RouteCreateNestedOneWithoutOrderInput
    order: OrderCreateNestedOneWithoutRouteInput
  }

  export type RoutesOnOrdersUncheckedCreateInput = {
    routeId: string
    orderId: string
  }

  export type RoutesOnOrdersUpdateInput = {
    route?: RouteUpdateOneRequiredWithoutOrderNestedInput
    order?: OrderUpdateOneRequiredWithoutRouteNestedInput
  }

  export type RoutesOnOrdersUncheckedUpdateInput = {
    routeId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
  }

  export type RoutesOnOrdersCreateManyInput = {
    routeId: string
    orderId: string
  }

  export type RoutesOnOrdersUpdateManyMutationInput = {

  }

  export type RoutesOnOrdersUncheckedUpdateManyInput = {
    routeId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumBusinessSectorNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessSector | EnumBusinessSectorFieldRefInput<$PrismaModel> | null
    in?: $Enums.BusinessSector[] | ListEnumBusinessSectorFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BusinessSector[] | ListEnumBusinessSectorFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBusinessSectorNullableFilter<$PrismaModel> | $Enums.BusinessSector | null
  }

  export type AddressScalarRelationFilter = {
    is?: AddressWhereInput
    isNot?: AddressWhereInput
  }

  export type CartNullableScalarRelationFilter = {
    is?: CartWhereInput | null
    isNot?: CartWhereInput | null
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type CustomerHistoryListRelationFilter = {
    every?: CustomerHistoryWhereInput
    some?: CustomerHistoryWhereInput
    none?: CustomerHistoryWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    customerId?: SortOrder
    customerReference?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    companyNumber?: SortOrder
    modifiedAt?: SortOrder
    deleted?: SortOrder
    signedUp?: SortOrder
    avatarPath?: SortOrder
    addressId?: SortOrder
    businessSector?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    customerReference?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    customerId?: SortOrder
    customerReference?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    companyNumber?: SortOrder
    modifiedAt?: SortOrder
    deleted?: SortOrder
    signedUp?: SortOrder
    avatarPath?: SortOrder
    addressId?: SortOrder
    businessSector?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    customerId?: SortOrder
    customerReference?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    companyNumber?: SortOrder
    modifiedAt?: SortOrder
    deleted?: SortOrder
    signedUp?: SortOrder
    avatarPath?: SortOrder
    addressId?: SortOrder
    businessSector?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    customerReference?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumBusinessSectorNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessSector | EnumBusinessSectorFieldRefInput<$PrismaModel> | null
    in?: $Enums.BusinessSector[] | ListEnumBusinessSectorFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BusinessSector[] | ListEnumBusinessSectorFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBusinessSectorNullableWithAggregatesFilter<$PrismaModel> | $Enums.BusinessSector | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBusinessSectorNullableFilter<$PrismaModel>
    _max?: NestedEnumBusinessSectorNullableFilter<$PrismaModel>
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type CustomerHistoryCountOrderByAggregateInput = {
    historyId?: SortOrder
    customerReference?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    companyNumber?: SortOrder
    modifiedAt?: SortOrder
    deleted?: SortOrder
    signedUp?: SortOrder
    avatarPath?: SortOrder
    addressId?: SortOrder
    businessSector?: SortOrder
  }

  export type CustomerHistoryAvgOrderByAggregateInput = {
    customerReference?: SortOrder
  }

  export type CustomerHistoryMaxOrderByAggregateInput = {
    historyId?: SortOrder
    customerReference?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    companyNumber?: SortOrder
    modifiedAt?: SortOrder
    deleted?: SortOrder
    signedUp?: SortOrder
    avatarPath?: SortOrder
    addressId?: SortOrder
    businessSector?: SortOrder
  }

  export type CustomerHistoryMinOrderByAggregateInput = {
    historyId?: SortOrder
    customerReference?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    companyNumber?: SortOrder
    modifiedAt?: SortOrder
    deleted?: SortOrder
    signedUp?: SortOrder
    avatarPath?: SortOrder
    addressId?: SortOrder
    businessSector?: SortOrder
  }

  export type CustomerHistorySumOrderByAggregateInput = {
    customerReference?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type CartOnProductsListRelationFilter = {
    every?: CartOnProductsWhereInput
    some?: CartOnProductsWhereInput
    none?: CartOnProductsWhereInput
  }

  export type CartOnProductsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CartCountOrderByAggregateInput = {
    cartId?: SortOrder
    customerReference?: SortOrder
  }

  export type CartAvgOrderByAggregateInput = {
    customerReference?: SortOrder
  }

  export type CartMaxOrderByAggregateInput = {
    cartId?: SortOrder
    customerReference?: SortOrder
  }

  export type CartMinOrderByAggregateInput = {
    cartId?: SortOrder
    customerReference?: SortOrder
  }

  export type CartSumOrderByAggregateInput = {
    customerReference?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type SiteConfigListRelationFilter = {
    every?: SiteConfigWhereInput
    some?: SiteConfigWhereInput
    none?: SiteConfigWhereInput
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SiteConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddressCountOrderByAggregateInput = {
    addressId?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postCode?: SortOrder
    state?: SortOrder
    streetName?: SortOrder
    streetNumber?: SortOrder
    modifiedAt?: SortOrder
    deleted?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    addressId?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postCode?: SortOrder
    state?: SortOrder
    streetName?: SortOrder
    streetNumber?: SortOrder
    modifiedAt?: SortOrder
    deleted?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    addressId?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postCode?: SortOrder
    state?: SortOrder
    streetName?: SortOrder
    streetNumber?: SortOrder
    modifiedAt?: SortOrder
    deleted?: SortOrder
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type OrderOnProductsListRelationFilter = {
    every?: OrderOnProductsWhereInput
    some?: OrderOnProductsWhereInput
    none?: OrderOnProductsWhereInput
  }

  export type ProductHistoryListRelationFilter = {
    every?: ProductHistoryWhereInput
    some?: ProductHistoryWhereInput
    none?: ProductHistoryWhereInput
  }

  export type OrderOnProductsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    productId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrder
    stock?: SortOrder
    imagePath?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
    deleted?: SortOrder
    categoryId?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    productId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrder
    stock?: SortOrder
    imagePath?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
    deleted?: SortOrder
    categoryId?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    productId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrder
    stock?: SortOrder
    imagePath?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
    deleted?: SortOrder
    categoryId?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type ProductHistoryCountOrderByAggregateInput = {
    historyId?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrder
    stock?: SortOrder
    imagePath?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
    deleted?: SortOrder
    categoryId?: SortOrder
  }

  export type ProductHistoryAvgOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
  }

  export type ProductHistoryMaxOrderByAggregateInput = {
    historyId?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrder
    stock?: SortOrder
    imagePath?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
    deleted?: SortOrder
    categoryId?: SortOrder
  }

  export type ProductHistoryMinOrderByAggregateInput = {
    historyId?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrder
    stock?: SortOrder
    imagePath?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
    deleted?: SortOrder
    categoryId?: SortOrder
  }

  export type ProductHistorySumOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    categoryId?: SortOrder
    name?: SortOrder
    imagePath?: SortOrder
    deleted?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    categoryId?: SortOrder
    name?: SortOrder
    imagePath?: SortOrder
    deleted?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    categoryId?: SortOrder
    name?: SortOrder
    imagePath?: SortOrder
    deleted?: SortOrder
  }

  export type EnumOrderStateFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderState | EnumOrderStateFieldRefInput<$PrismaModel>
    in?: $Enums.OrderState[] | ListEnumOrderStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderState[] | ListEnumOrderStateFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStateFilter<$PrismaModel> | $Enums.OrderState
  }

  export type InvoiceNullableScalarRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type RoutesOnOrdersListRelationFilter = {
    every?: RoutesOnOrdersWhereInput
    some?: RoutesOnOrdersWhereInput
    none?: RoutesOnOrdersWhereInput
  }

  export type RoutesOnOrdersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    orderId?: SortOrder
    customerReference?: SortOrder
    orderDate?: SortOrder
    deliveryDate?: SortOrder
    deleted?: SortOrder
    orderState?: SortOrder
    selfCollect?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    customerReference?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    orderId?: SortOrder
    customerReference?: SortOrder
    orderDate?: SortOrder
    deliveryDate?: SortOrder
    deleted?: SortOrder
    orderState?: SortOrder
    selfCollect?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    orderId?: SortOrder
    customerReference?: SortOrder
    orderDate?: SortOrder
    deliveryDate?: SortOrder
    deleted?: SortOrder
    orderState?: SortOrder
    selfCollect?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    customerReference?: SortOrder
  }

  export type EnumOrderStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderState | EnumOrderStateFieldRefInput<$PrismaModel>
    in?: $Enums.OrderState[] | ListEnumOrderStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderState[] | ListEnumOrderStateFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStateWithAggregatesFilter<$PrismaModel> | $Enums.OrderState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStateFilter<$PrismaModel>
    _max?: NestedEnumOrderStateFilter<$PrismaModel>
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type InvoiceCountOrderByAggregateInput = {
    invoiceId?: SortOrder
    orderId?: SortOrder
    invoiceAmount?: SortOrder
    paymentDate?: SortOrder
    pdfUrl?: SortOrder
    deleted?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    invoiceAmount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    invoiceId?: SortOrder
    orderId?: SortOrder
    invoiceAmount?: SortOrder
    paymentDate?: SortOrder
    pdfUrl?: SortOrder
    deleted?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    invoiceId?: SortOrder
    orderId?: SortOrder
    invoiceAmount?: SortOrder
    paymentDate?: SortOrder
    pdfUrl?: SortOrder
    deleted?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    invoiceAmount?: SortOrder
  }

  export type RouteCountOrderByAggregateInput = {
    routeId?: SortOrder
    name?: SortOrder
    deleted?: SortOrder
  }

  export type RouteMaxOrderByAggregateInput = {
    routeId?: SortOrder
    name?: SortOrder
    deleted?: SortOrder
  }

  export type RouteMinOrderByAggregateInput = {
    routeId?: SortOrder
    name?: SortOrder
    deleted?: SortOrder
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type EmployeesCountOrderByAggregateInput = {
    employeeId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    deleted?: SortOrder
    role?: SortOrder
  }

  export type EmployeesMaxOrderByAggregateInput = {
    employeeId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    deleted?: SortOrder
    role?: SortOrder
  }

  export type EmployeesMinOrderByAggregateInput = {
    employeeId?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    deleted?: SortOrder
    role?: SortOrder
  }

  export type SiteConfigCountOrderByAggregateInput = {
    siteConfigId?: SortOrder
    companyName?: SortOrder
    logoPath?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    iban?: SortOrder
    companyNumber?: SortOrder
    addressId?: SortOrder
    modifiedAt?: SortOrder
    isPremium?: SortOrder
    deleted?: SortOrder
    stripeCustomerId?: SortOrder
    stripeAccountId?: SortOrder
    stripeConfigured?: SortOrder
  }

  export type SiteConfigMaxOrderByAggregateInput = {
    siteConfigId?: SortOrder
    companyName?: SortOrder
    logoPath?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    iban?: SortOrder
    companyNumber?: SortOrder
    addressId?: SortOrder
    modifiedAt?: SortOrder
    isPremium?: SortOrder
    deleted?: SortOrder
    stripeCustomerId?: SortOrder
    stripeAccountId?: SortOrder
    stripeConfigured?: SortOrder
  }

  export type SiteConfigMinOrderByAggregateInput = {
    siteConfigId?: SortOrder
    companyName?: SortOrder
    logoPath?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    iban?: SortOrder
    companyNumber?: SortOrder
    addressId?: SortOrder
    modifiedAt?: SortOrder
    isPremium?: SortOrder
    deleted?: SortOrder
    stripeCustomerId?: SortOrder
    stripeAccountId?: SortOrder
    stripeConfigured?: SortOrder
  }

  export type EnumActionsFilter<$PrismaModel = never> = {
    equals?: $Enums.Actions | EnumActionsFieldRefInput<$PrismaModel>
    in?: $Enums.Actions[] | ListEnumActionsFieldRefInput<$PrismaModel>
    notIn?: $Enums.Actions[] | ListEnumActionsFieldRefInput<$PrismaModel>
    not?: NestedEnumActionsFilter<$PrismaModel> | $Enums.Actions
  }

  export type ResourceActionListRelationFilter = {
    every?: ResourceActionWhereInput
    some?: ResourceActionWhereInput
    none?: ResourceActionWhereInput
  }

  export type ResourceActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActionCountOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    deleted?: SortOrder
  }

  export type ActionMaxOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    deleted?: SortOrder
  }

  export type ActionMinOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    deleted?: SortOrder
  }

  export type EnumActionsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Actions | EnumActionsFieldRefInput<$PrismaModel>
    in?: $Enums.Actions[] | ListEnumActionsFieldRefInput<$PrismaModel>
    notIn?: $Enums.Actions[] | ListEnumActionsFieldRefInput<$PrismaModel>
    not?: NestedEnumActionsWithAggregatesFilter<$PrismaModel> | $Enums.Actions
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionsFilter<$PrismaModel>
    _max?: NestedEnumActionsFilter<$PrismaModel>
  }

  export type EnumRessourcesFilter<$PrismaModel = never> = {
    equals?: $Enums.Ressources | EnumRessourcesFieldRefInput<$PrismaModel>
    in?: $Enums.Ressources[] | ListEnumRessourcesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Ressources[] | ListEnumRessourcesFieldRefInput<$PrismaModel>
    not?: NestedEnumRessourcesFilter<$PrismaModel> | $Enums.Ressources
  }

  export type RessourceCountOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    deleted?: SortOrder
  }

  export type RessourceMaxOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    deleted?: SortOrder
  }

  export type RessourceMinOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    deleted?: SortOrder
  }

  export type EnumRessourcesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Ressources | EnumRessourcesFieldRefInput<$PrismaModel>
    in?: $Enums.Ressources[] | ListEnumRessourcesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Ressources[] | ListEnumRessourcesFieldRefInput<$PrismaModel>
    not?: NestedEnumRessourcesWithAggregatesFilter<$PrismaModel> | $Enums.Ressources
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRessourcesFilter<$PrismaModel>
    _max?: NestedEnumRessourcesFilter<$PrismaModel>
  }

  export type ActionScalarRelationFilter = {
    is?: ActionWhereInput
    isNot?: ActionWhereInput
  }

  export type RessourceScalarRelationFilter = {
    is?: RessourceWhereInput
    isNot?: RessourceWhereInput
  }

  export type PermissionListRelationFilter = {
    every?: PermissionWhereInput
    some?: PermissionWhereInput
    none?: PermissionWhereInput
  }

  export type PermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResourceActionActionResourceCompoundUniqueInput = {
    action: $Enums.Actions
    resource: $Enums.Ressources
  }

  export type ResourceActionCountOrderByAggregateInput = {
    action?: SortOrder
    resource?: SortOrder
  }

  export type ResourceActionMaxOrderByAggregateInput = {
    action?: SortOrder
    resource?: SortOrder
  }

  export type ResourceActionMinOrderByAggregateInput = {
    action?: SortOrder
    resource?: SortOrder
  }

  export type EmployeesListRelationFilter = {
    every?: EmployeesWhereInput
    some?: EmployeesWhereInput
    none?: EmployeesWhereInput
  }

  export type EmployeesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    deleted?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    deleted?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    deleted?: SortOrder
  }

  export type ResourceActionScalarRelationFilter = {
    is?: ResourceActionWhereInput
    isNot?: ResourceActionWhereInput
  }

  export type PermissionRoleActionResourceCompoundUniqueInput = {
    role: string
    action: $Enums.Actions
    resource: $Enums.Ressources
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    allowed?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    allowed?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    allowed?: SortOrder
    createdAt?: SortOrder
  }

  export type CartScalarRelationFilter = {
    is?: CartWhereInput
    isNot?: CartWhereInput
  }

  export type CartOnProductsCartIdProductIdCompoundUniqueInput = {
    cartId: string
    productId: string
  }

  export type CartOnProductsCountOrderByAggregateInput = {
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type CartOnProductsAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type CartOnProductsMaxOrderByAggregateInput = {
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type CartOnProductsMinOrderByAggregateInput = {
    cartId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type CartOnProductsSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type OrderOnProductsOrderIdProductIdCompoundUniqueInput = {
    orderId: string
    productId: string
  }

  export type OrderOnProductsCountOrderByAggregateInput = {
    orderId?: SortOrder
    productId?: SortOrder
    orderDate?: SortOrder
    productAmount?: SortOrder
  }

  export type OrderOnProductsAvgOrderByAggregateInput = {
    productAmount?: SortOrder
  }

  export type OrderOnProductsMaxOrderByAggregateInput = {
    orderId?: SortOrder
    productId?: SortOrder
    orderDate?: SortOrder
    productAmount?: SortOrder
  }

  export type OrderOnProductsMinOrderByAggregateInput = {
    orderId?: SortOrder
    productId?: SortOrder
    orderDate?: SortOrder
    productAmount?: SortOrder
  }

  export type OrderOnProductsSumOrderByAggregateInput = {
    productAmount?: SortOrder
  }

  export type RouteScalarRelationFilter = {
    is?: RouteWhereInput
    isNot?: RouteWhereInput
  }

  export type RoutesOnOrdersRouteIdOrderIdCompoundUniqueInput = {
    routeId: string
    orderId: string
  }

  export type RoutesOnOrdersCountOrderByAggregateInput = {
    routeId?: SortOrder
    orderId?: SortOrder
  }

  export type RoutesOnOrdersMaxOrderByAggregateInput = {
    routeId?: SortOrder
    orderId?: SortOrder
  }

  export type RoutesOnOrdersMinOrderByAggregateInput = {
    routeId?: SortOrder
    orderId?: SortOrder
  }

  export type AddressCreateNestedOneWithoutCustomersInput = {
    create?: XOR<AddressCreateWithoutCustomersInput, AddressUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: AddressCreateOrConnectWithoutCustomersInput
    connect?: AddressWhereUniqueInput
  }

  export type CartCreateNestedOneWithoutCustomerInput = {
    create?: XOR<CartCreateWithoutCustomerInput, CartUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: CartCreateOrConnectWithoutCustomerInput
    connect?: CartWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type CustomerHistoryCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerHistoryCreateWithoutCustomerInput, CustomerHistoryUncheckedCreateWithoutCustomerInput> | CustomerHistoryCreateWithoutCustomerInput[] | CustomerHistoryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerHistoryCreateOrConnectWithoutCustomerInput | CustomerHistoryCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerHistoryCreateManyCustomerInputEnvelope
    connect?: CustomerHistoryWhereUniqueInput | CustomerHistoryWhereUniqueInput[]
  }

  export type CartUncheckedCreateNestedOneWithoutCustomerInput = {
    create?: XOR<CartCreateWithoutCustomerInput, CartUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: CartCreateOrConnectWithoutCustomerInput
    connect?: CartWhereUniqueInput
  }

  export type OrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type CustomerHistoryUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerHistoryCreateWithoutCustomerInput, CustomerHistoryUncheckedCreateWithoutCustomerInput> | CustomerHistoryCreateWithoutCustomerInput[] | CustomerHistoryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerHistoryCreateOrConnectWithoutCustomerInput | CustomerHistoryCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerHistoryCreateManyCustomerInputEnvelope
    connect?: CustomerHistoryWhereUniqueInput | CustomerHistoryWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableEnumBusinessSectorFieldUpdateOperationsInput = {
    set?: $Enums.BusinessSector | null
  }

  export type AddressUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<AddressCreateWithoutCustomersInput, AddressUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: AddressCreateOrConnectWithoutCustomersInput
    upsert?: AddressUpsertWithoutCustomersInput
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutCustomersInput, AddressUpdateWithoutCustomersInput>, AddressUncheckedUpdateWithoutCustomersInput>
  }

  export type CartUpdateOneWithoutCustomerNestedInput = {
    create?: XOR<CartCreateWithoutCustomerInput, CartUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: CartCreateOrConnectWithoutCustomerInput
    upsert?: CartUpsertWithoutCustomerInput
    disconnect?: CartWhereInput | boolean
    delete?: CartWhereInput | boolean
    connect?: CartWhereUniqueInput
    update?: XOR<XOR<CartUpdateToOneWithWhereWithoutCustomerInput, CartUpdateWithoutCustomerInput>, CartUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type CustomerHistoryUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerHistoryCreateWithoutCustomerInput, CustomerHistoryUncheckedCreateWithoutCustomerInput> | CustomerHistoryCreateWithoutCustomerInput[] | CustomerHistoryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerHistoryCreateOrConnectWithoutCustomerInput | CustomerHistoryCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerHistoryUpsertWithWhereUniqueWithoutCustomerInput | CustomerHistoryUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerHistoryCreateManyCustomerInputEnvelope
    set?: CustomerHistoryWhereUniqueInput | CustomerHistoryWhereUniqueInput[]
    disconnect?: CustomerHistoryWhereUniqueInput | CustomerHistoryWhereUniqueInput[]
    delete?: CustomerHistoryWhereUniqueInput | CustomerHistoryWhereUniqueInput[]
    connect?: CustomerHistoryWhereUniqueInput | CustomerHistoryWhereUniqueInput[]
    update?: CustomerHistoryUpdateWithWhereUniqueWithoutCustomerInput | CustomerHistoryUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerHistoryUpdateManyWithWhereWithoutCustomerInput | CustomerHistoryUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerHistoryScalarWhereInput | CustomerHistoryScalarWhereInput[]
  }

  export type CartUncheckedUpdateOneWithoutCustomerNestedInput = {
    create?: XOR<CartCreateWithoutCustomerInput, CartUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: CartCreateOrConnectWithoutCustomerInput
    upsert?: CartUpsertWithoutCustomerInput
    disconnect?: CartWhereInput | boolean
    delete?: CartWhereInput | boolean
    connect?: CartWhereUniqueInput
    update?: XOR<XOR<CartUpdateToOneWithWhereWithoutCustomerInput, CartUpdateWithoutCustomerInput>, CartUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type CustomerHistoryUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerHistoryCreateWithoutCustomerInput, CustomerHistoryUncheckedCreateWithoutCustomerInput> | CustomerHistoryCreateWithoutCustomerInput[] | CustomerHistoryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerHistoryCreateOrConnectWithoutCustomerInput | CustomerHistoryCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerHistoryUpsertWithWhereUniqueWithoutCustomerInput | CustomerHistoryUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerHistoryCreateManyCustomerInputEnvelope
    set?: CustomerHistoryWhereUniqueInput | CustomerHistoryWhereUniqueInput[]
    disconnect?: CustomerHistoryWhereUniqueInput | CustomerHistoryWhereUniqueInput[]
    delete?: CustomerHistoryWhereUniqueInput | CustomerHistoryWhereUniqueInput[]
    connect?: CustomerHistoryWhereUniqueInput | CustomerHistoryWhereUniqueInput[]
    update?: CustomerHistoryUpdateWithWhereUniqueWithoutCustomerInput | CustomerHistoryUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerHistoryUpdateManyWithWhereWithoutCustomerInput | CustomerHistoryUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerHistoryScalarWhereInput | CustomerHistoryScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutHistoryInput = {
    create?: XOR<CustomerCreateWithoutHistoryInput, CustomerUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutHistoryInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<CustomerCreateWithoutHistoryInput, CustomerUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutHistoryInput
    upsert?: CustomerUpsertWithoutHistoryInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutHistoryInput, CustomerUpdateWithoutHistoryInput>, CustomerUncheckedUpdateWithoutHistoryInput>
  }

  export type CustomerCreateNestedOneWithoutCartInput = {
    create?: XOR<CustomerCreateWithoutCartInput, CustomerUncheckedCreateWithoutCartInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCartInput
    connect?: CustomerWhereUniqueInput
  }

  export type CartOnProductsCreateNestedManyWithoutCartInput = {
    create?: XOR<CartOnProductsCreateWithoutCartInput, CartOnProductsUncheckedCreateWithoutCartInput> | CartOnProductsCreateWithoutCartInput[] | CartOnProductsUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartOnProductsCreateOrConnectWithoutCartInput | CartOnProductsCreateOrConnectWithoutCartInput[]
    createMany?: CartOnProductsCreateManyCartInputEnvelope
    connect?: CartOnProductsWhereUniqueInput | CartOnProductsWhereUniqueInput[]
  }

  export type CartOnProductsUncheckedCreateNestedManyWithoutCartInput = {
    create?: XOR<CartOnProductsCreateWithoutCartInput, CartOnProductsUncheckedCreateWithoutCartInput> | CartOnProductsCreateWithoutCartInput[] | CartOnProductsUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartOnProductsCreateOrConnectWithoutCartInput | CartOnProductsCreateOrConnectWithoutCartInput[]
    createMany?: CartOnProductsCreateManyCartInputEnvelope
    connect?: CartOnProductsWhereUniqueInput | CartOnProductsWhereUniqueInput[]
  }

  export type CustomerUpdateOneWithoutCartNestedInput = {
    create?: XOR<CustomerCreateWithoutCartInput, CustomerUncheckedCreateWithoutCartInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCartInput
    upsert?: CustomerUpsertWithoutCartInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutCartInput, CustomerUpdateWithoutCartInput>, CustomerUncheckedUpdateWithoutCartInput>
  }

  export type CartOnProductsUpdateManyWithoutCartNestedInput = {
    create?: XOR<CartOnProductsCreateWithoutCartInput, CartOnProductsUncheckedCreateWithoutCartInput> | CartOnProductsCreateWithoutCartInput[] | CartOnProductsUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartOnProductsCreateOrConnectWithoutCartInput | CartOnProductsCreateOrConnectWithoutCartInput[]
    upsert?: CartOnProductsUpsertWithWhereUniqueWithoutCartInput | CartOnProductsUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: CartOnProductsCreateManyCartInputEnvelope
    set?: CartOnProductsWhereUniqueInput | CartOnProductsWhereUniqueInput[]
    disconnect?: CartOnProductsWhereUniqueInput | CartOnProductsWhereUniqueInput[]
    delete?: CartOnProductsWhereUniqueInput | CartOnProductsWhereUniqueInput[]
    connect?: CartOnProductsWhereUniqueInput | CartOnProductsWhereUniqueInput[]
    update?: CartOnProductsUpdateWithWhereUniqueWithoutCartInput | CartOnProductsUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: CartOnProductsUpdateManyWithWhereWithoutCartInput | CartOnProductsUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: CartOnProductsScalarWhereInput | CartOnProductsScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CartOnProductsUncheckedUpdateManyWithoutCartNestedInput = {
    create?: XOR<CartOnProductsCreateWithoutCartInput, CartOnProductsUncheckedCreateWithoutCartInput> | CartOnProductsCreateWithoutCartInput[] | CartOnProductsUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartOnProductsCreateOrConnectWithoutCartInput | CartOnProductsCreateOrConnectWithoutCartInput[]
    upsert?: CartOnProductsUpsertWithWhereUniqueWithoutCartInput | CartOnProductsUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: CartOnProductsCreateManyCartInputEnvelope
    set?: CartOnProductsWhereUniqueInput | CartOnProductsWhereUniqueInput[]
    disconnect?: CartOnProductsWhereUniqueInput | CartOnProductsWhereUniqueInput[]
    delete?: CartOnProductsWhereUniqueInput | CartOnProductsWhereUniqueInput[]
    connect?: CartOnProductsWhereUniqueInput | CartOnProductsWhereUniqueInput[]
    update?: CartOnProductsUpdateWithWhereUniqueWithoutCartInput | CartOnProductsUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: CartOnProductsUpdateManyWithWhereWithoutCartInput | CartOnProductsUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: CartOnProductsScalarWhereInput | CartOnProductsScalarWhereInput[]
  }

  export type CustomerCreateNestedManyWithoutAddressInput = {
    create?: XOR<CustomerCreateWithoutAddressInput, CustomerUncheckedCreateWithoutAddressInput> | CustomerCreateWithoutAddressInput[] | CustomerUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutAddressInput | CustomerCreateOrConnectWithoutAddressInput[]
    createMany?: CustomerCreateManyAddressInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type SiteConfigCreateNestedManyWithoutAddressInput = {
    create?: XOR<SiteConfigCreateWithoutAddressInput, SiteConfigUncheckedCreateWithoutAddressInput> | SiteConfigCreateWithoutAddressInput[] | SiteConfigUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: SiteConfigCreateOrConnectWithoutAddressInput | SiteConfigCreateOrConnectWithoutAddressInput[]
    createMany?: SiteConfigCreateManyAddressInputEnvelope
    connect?: SiteConfigWhereUniqueInput | SiteConfigWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutAddressInput = {
    create?: XOR<CustomerCreateWithoutAddressInput, CustomerUncheckedCreateWithoutAddressInput> | CustomerCreateWithoutAddressInput[] | CustomerUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutAddressInput | CustomerCreateOrConnectWithoutAddressInput[]
    createMany?: CustomerCreateManyAddressInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type SiteConfigUncheckedCreateNestedManyWithoutAddressInput = {
    create?: XOR<SiteConfigCreateWithoutAddressInput, SiteConfigUncheckedCreateWithoutAddressInput> | SiteConfigCreateWithoutAddressInput[] | SiteConfigUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: SiteConfigCreateOrConnectWithoutAddressInput | SiteConfigCreateOrConnectWithoutAddressInput[]
    createMany?: SiteConfigCreateManyAddressInputEnvelope
    connect?: SiteConfigWhereUniqueInput | SiteConfigWhereUniqueInput[]
  }

  export type CustomerUpdateManyWithoutAddressNestedInput = {
    create?: XOR<CustomerCreateWithoutAddressInput, CustomerUncheckedCreateWithoutAddressInput> | CustomerCreateWithoutAddressInput[] | CustomerUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutAddressInput | CustomerCreateOrConnectWithoutAddressInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutAddressInput | CustomerUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: CustomerCreateManyAddressInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutAddressInput | CustomerUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutAddressInput | CustomerUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type SiteConfigUpdateManyWithoutAddressNestedInput = {
    create?: XOR<SiteConfigCreateWithoutAddressInput, SiteConfigUncheckedCreateWithoutAddressInput> | SiteConfigCreateWithoutAddressInput[] | SiteConfigUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: SiteConfigCreateOrConnectWithoutAddressInput | SiteConfigCreateOrConnectWithoutAddressInput[]
    upsert?: SiteConfigUpsertWithWhereUniqueWithoutAddressInput | SiteConfigUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: SiteConfigCreateManyAddressInputEnvelope
    set?: SiteConfigWhereUniqueInput | SiteConfigWhereUniqueInput[]
    disconnect?: SiteConfigWhereUniqueInput | SiteConfigWhereUniqueInput[]
    delete?: SiteConfigWhereUniqueInput | SiteConfigWhereUniqueInput[]
    connect?: SiteConfigWhereUniqueInput | SiteConfigWhereUniqueInput[]
    update?: SiteConfigUpdateWithWhereUniqueWithoutAddressInput | SiteConfigUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: SiteConfigUpdateManyWithWhereWithoutAddressInput | SiteConfigUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: SiteConfigScalarWhereInput | SiteConfigScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutAddressNestedInput = {
    create?: XOR<CustomerCreateWithoutAddressInput, CustomerUncheckedCreateWithoutAddressInput> | CustomerCreateWithoutAddressInput[] | CustomerUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutAddressInput | CustomerCreateOrConnectWithoutAddressInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutAddressInput | CustomerUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: CustomerCreateManyAddressInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutAddressInput | CustomerUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutAddressInput | CustomerUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type SiteConfigUncheckedUpdateManyWithoutAddressNestedInput = {
    create?: XOR<SiteConfigCreateWithoutAddressInput, SiteConfigUncheckedCreateWithoutAddressInput> | SiteConfigCreateWithoutAddressInput[] | SiteConfigUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: SiteConfigCreateOrConnectWithoutAddressInput | SiteConfigCreateOrConnectWithoutAddressInput[]
    upsert?: SiteConfigUpsertWithWhereUniqueWithoutAddressInput | SiteConfigUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: SiteConfigCreateManyAddressInputEnvelope
    set?: SiteConfigWhereUniqueInput | SiteConfigWhereUniqueInput[]
    disconnect?: SiteConfigWhereUniqueInput | SiteConfigWhereUniqueInput[]
    delete?: SiteConfigWhereUniqueInput | SiteConfigWhereUniqueInput[]
    connect?: SiteConfigWhereUniqueInput | SiteConfigWhereUniqueInput[]
    update?: SiteConfigUpdateWithWhereUniqueWithoutAddressInput | SiteConfigUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: SiteConfigUpdateManyWithWhereWithoutAddressInput | SiteConfigUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: SiteConfigScalarWhereInput | SiteConfigScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    connect?: CategoryWhereUniqueInput
  }

  export type CartOnProductsCreateNestedManyWithoutProductInput = {
    create?: XOR<CartOnProductsCreateWithoutProductInput, CartOnProductsUncheckedCreateWithoutProductInput> | CartOnProductsCreateWithoutProductInput[] | CartOnProductsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartOnProductsCreateOrConnectWithoutProductInput | CartOnProductsCreateOrConnectWithoutProductInput[]
    createMany?: CartOnProductsCreateManyProductInputEnvelope
    connect?: CartOnProductsWhereUniqueInput | CartOnProductsWhereUniqueInput[]
  }

  export type OrderOnProductsCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderOnProductsCreateWithoutProductInput, OrderOnProductsUncheckedCreateWithoutProductInput> | OrderOnProductsCreateWithoutProductInput[] | OrderOnProductsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderOnProductsCreateOrConnectWithoutProductInput | OrderOnProductsCreateOrConnectWithoutProductInput[]
    createMany?: OrderOnProductsCreateManyProductInputEnvelope
    connect?: OrderOnProductsWhereUniqueInput | OrderOnProductsWhereUniqueInput[]
  }

  export type ProductHistoryCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductHistoryCreateWithoutProductInput, ProductHistoryUncheckedCreateWithoutProductInput> | ProductHistoryCreateWithoutProductInput[] | ProductHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductHistoryCreateOrConnectWithoutProductInput | ProductHistoryCreateOrConnectWithoutProductInput[]
    createMany?: ProductHistoryCreateManyProductInputEnvelope
    connect?: ProductHistoryWhereUniqueInput | ProductHistoryWhereUniqueInput[]
  }

  export type CartOnProductsUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CartOnProductsCreateWithoutProductInput, CartOnProductsUncheckedCreateWithoutProductInput> | CartOnProductsCreateWithoutProductInput[] | CartOnProductsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartOnProductsCreateOrConnectWithoutProductInput | CartOnProductsCreateOrConnectWithoutProductInput[]
    createMany?: CartOnProductsCreateManyProductInputEnvelope
    connect?: CartOnProductsWhereUniqueInput | CartOnProductsWhereUniqueInput[]
  }

  export type OrderOnProductsUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderOnProductsCreateWithoutProductInput, OrderOnProductsUncheckedCreateWithoutProductInput> | OrderOnProductsCreateWithoutProductInput[] | OrderOnProductsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderOnProductsCreateOrConnectWithoutProductInput | OrderOnProductsCreateOrConnectWithoutProductInput[]
    createMany?: OrderOnProductsCreateManyProductInputEnvelope
    connect?: OrderOnProductsWhereUniqueInput | OrderOnProductsWhereUniqueInput[]
  }

  export type ProductHistoryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductHistoryCreateWithoutProductInput, ProductHistoryUncheckedCreateWithoutProductInput> | ProductHistoryCreateWithoutProductInput[] | ProductHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductHistoryCreateOrConnectWithoutProductInput | ProductHistoryCreateOrConnectWithoutProductInput[]
    createMany?: ProductHistoryCreateManyProductInputEnvelope
    connect?: ProductHistoryWhereUniqueInput | ProductHistoryWhereUniqueInput[]
  }

  export type CategoryUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    upsert?: CategoryUpsertWithoutProductsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProductsInput, CategoryUpdateWithoutProductsInput>, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CartOnProductsUpdateManyWithoutProductNestedInput = {
    create?: XOR<CartOnProductsCreateWithoutProductInput, CartOnProductsUncheckedCreateWithoutProductInput> | CartOnProductsCreateWithoutProductInput[] | CartOnProductsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartOnProductsCreateOrConnectWithoutProductInput | CartOnProductsCreateOrConnectWithoutProductInput[]
    upsert?: CartOnProductsUpsertWithWhereUniqueWithoutProductInput | CartOnProductsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CartOnProductsCreateManyProductInputEnvelope
    set?: CartOnProductsWhereUniqueInput | CartOnProductsWhereUniqueInput[]
    disconnect?: CartOnProductsWhereUniqueInput | CartOnProductsWhereUniqueInput[]
    delete?: CartOnProductsWhereUniqueInput | CartOnProductsWhereUniqueInput[]
    connect?: CartOnProductsWhereUniqueInput | CartOnProductsWhereUniqueInput[]
    update?: CartOnProductsUpdateWithWhereUniqueWithoutProductInput | CartOnProductsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CartOnProductsUpdateManyWithWhereWithoutProductInput | CartOnProductsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CartOnProductsScalarWhereInput | CartOnProductsScalarWhereInput[]
  }

  export type OrderOnProductsUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderOnProductsCreateWithoutProductInput, OrderOnProductsUncheckedCreateWithoutProductInput> | OrderOnProductsCreateWithoutProductInput[] | OrderOnProductsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderOnProductsCreateOrConnectWithoutProductInput | OrderOnProductsCreateOrConnectWithoutProductInput[]
    upsert?: OrderOnProductsUpsertWithWhereUniqueWithoutProductInput | OrderOnProductsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderOnProductsCreateManyProductInputEnvelope
    set?: OrderOnProductsWhereUniqueInput | OrderOnProductsWhereUniqueInput[]
    disconnect?: OrderOnProductsWhereUniqueInput | OrderOnProductsWhereUniqueInput[]
    delete?: OrderOnProductsWhereUniqueInput | OrderOnProductsWhereUniqueInput[]
    connect?: OrderOnProductsWhereUniqueInput | OrderOnProductsWhereUniqueInput[]
    update?: OrderOnProductsUpdateWithWhereUniqueWithoutProductInput | OrderOnProductsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderOnProductsUpdateManyWithWhereWithoutProductInput | OrderOnProductsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderOnProductsScalarWhereInput | OrderOnProductsScalarWhereInput[]
  }

  export type ProductHistoryUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductHistoryCreateWithoutProductInput, ProductHistoryUncheckedCreateWithoutProductInput> | ProductHistoryCreateWithoutProductInput[] | ProductHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductHistoryCreateOrConnectWithoutProductInput | ProductHistoryCreateOrConnectWithoutProductInput[]
    upsert?: ProductHistoryUpsertWithWhereUniqueWithoutProductInput | ProductHistoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductHistoryCreateManyProductInputEnvelope
    set?: ProductHistoryWhereUniqueInput | ProductHistoryWhereUniqueInput[]
    disconnect?: ProductHistoryWhereUniqueInput | ProductHistoryWhereUniqueInput[]
    delete?: ProductHistoryWhereUniqueInput | ProductHistoryWhereUniqueInput[]
    connect?: ProductHistoryWhereUniqueInput | ProductHistoryWhereUniqueInput[]
    update?: ProductHistoryUpdateWithWhereUniqueWithoutProductInput | ProductHistoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductHistoryUpdateManyWithWhereWithoutProductInput | ProductHistoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductHistoryScalarWhereInput | ProductHistoryScalarWhereInput[]
  }

  export type CartOnProductsUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CartOnProductsCreateWithoutProductInput, CartOnProductsUncheckedCreateWithoutProductInput> | CartOnProductsCreateWithoutProductInput[] | CartOnProductsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartOnProductsCreateOrConnectWithoutProductInput | CartOnProductsCreateOrConnectWithoutProductInput[]
    upsert?: CartOnProductsUpsertWithWhereUniqueWithoutProductInput | CartOnProductsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CartOnProductsCreateManyProductInputEnvelope
    set?: CartOnProductsWhereUniqueInput | CartOnProductsWhereUniqueInput[]
    disconnect?: CartOnProductsWhereUniqueInput | CartOnProductsWhereUniqueInput[]
    delete?: CartOnProductsWhereUniqueInput | CartOnProductsWhereUniqueInput[]
    connect?: CartOnProductsWhereUniqueInput | CartOnProductsWhereUniqueInput[]
    update?: CartOnProductsUpdateWithWhereUniqueWithoutProductInput | CartOnProductsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CartOnProductsUpdateManyWithWhereWithoutProductInput | CartOnProductsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CartOnProductsScalarWhereInput | CartOnProductsScalarWhereInput[]
  }

  export type OrderOnProductsUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderOnProductsCreateWithoutProductInput, OrderOnProductsUncheckedCreateWithoutProductInput> | OrderOnProductsCreateWithoutProductInput[] | OrderOnProductsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderOnProductsCreateOrConnectWithoutProductInput | OrderOnProductsCreateOrConnectWithoutProductInput[]
    upsert?: OrderOnProductsUpsertWithWhereUniqueWithoutProductInput | OrderOnProductsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderOnProductsCreateManyProductInputEnvelope
    set?: OrderOnProductsWhereUniqueInput | OrderOnProductsWhereUniqueInput[]
    disconnect?: OrderOnProductsWhereUniqueInput | OrderOnProductsWhereUniqueInput[]
    delete?: OrderOnProductsWhereUniqueInput | OrderOnProductsWhereUniqueInput[]
    connect?: OrderOnProductsWhereUniqueInput | OrderOnProductsWhereUniqueInput[]
    update?: OrderOnProductsUpdateWithWhereUniqueWithoutProductInput | OrderOnProductsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderOnProductsUpdateManyWithWhereWithoutProductInput | OrderOnProductsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderOnProductsScalarWhereInput | OrderOnProductsScalarWhereInput[]
  }

  export type ProductHistoryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductHistoryCreateWithoutProductInput, ProductHistoryUncheckedCreateWithoutProductInput> | ProductHistoryCreateWithoutProductInput[] | ProductHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductHistoryCreateOrConnectWithoutProductInput | ProductHistoryCreateOrConnectWithoutProductInput[]
    upsert?: ProductHistoryUpsertWithWhereUniqueWithoutProductInput | ProductHistoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductHistoryCreateManyProductInputEnvelope
    set?: ProductHistoryWhereUniqueInput | ProductHistoryWhereUniqueInput[]
    disconnect?: ProductHistoryWhereUniqueInput | ProductHistoryWhereUniqueInput[]
    delete?: ProductHistoryWhereUniqueInput | ProductHistoryWhereUniqueInput[]
    connect?: ProductHistoryWhereUniqueInput | ProductHistoryWhereUniqueInput[]
    update?: ProductHistoryUpdateWithWhereUniqueWithoutProductInput | ProductHistoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductHistoryUpdateManyWithWhereWithoutProductInput | ProductHistoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductHistoryScalarWhereInput | ProductHistoryScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutProductHistoryInput = {
    create?: XOR<CategoryCreateWithoutProductHistoryInput, CategoryUncheckedCreateWithoutProductHistoryInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductHistoryInput
    connect?: CategoryWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutProductHistoryInput = {
    create?: XOR<ProductCreateWithoutProductHistoryInput, ProductUncheckedCreateWithoutProductHistoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductHistoryInput
    connect?: ProductWhereUniqueInput
  }

  export type CategoryUpdateOneRequiredWithoutProductHistoryNestedInput = {
    create?: XOR<CategoryCreateWithoutProductHistoryInput, CategoryUncheckedCreateWithoutProductHistoryInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductHistoryInput
    upsert?: CategoryUpsertWithoutProductHistoryInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProductHistoryInput, CategoryUpdateWithoutProductHistoryInput>, CategoryUncheckedUpdateWithoutProductHistoryInput>
  }

  export type ProductUpdateOneRequiredWithoutProductHistoryNestedInput = {
    create?: XOR<ProductCreateWithoutProductHistoryInput, ProductUncheckedCreateWithoutProductHistoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductHistoryInput
    upsert?: ProductUpsertWithoutProductHistoryInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductHistoryInput, ProductUpdateWithoutProductHistoryInput>, ProductUncheckedUpdateWithoutProductHistoryInput>
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductHistoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductHistoryCreateWithoutCategoryInput, ProductHistoryUncheckedCreateWithoutCategoryInput> | ProductHistoryCreateWithoutCategoryInput[] | ProductHistoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductHistoryCreateOrConnectWithoutCategoryInput | ProductHistoryCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductHistoryCreateManyCategoryInputEnvelope
    connect?: ProductHistoryWhereUniqueInput | ProductHistoryWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductHistoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductHistoryCreateWithoutCategoryInput, ProductHistoryUncheckedCreateWithoutCategoryInput> | ProductHistoryCreateWithoutCategoryInput[] | ProductHistoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductHistoryCreateOrConnectWithoutCategoryInput | ProductHistoryCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductHistoryCreateManyCategoryInputEnvelope
    connect?: ProductHistoryWhereUniqueInput | ProductHistoryWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductHistoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductHistoryCreateWithoutCategoryInput, ProductHistoryUncheckedCreateWithoutCategoryInput> | ProductHistoryCreateWithoutCategoryInput[] | ProductHistoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductHistoryCreateOrConnectWithoutCategoryInput | ProductHistoryCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductHistoryUpsertWithWhereUniqueWithoutCategoryInput | ProductHistoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductHistoryCreateManyCategoryInputEnvelope
    set?: ProductHistoryWhereUniqueInput | ProductHistoryWhereUniqueInput[]
    disconnect?: ProductHistoryWhereUniqueInput | ProductHistoryWhereUniqueInput[]
    delete?: ProductHistoryWhereUniqueInput | ProductHistoryWhereUniqueInput[]
    connect?: ProductHistoryWhereUniqueInput | ProductHistoryWhereUniqueInput[]
    update?: ProductHistoryUpdateWithWhereUniqueWithoutCategoryInput | ProductHistoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductHistoryUpdateManyWithWhereWithoutCategoryInput | ProductHistoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductHistoryScalarWhereInput | ProductHistoryScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductHistoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductHistoryCreateWithoutCategoryInput, ProductHistoryUncheckedCreateWithoutCategoryInput> | ProductHistoryCreateWithoutCategoryInput[] | ProductHistoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductHistoryCreateOrConnectWithoutCategoryInput | ProductHistoryCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductHistoryUpsertWithWhereUniqueWithoutCategoryInput | ProductHistoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductHistoryCreateManyCategoryInputEnvelope
    set?: ProductHistoryWhereUniqueInput | ProductHistoryWhereUniqueInput[]
    disconnect?: ProductHistoryWhereUniqueInput | ProductHistoryWhereUniqueInput[]
    delete?: ProductHistoryWhereUniqueInput | ProductHistoryWhereUniqueInput[]
    connect?: ProductHistoryWhereUniqueInput | ProductHistoryWhereUniqueInput[]
    update?: ProductHistoryUpdateWithWhereUniqueWithoutCategoryInput | ProductHistoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductHistoryUpdateManyWithWhereWithoutCategoryInput | ProductHistoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductHistoryScalarWhereInput | ProductHistoryScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutOrdersInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
  }

  export type OrderOnProductsCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderOnProductsCreateWithoutOrderInput, OrderOnProductsUncheckedCreateWithoutOrderInput> | OrderOnProductsCreateWithoutOrderInput[] | OrderOnProductsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderOnProductsCreateOrConnectWithoutOrderInput | OrderOnProductsCreateOrConnectWithoutOrderInput[]
    createMany?: OrderOnProductsCreateManyOrderInputEnvelope
    connect?: OrderOnProductsWhereUniqueInput | OrderOnProductsWhereUniqueInput[]
  }

  export type InvoiceCreateNestedOneWithoutOrderInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput
    connect?: InvoiceWhereUniqueInput
  }

  export type RoutesOnOrdersCreateNestedManyWithoutOrderInput = {
    create?: XOR<RoutesOnOrdersCreateWithoutOrderInput, RoutesOnOrdersUncheckedCreateWithoutOrderInput> | RoutesOnOrdersCreateWithoutOrderInput[] | RoutesOnOrdersUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: RoutesOnOrdersCreateOrConnectWithoutOrderInput | RoutesOnOrdersCreateOrConnectWithoutOrderInput[]
    createMany?: RoutesOnOrdersCreateManyOrderInputEnvelope
    connect?: RoutesOnOrdersWhereUniqueInput | RoutesOnOrdersWhereUniqueInput[]
  }

  export type OrderOnProductsUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderOnProductsCreateWithoutOrderInput, OrderOnProductsUncheckedCreateWithoutOrderInput> | OrderOnProductsCreateWithoutOrderInput[] | OrderOnProductsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderOnProductsCreateOrConnectWithoutOrderInput | OrderOnProductsCreateOrConnectWithoutOrderInput[]
    createMany?: OrderOnProductsCreateManyOrderInputEnvelope
    connect?: OrderOnProductsWhereUniqueInput | OrderOnProductsWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput
    connect?: InvoiceWhereUniqueInput
  }

  export type RoutesOnOrdersUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<RoutesOnOrdersCreateWithoutOrderInput, RoutesOnOrdersUncheckedCreateWithoutOrderInput> | RoutesOnOrdersCreateWithoutOrderInput[] | RoutesOnOrdersUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: RoutesOnOrdersCreateOrConnectWithoutOrderInput | RoutesOnOrdersCreateOrConnectWithoutOrderInput[]
    createMany?: RoutesOnOrdersCreateManyOrderInputEnvelope
    connect?: RoutesOnOrdersWhereUniqueInput | RoutesOnOrdersWhereUniqueInput[]
  }

  export type EnumOrderStateFieldUpdateOperationsInput = {
    set?: $Enums.OrderState
  }

  export type CustomerUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    upsert?: CustomerUpsertWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutOrdersInput, CustomerUpdateWithoutOrdersInput>, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderOnProductsUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderOnProductsCreateWithoutOrderInput, OrderOnProductsUncheckedCreateWithoutOrderInput> | OrderOnProductsCreateWithoutOrderInput[] | OrderOnProductsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderOnProductsCreateOrConnectWithoutOrderInput | OrderOnProductsCreateOrConnectWithoutOrderInput[]
    upsert?: OrderOnProductsUpsertWithWhereUniqueWithoutOrderInput | OrderOnProductsUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderOnProductsCreateManyOrderInputEnvelope
    set?: OrderOnProductsWhereUniqueInput | OrderOnProductsWhereUniqueInput[]
    disconnect?: OrderOnProductsWhereUniqueInput | OrderOnProductsWhereUniqueInput[]
    delete?: OrderOnProductsWhereUniqueInput | OrderOnProductsWhereUniqueInput[]
    connect?: OrderOnProductsWhereUniqueInput | OrderOnProductsWhereUniqueInput[]
    update?: OrderOnProductsUpdateWithWhereUniqueWithoutOrderInput | OrderOnProductsUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderOnProductsUpdateManyWithWhereWithoutOrderInput | OrderOnProductsUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderOnProductsScalarWhereInput | OrderOnProductsScalarWhereInput[]
  }

  export type InvoiceUpdateOneWithoutOrderNestedInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput
    upsert?: InvoiceUpsertWithoutOrderInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutOrderInput, InvoiceUpdateWithoutOrderInput>, InvoiceUncheckedUpdateWithoutOrderInput>
  }

  export type RoutesOnOrdersUpdateManyWithoutOrderNestedInput = {
    create?: XOR<RoutesOnOrdersCreateWithoutOrderInput, RoutesOnOrdersUncheckedCreateWithoutOrderInput> | RoutesOnOrdersCreateWithoutOrderInput[] | RoutesOnOrdersUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: RoutesOnOrdersCreateOrConnectWithoutOrderInput | RoutesOnOrdersCreateOrConnectWithoutOrderInput[]
    upsert?: RoutesOnOrdersUpsertWithWhereUniqueWithoutOrderInput | RoutesOnOrdersUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: RoutesOnOrdersCreateManyOrderInputEnvelope
    set?: RoutesOnOrdersWhereUniqueInput | RoutesOnOrdersWhereUniqueInput[]
    disconnect?: RoutesOnOrdersWhereUniqueInput | RoutesOnOrdersWhereUniqueInput[]
    delete?: RoutesOnOrdersWhereUniqueInput | RoutesOnOrdersWhereUniqueInput[]
    connect?: RoutesOnOrdersWhereUniqueInput | RoutesOnOrdersWhereUniqueInput[]
    update?: RoutesOnOrdersUpdateWithWhereUniqueWithoutOrderInput | RoutesOnOrdersUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: RoutesOnOrdersUpdateManyWithWhereWithoutOrderInput | RoutesOnOrdersUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: RoutesOnOrdersScalarWhereInput | RoutesOnOrdersScalarWhereInput[]
  }

  export type OrderOnProductsUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderOnProductsCreateWithoutOrderInput, OrderOnProductsUncheckedCreateWithoutOrderInput> | OrderOnProductsCreateWithoutOrderInput[] | OrderOnProductsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderOnProductsCreateOrConnectWithoutOrderInput | OrderOnProductsCreateOrConnectWithoutOrderInput[]
    upsert?: OrderOnProductsUpsertWithWhereUniqueWithoutOrderInput | OrderOnProductsUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderOnProductsCreateManyOrderInputEnvelope
    set?: OrderOnProductsWhereUniqueInput | OrderOnProductsWhereUniqueInput[]
    disconnect?: OrderOnProductsWhereUniqueInput | OrderOnProductsWhereUniqueInput[]
    delete?: OrderOnProductsWhereUniqueInput | OrderOnProductsWhereUniqueInput[]
    connect?: OrderOnProductsWhereUniqueInput | OrderOnProductsWhereUniqueInput[]
    update?: OrderOnProductsUpdateWithWhereUniqueWithoutOrderInput | OrderOnProductsUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderOnProductsUpdateManyWithWhereWithoutOrderInput | OrderOnProductsUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderOnProductsScalarWhereInput | OrderOnProductsScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput
    upsert?: InvoiceUpsertWithoutOrderInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutOrderInput, InvoiceUpdateWithoutOrderInput>, InvoiceUncheckedUpdateWithoutOrderInput>
  }

  export type RoutesOnOrdersUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<RoutesOnOrdersCreateWithoutOrderInput, RoutesOnOrdersUncheckedCreateWithoutOrderInput> | RoutesOnOrdersCreateWithoutOrderInput[] | RoutesOnOrdersUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: RoutesOnOrdersCreateOrConnectWithoutOrderInput | RoutesOnOrdersCreateOrConnectWithoutOrderInput[]
    upsert?: RoutesOnOrdersUpsertWithWhereUniqueWithoutOrderInput | RoutesOnOrdersUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: RoutesOnOrdersCreateManyOrderInputEnvelope
    set?: RoutesOnOrdersWhereUniqueInput | RoutesOnOrdersWhereUniqueInput[]
    disconnect?: RoutesOnOrdersWhereUniqueInput | RoutesOnOrdersWhereUniqueInput[]
    delete?: RoutesOnOrdersWhereUniqueInput | RoutesOnOrdersWhereUniqueInput[]
    connect?: RoutesOnOrdersWhereUniqueInput | RoutesOnOrdersWhereUniqueInput[]
    update?: RoutesOnOrdersUpdateWithWhereUniqueWithoutOrderInput | RoutesOnOrdersUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: RoutesOnOrdersUpdateManyWithWhereWithoutOrderInput | RoutesOnOrdersUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: RoutesOnOrdersScalarWhereInput | RoutesOnOrdersScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<OrderCreateWithoutInvoiceInput, OrderUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInvoiceInput
    connect?: OrderWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutInvoiceNestedInput = {
    create?: XOR<OrderCreateWithoutInvoiceInput, OrderUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInvoiceInput
    upsert?: OrderUpsertWithoutInvoiceInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutInvoiceInput, OrderUpdateWithoutInvoiceInput>, OrderUncheckedUpdateWithoutInvoiceInput>
  }

  export type RoutesOnOrdersCreateNestedManyWithoutRouteInput = {
    create?: XOR<RoutesOnOrdersCreateWithoutRouteInput, RoutesOnOrdersUncheckedCreateWithoutRouteInput> | RoutesOnOrdersCreateWithoutRouteInput[] | RoutesOnOrdersUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RoutesOnOrdersCreateOrConnectWithoutRouteInput | RoutesOnOrdersCreateOrConnectWithoutRouteInput[]
    createMany?: RoutesOnOrdersCreateManyRouteInputEnvelope
    connect?: RoutesOnOrdersWhereUniqueInput | RoutesOnOrdersWhereUniqueInput[]
  }

  export type RoutesOnOrdersUncheckedCreateNestedManyWithoutRouteInput = {
    create?: XOR<RoutesOnOrdersCreateWithoutRouteInput, RoutesOnOrdersUncheckedCreateWithoutRouteInput> | RoutesOnOrdersCreateWithoutRouteInput[] | RoutesOnOrdersUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RoutesOnOrdersCreateOrConnectWithoutRouteInput | RoutesOnOrdersCreateOrConnectWithoutRouteInput[]
    createMany?: RoutesOnOrdersCreateManyRouteInputEnvelope
    connect?: RoutesOnOrdersWhereUniqueInput | RoutesOnOrdersWhereUniqueInput[]
  }

  export type RoutesOnOrdersUpdateManyWithoutRouteNestedInput = {
    create?: XOR<RoutesOnOrdersCreateWithoutRouteInput, RoutesOnOrdersUncheckedCreateWithoutRouteInput> | RoutesOnOrdersCreateWithoutRouteInput[] | RoutesOnOrdersUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RoutesOnOrdersCreateOrConnectWithoutRouteInput | RoutesOnOrdersCreateOrConnectWithoutRouteInput[]
    upsert?: RoutesOnOrdersUpsertWithWhereUniqueWithoutRouteInput | RoutesOnOrdersUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: RoutesOnOrdersCreateManyRouteInputEnvelope
    set?: RoutesOnOrdersWhereUniqueInput | RoutesOnOrdersWhereUniqueInput[]
    disconnect?: RoutesOnOrdersWhereUniqueInput | RoutesOnOrdersWhereUniqueInput[]
    delete?: RoutesOnOrdersWhereUniqueInput | RoutesOnOrdersWhereUniqueInput[]
    connect?: RoutesOnOrdersWhereUniqueInput | RoutesOnOrdersWhereUniqueInput[]
    update?: RoutesOnOrdersUpdateWithWhereUniqueWithoutRouteInput | RoutesOnOrdersUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: RoutesOnOrdersUpdateManyWithWhereWithoutRouteInput | RoutesOnOrdersUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: RoutesOnOrdersScalarWhereInput | RoutesOnOrdersScalarWhereInput[]
  }

  export type RoutesOnOrdersUncheckedUpdateManyWithoutRouteNestedInput = {
    create?: XOR<RoutesOnOrdersCreateWithoutRouteInput, RoutesOnOrdersUncheckedCreateWithoutRouteInput> | RoutesOnOrdersCreateWithoutRouteInput[] | RoutesOnOrdersUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RoutesOnOrdersCreateOrConnectWithoutRouteInput | RoutesOnOrdersCreateOrConnectWithoutRouteInput[]
    upsert?: RoutesOnOrdersUpsertWithWhereUniqueWithoutRouteInput | RoutesOnOrdersUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: RoutesOnOrdersCreateManyRouteInputEnvelope
    set?: RoutesOnOrdersWhereUniqueInput | RoutesOnOrdersWhereUniqueInput[]
    disconnect?: RoutesOnOrdersWhereUniqueInput | RoutesOnOrdersWhereUniqueInput[]
    delete?: RoutesOnOrdersWhereUniqueInput | RoutesOnOrdersWhereUniqueInput[]
    connect?: RoutesOnOrdersWhereUniqueInput | RoutesOnOrdersWhereUniqueInput[]
    update?: RoutesOnOrdersUpdateWithWhereUniqueWithoutRouteInput | RoutesOnOrdersUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: RoutesOnOrdersUpdateManyWithWhereWithoutRouteInput | RoutesOnOrdersUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: RoutesOnOrdersScalarWhereInput | RoutesOnOrdersScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<RoleCreateWithoutEmployeesInput, RoleUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutEmployeesInput
    connect?: RoleWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutEmployeesNestedInput = {
    create?: XOR<RoleCreateWithoutEmployeesInput, RoleUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutEmployeesInput
    upsert?: RoleUpsertWithoutEmployeesInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutEmployeesInput, RoleUpdateWithoutEmployeesInput>, RoleUncheckedUpdateWithoutEmployeesInput>
  }

  export type AddressCreateNestedOneWithoutSiteConfigInput = {
    create?: XOR<AddressCreateWithoutSiteConfigInput, AddressUncheckedCreateWithoutSiteConfigInput>
    connectOrCreate?: AddressCreateOrConnectWithoutSiteConfigInput
    connect?: AddressWhereUniqueInput
  }

  export type AddressUpdateOneRequiredWithoutSiteConfigNestedInput = {
    create?: XOR<AddressCreateWithoutSiteConfigInput, AddressUncheckedCreateWithoutSiteConfigInput>
    connectOrCreate?: AddressCreateOrConnectWithoutSiteConfigInput
    upsert?: AddressUpsertWithoutSiteConfigInput
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutSiteConfigInput, AddressUpdateWithoutSiteConfigInput>, AddressUncheckedUpdateWithoutSiteConfigInput>
  }

  export type ResourceActionCreateNestedManyWithoutActionInput = {
    create?: XOR<ResourceActionCreateWithoutActionInput, ResourceActionUncheckedCreateWithoutActionInput> | ResourceActionCreateWithoutActionInput[] | ResourceActionUncheckedCreateWithoutActionInput[]
    connectOrCreate?: ResourceActionCreateOrConnectWithoutActionInput | ResourceActionCreateOrConnectWithoutActionInput[]
    createMany?: ResourceActionCreateManyActionInputEnvelope
    connect?: ResourceActionWhereUniqueInput | ResourceActionWhereUniqueInput[]
  }

  export type ResourceActionUncheckedCreateNestedManyWithoutActionInput = {
    create?: XOR<ResourceActionCreateWithoutActionInput, ResourceActionUncheckedCreateWithoutActionInput> | ResourceActionCreateWithoutActionInput[] | ResourceActionUncheckedCreateWithoutActionInput[]
    connectOrCreate?: ResourceActionCreateOrConnectWithoutActionInput | ResourceActionCreateOrConnectWithoutActionInput[]
    createMany?: ResourceActionCreateManyActionInputEnvelope
    connect?: ResourceActionWhereUniqueInput | ResourceActionWhereUniqueInput[]
  }

  export type EnumActionsFieldUpdateOperationsInput = {
    set?: $Enums.Actions
  }

  export type ResourceActionUpdateManyWithoutActionNestedInput = {
    create?: XOR<ResourceActionCreateWithoutActionInput, ResourceActionUncheckedCreateWithoutActionInput> | ResourceActionCreateWithoutActionInput[] | ResourceActionUncheckedCreateWithoutActionInput[]
    connectOrCreate?: ResourceActionCreateOrConnectWithoutActionInput | ResourceActionCreateOrConnectWithoutActionInput[]
    upsert?: ResourceActionUpsertWithWhereUniqueWithoutActionInput | ResourceActionUpsertWithWhereUniqueWithoutActionInput[]
    createMany?: ResourceActionCreateManyActionInputEnvelope
    set?: ResourceActionWhereUniqueInput | ResourceActionWhereUniqueInput[]
    disconnect?: ResourceActionWhereUniqueInput | ResourceActionWhereUniqueInput[]
    delete?: ResourceActionWhereUniqueInput | ResourceActionWhereUniqueInput[]
    connect?: ResourceActionWhereUniqueInput | ResourceActionWhereUniqueInput[]
    update?: ResourceActionUpdateWithWhereUniqueWithoutActionInput | ResourceActionUpdateWithWhereUniqueWithoutActionInput[]
    updateMany?: ResourceActionUpdateManyWithWhereWithoutActionInput | ResourceActionUpdateManyWithWhereWithoutActionInput[]
    deleteMany?: ResourceActionScalarWhereInput | ResourceActionScalarWhereInput[]
  }

  export type ResourceActionUncheckedUpdateManyWithoutActionNestedInput = {
    create?: XOR<ResourceActionCreateWithoutActionInput, ResourceActionUncheckedCreateWithoutActionInput> | ResourceActionCreateWithoutActionInput[] | ResourceActionUncheckedCreateWithoutActionInput[]
    connectOrCreate?: ResourceActionCreateOrConnectWithoutActionInput | ResourceActionCreateOrConnectWithoutActionInput[]
    upsert?: ResourceActionUpsertWithWhereUniqueWithoutActionInput | ResourceActionUpsertWithWhereUniqueWithoutActionInput[]
    createMany?: ResourceActionCreateManyActionInputEnvelope
    set?: ResourceActionWhereUniqueInput | ResourceActionWhereUniqueInput[]
    disconnect?: ResourceActionWhereUniqueInput | ResourceActionWhereUniqueInput[]
    delete?: ResourceActionWhereUniqueInput | ResourceActionWhereUniqueInput[]
    connect?: ResourceActionWhereUniqueInput | ResourceActionWhereUniqueInput[]
    update?: ResourceActionUpdateWithWhereUniqueWithoutActionInput | ResourceActionUpdateWithWhereUniqueWithoutActionInput[]
    updateMany?: ResourceActionUpdateManyWithWhereWithoutActionInput | ResourceActionUpdateManyWithWhereWithoutActionInput[]
    deleteMany?: ResourceActionScalarWhereInput | ResourceActionScalarWhereInput[]
  }

  export type ResourceActionCreateNestedManyWithoutRessourceInput = {
    create?: XOR<ResourceActionCreateWithoutRessourceInput, ResourceActionUncheckedCreateWithoutRessourceInput> | ResourceActionCreateWithoutRessourceInput[] | ResourceActionUncheckedCreateWithoutRessourceInput[]
    connectOrCreate?: ResourceActionCreateOrConnectWithoutRessourceInput | ResourceActionCreateOrConnectWithoutRessourceInput[]
    createMany?: ResourceActionCreateManyRessourceInputEnvelope
    connect?: ResourceActionWhereUniqueInput | ResourceActionWhereUniqueInput[]
  }

  export type ResourceActionUncheckedCreateNestedManyWithoutRessourceInput = {
    create?: XOR<ResourceActionCreateWithoutRessourceInput, ResourceActionUncheckedCreateWithoutRessourceInput> | ResourceActionCreateWithoutRessourceInput[] | ResourceActionUncheckedCreateWithoutRessourceInput[]
    connectOrCreate?: ResourceActionCreateOrConnectWithoutRessourceInput | ResourceActionCreateOrConnectWithoutRessourceInput[]
    createMany?: ResourceActionCreateManyRessourceInputEnvelope
    connect?: ResourceActionWhereUniqueInput | ResourceActionWhereUniqueInput[]
  }

  export type EnumRessourcesFieldUpdateOperationsInput = {
    set?: $Enums.Ressources
  }

  export type ResourceActionUpdateManyWithoutRessourceNestedInput = {
    create?: XOR<ResourceActionCreateWithoutRessourceInput, ResourceActionUncheckedCreateWithoutRessourceInput> | ResourceActionCreateWithoutRessourceInput[] | ResourceActionUncheckedCreateWithoutRessourceInput[]
    connectOrCreate?: ResourceActionCreateOrConnectWithoutRessourceInput | ResourceActionCreateOrConnectWithoutRessourceInput[]
    upsert?: ResourceActionUpsertWithWhereUniqueWithoutRessourceInput | ResourceActionUpsertWithWhereUniqueWithoutRessourceInput[]
    createMany?: ResourceActionCreateManyRessourceInputEnvelope
    set?: ResourceActionWhereUniqueInput | ResourceActionWhereUniqueInput[]
    disconnect?: ResourceActionWhereUniqueInput | ResourceActionWhereUniqueInput[]
    delete?: ResourceActionWhereUniqueInput | ResourceActionWhereUniqueInput[]
    connect?: ResourceActionWhereUniqueInput | ResourceActionWhereUniqueInput[]
    update?: ResourceActionUpdateWithWhereUniqueWithoutRessourceInput | ResourceActionUpdateWithWhereUniqueWithoutRessourceInput[]
    updateMany?: ResourceActionUpdateManyWithWhereWithoutRessourceInput | ResourceActionUpdateManyWithWhereWithoutRessourceInput[]
    deleteMany?: ResourceActionScalarWhereInput | ResourceActionScalarWhereInput[]
  }

  export type ResourceActionUncheckedUpdateManyWithoutRessourceNestedInput = {
    create?: XOR<ResourceActionCreateWithoutRessourceInput, ResourceActionUncheckedCreateWithoutRessourceInput> | ResourceActionCreateWithoutRessourceInput[] | ResourceActionUncheckedCreateWithoutRessourceInput[]
    connectOrCreate?: ResourceActionCreateOrConnectWithoutRessourceInput | ResourceActionCreateOrConnectWithoutRessourceInput[]
    upsert?: ResourceActionUpsertWithWhereUniqueWithoutRessourceInput | ResourceActionUpsertWithWhereUniqueWithoutRessourceInput[]
    createMany?: ResourceActionCreateManyRessourceInputEnvelope
    set?: ResourceActionWhereUniqueInput | ResourceActionWhereUniqueInput[]
    disconnect?: ResourceActionWhereUniqueInput | ResourceActionWhereUniqueInput[]
    delete?: ResourceActionWhereUniqueInput | ResourceActionWhereUniqueInput[]
    connect?: ResourceActionWhereUniqueInput | ResourceActionWhereUniqueInput[]
    update?: ResourceActionUpdateWithWhereUniqueWithoutRessourceInput | ResourceActionUpdateWithWhereUniqueWithoutRessourceInput[]
    updateMany?: ResourceActionUpdateManyWithWhereWithoutRessourceInput | ResourceActionUpdateManyWithWhereWithoutRessourceInput[]
    deleteMany?: ResourceActionScalarWhereInput | ResourceActionScalarWhereInput[]
  }

  export type ActionCreateNestedOneWithoutResourceLinksInput = {
    create?: XOR<ActionCreateWithoutResourceLinksInput, ActionUncheckedCreateWithoutResourceLinksInput>
    connectOrCreate?: ActionCreateOrConnectWithoutResourceLinksInput
    connect?: ActionWhereUniqueInput
  }

  export type RessourceCreateNestedOneWithoutActionLinksInput = {
    create?: XOR<RessourceCreateWithoutActionLinksInput, RessourceUncheckedCreateWithoutActionLinksInput>
    connectOrCreate?: RessourceCreateOrConnectWithoutActionLinksInput
    connect?: RessourceWhereUniqueInput
  }

  export type PermissionCreateNestedManyWithoutResourceActionInput = {
    create?: XOR<PermissionCreateWithoutResourceActionInput, PermissionUncheckedCreateWithoutResourceActionInput> | PermissionCreateWithoutResourceActionInput[] | PermissionUncheckedCreateWithoutResourceActionInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutResourceActionInput | PermissionCreateOrConnectWithoutResourceActionInput[]
    createMany?: PermissionCreateManyResourceActionInputEnvelope
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type PermissionUncheckedCreateNestedManyWithoutResourceActionInput = {
    create?: XOR<PermissionCreateWithoutResourceActionInput, PermissionUncheckedCreateWithoutResourceActionInput> | PermissionCreateWithoutResourceActionInput[] | PermissionUncheckedCreateWithoutResourceActionInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutResourceActionInput | PermissionCreateOrConnectWithoutResourceActionInput[]
    createMany?: PermissionCreateManyResourceActionInputEnvelope
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type ActionUpdateOneRequiredWithoutResourceLinksNestedInput = {
    create?: XOR<ActionCreateWithoutResourceLinksInput, ActionUncheckedCreateWithoutResourceLinksInput>
    connectOrCreate?: ActionCreateOrConnectWithoutResourceLinksInput
    upsert?: ActionUpsertWithoutResourceLinksInput
    connect?: ActionWhereUniqueInput
    update?: XOR<XOR<ActionUpdateToOneWithWhereWithoutResourceLinksInput, ActionUpdateWithoutResourceLinksInput>, ActionUncheckedUpdateWithoutResourceLinksInput>
  }

  export type RessourceUpdateOneRequiredWithoutActionLinksNestedInput = {
    create?: XOR<RessourceCreateWithoutActionLinksInput, RessourceUncheckedCreateWithoutActionLinksInput>
    connectOrCreate?: RessourceCreateOrConnectWithoutActionLinksInput
    upsert?: RessourceUpsertWithoutActionLinksInput
    connect?: RessourceWhereUniqueInput
    update?: XOR<XOR<RessourceUpdateToOneWithWhereWithoutActionLinksInput, RessourceUpdateWithoutActionLinksInput>, RessourceUncheckedUpdateWithoutActionLinksInput>
  }

  export type PermissionUpdateManyWithoutResourceActionNestedInput = {
    create?: XOR<PermissionCreateWithoutResourceActionInput, PermissionUncheckedCreateWithoutResourceActionInput> | PermissionCreateWithoutResourceActionInput[] | PermissionUncheckedCreateWithoutResourceActionInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutResourceActionInput | PermissionCreateOrConnectWithoutResourceActionInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutResourceActionInput | PermissionUpsertWithWhereUniqueWithoutResourceActionInput[]
    createMany?: PermissionCreateManyResourceActionInputEnvelope
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutResourceActionInput | PermissionUpdateWithWhereUniqueWithoutResourceActionInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutResourceActionInput | PermissionUpdateManyWithWhereWithoutResourceActionInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type PermissionUncheckedUpdateManyWithoutResourceActionNestedInput = {
    create?: XOR<PermissionCreateWithoutResourceActionInput, PermissionUncheckedCreateWithoutResourceActionInput> | PermissionCreateWithoutResourceActionInput[] | PermissionUncheckedCreateWithoutResourceActionInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutResourceActionInput | PermissionCreateOrConnectWithoutResourceActionInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutResourceActionInput | PermissionUpsertWithWhereUniqueWithoutResourceActionInput[]
    createMany?: PermissionCreateManyResourceActionInputEnvelope
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutResourceActionInput | PermissionUpdateWithWhereUniqueWithoutResourceActionInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutResourceActionInput | PermissionUpdateManyWithWhereWithoutResourceActionInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type EmployeesCreateNestedManyWithoutRoleInput = {
    create?: XOR<EmployeesCreateWithoutRoleInput, EmployeesUncheckedCreateWithoutRoleInput> | EmployeesCreateWithoutRoleInput[] | EmployeesUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: EmployeesCreateOrConnectWithoutRoleInput | EmployeesCreateOrConnectWithoutRoleInput[]
    createMany?: EmployeesCreateManyRoleInputEnvelope
    connect?: EmployeesWhereUniqueInput | EmployeesWhereUniqueInput[]
  }

  export type PermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<PermissionCreateWithoutRoleInput, PermissionUncheckedCreateWithoutRoleInput> | PermissionCreateWithoutRoleInput[] | PermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutRoleInput | PermissionCreateOrConnectWithoutRoleInput[]
    createMany?: PermissionCreateManyRoleInputEnvelope
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type EmployeesUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<EmployeesCreateWithoutRoleInput, EmployeesUncheckedCreateWithoutRoleInput> | EmployeesCreateWithoutRoleInput[] | EmployeesUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: EmployeesCreateOrConnectWithoutRoleInput | EmployeesCreateOrConnectWithoutRoleInput[]
    createMany?: EmployeesCreateManyRoleInputEnvelope
    connect?: EmployeesWhereUniqueInput | EmployeesWhereUniqueInput[]
  }

  export type PermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<PermissionCreateWithoutRoleInput, PermissionUncheckedCreateWithoutRoleInput> | PermissionCreateWithoutRoleInput[] | PermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutRoleInput | PermissionCreateOrConnectWithoutRoleInput[]
    createMany?: PermissionCreateManyRoleInputEnvelope
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type EmployeesUpdateManyWithoutRoleNestedInput = {
    create?: XOR<EmployeesCreateWithoutRoleInput, EmployeesUncheckedCreateWithoutRoleInput> | EmployeesCreateWithoutRoleInput[] | EmployeesUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: EmployeesCreateOrConnectWithoutRoleInput | EmployeesCreateOrConnectWithoutRoleInput[]
    upsert?: EmployeesUpsertWithWhereUniqueWithoutRoleInput | EmployeesUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: EmployeesCreateManyRoleInputEnvelope
    set?: EmployeesWhereUniqueInput | EmployeesWhereUniqueInput[]
    disconnect?: EmployeesWhereUniqueInput | EmployeesWhereUniqueInput[]
    delete?: EmployeesWhereUniqueInput | EmployeesWhereUniqueInput[]
    connect?: EmployeesWhereUniqueInput | EmployeesWhereUniqueInput[]
    update?: EmployeesUpdateWithWhereUniqueWithoutRoleInput | EmployeesUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: EmployeesUpdateManyWithWhereWithoutRoleInput | EmployeesUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: EmployeesScalarWhereInput | EmployeesScalarWhereInput[]
  }

  export type PermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<PermissionCreateWithoutRoleInput, PermissionUncheckedCreateWithoutRoleInput> | PermissionCreateWithoutRoleInput[] | PermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutRoleInput | PermissionCreateOrConnectWithoutRoleInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutRoleInput | PermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: PermissionCreateManyRoleInputEnvelope
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutRoleInput | PermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutRoleInput | PermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type EmployeesUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<EmployeesCreateWithoutRoleInput, EmployeesUncheckedCreateWithoutRoleInput> | EmployeesCreateWithoutRoleInput[] | EmployeesUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: EmployeesCreateOrConnectWithoutRoleInput | EmployeesCreateOrConnectWithoutRoleInput[]
    upsert?: EmployeesUpsertWithWhereUniqueWithoutRoleInput | EmployeesUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: EmployeesCreateManyRoleInputEnvelope
    set?: EmployeesWhereUniqueInput | EmployeesWhereUniqueInput[]
    disconnect?: EmployeesWhereUniqueInput | EmployeesWhereUniqueInput[]
    delete?: EmployeesWhereUniqueInput | EmployeesWhereUniqueInput[]
    connect?: EmployeesWhereUniqueInput | EmployeesWhereUniqueInput[]
    update?: EmployeesUpdateWithWhereUniqueWithoutRoleInput | EmployeesUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: EmployeesUpdateManyWithWhereWithoutRoleInput | EmployeesUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: EmployeesScalarWhereInput | EmployeesScalarWhereInput[]
  }

  export type PermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<PermissionCreateWithoutRoleInput, PermissionUncheckedCreateWithoutRoleInput> | PermissionCreateWithoutRoleInput[] | PermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutRoleInput | PermissionCreateOrConnectWithoutRoleInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutRoleInput | PermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: PermissionCreateManyRoleInputEnvelope
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutRoleInput | PermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutRoleInput | PermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
  }

  export type ResourceActionCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<ResourceActionCreateWithoutPermissionsInput, ResourceActionUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: ResourceActionCreateOrConnectWithoutPermissionsInput
    connect?: ResourceActionWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    upsert?: RoleUpsertWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutPermissionsInput, RoleUpdateWithoutPermissionsInput>, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type ResourceActionUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<ResourceActionCreateWithoutPermissionsInput, ResourceActionUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: ResourceActionCreateOrConnectWithoutPermissionsInput
    upsert?: ResourceActionUpsertWithoutPermissionsInput
    connect?: ResourceActionWhereUniqueInput
    update?: XOR<XOR<ResourceActionUpdateToOneWithWhereWithoutPermissionsInput, ResourceActionUpdateWithoutPermissionsInput>, ResourceActionUncheckedUpdateWithoutPermissionsInput>
  }

  export type CartCreateNestedOneWithoutProductsInput = {
    create?: XOR<CartCreateWithoutProductsInput, CartUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CartCreateOrConnectWithoutProductsInput
    connect?: CartWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutCartsInput = {
    create?: XOR<ProductCreateWithoutCartsInput, ProductUncheckedCreateWithoutCartsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCartsInput
    connect?: ProductWhereUniqueInput
  }

  export type CartUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<CartCreateWithoutProductsInput, CartUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CartCreateOrConnectWithoutProductsInput
    upsert?: CartUpsertWithoutProductsInput
    connect?: CartWhereUniqueInput
    update?: XOR<XOR<CartUpdateToOneWithWhereWithoutProductsInput, CartUpdateWithoutProductsInput>, CartUncheckedUpdateWithoutProductsInput>
  }

  export type ProductUpdateOneRequiredWithoutCartsNestedInput = {
    create?: XOR<ProductCreateWithoutCartsInput, ProductUncheckedCreateWithoutCartsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCartsInput
    upsert?: ProductUpsertWithoutCartsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutCartsInput, ProductUpdateWithoutCartsInput>, ProductUncheckedUpdateWithoutCartsInput>
  }

  export type OrderCreateNestedOneWithoutProductsInput = {
    create?: XOR<OrderCreateWithoutProductsInput, OrderUncheckedCreateWithoutProductsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutProductsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrdersInput = {
    create?: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrdersInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<OrderCreateWithoutProductsInput, OrderUncheckedCreateWithoutProductsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutProductsInput
    upsert?: OrderUpsertWithoutProductsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutProductsInput, OrderUpdateWithoutProductsInput>, OrderUncheckedUpdateWithoutProductsInput>
  }

  export type ProductUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrdersInput
    upsert?: ProductUpsertWithoutOrdersInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrdersInput, ProductUpdateWithoutOrdersInput>, ProductUncheckedUpdateWithoutOrdersInput>
  }

  export type RouteCreateNestedOneWithoutOrderInput = {
    create?: XOR<RouteCreateWithoutOrderInput, RouteUncheckedCreateWithoutOrderInput>
    connectOrCreate?: RouteCreateOrConnectWithoutOrderInput
    connect?: RouteWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutRouteInput = {
    create?: XOR<OrderCreateWithoutRouteInput, OrderUncheckedCreateWithoutRouteInput>
    connectOrCreate?: OrderCreateOrConnectWithoutRouteInput
    connect?: OrderWhereUniqueInput
  }

  export type RouteUpdateOneRequiredWithoutOrderNestedInput = {
    create?: XOR<RouteCreateWithoutOrderInput, RouteUncheckedCreateWithoutOrderInput>
    connectOrCreate?: RouteCreateOrConnectWithoutOrderInput
    upsert?: RouteUpsertWithoutOrderInput
    connect?: RouteWhereUniqueInput
    update?: XOR<XOR<RouteUpdateToOneWithWhereWithoutOrderInput, RouteUpdateWithoutOrderInput>, RouteUncheckedUpdateWithoutOrderInput>
  }

  export type OrderUpdateOneRequiredWithoutRouteNestedInput = {
    create?: XOR<OrderCreateWithoutRouteInput, OrderUncheckedCreateWithoutRouteInput>
    connectOrCreate?: OrderCreateOrConnectWithoutRouteInput
    upsert?: OrderUpsertWithoutRouteInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutRouteInput, OrderUpdateWithoutRouteInput>, OrderUncheckedUpdateWithoutRouteInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumBusinessSectorNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessSector | EnumBusinessSectorFieldRefInput<$PrismaModel> | null
    in?: $Enums.BusinessSector[] | ListEnumBusinessSectorFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BusinessSector[] | ListEnumBusinessSectorFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBusinessSectorNullableFilter<$PrismaModel> | $Enums.BusinessSector | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumBusinessSectorNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessSector | EnumBusinessSectorFieldRefInput<$PrismaModel> | null
    in?: $Enums.BusinessSector[] | ListEnumBusinessSectorFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BusinessSector[] | ListEnumBusinessSectorFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBusinessSectorNullableWithAggregatesFilter<$PrismaModel> | $Enums.BusinessSector | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBusinessSectorNullableFilter<$PrismaModel>
    _max?: NestedEnumBusinessSectorNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumOrderStateFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderState | EnumOrderStateFieldRefInput<$PrismaModel>
    in?: $Enums.OrderState[] | ListEnumOrderStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderState[] | ListEnumOrderStateFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStateFilter<$PrismaModel> | $Enums.OrderState
  }

  export type NestedEnumOrderStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderState | EnumOrderStateFieldRefInput<$PrismaModel>
    in?: $Enums.OrderState[] | ListEnumOrderStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderState[] | ListEnumOrderStateFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStateWithAggregatesFilter<$PrismaModel> | $Enums.OrderState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStateFilter<$PrismaModel>
    _max?: NestedEnumOrderStateFilter<$PrismaModel>
  }

  export type NestedEnumActionsFilter<$PrismaModel = never> = {
    equals?: $Enums.Actions | EnumActionsFieldRefInput<$PrismaModel>
    in?: $Enums.Actions[] | ListEnumActionsFieldRefInput<$PrismaModel>
    notIn?: $Enums.Actions[] | ListEnumActionsFieldRefInput<$PrismaModel>
    not?: NestedEnumActionsFilter<$PrismaModel> | $Enums.Actions
  }

  export type NestedEnumActionsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Actions | EnumActionsFieldRefInput<$PrismaModel>
    in?: $Enums.Actions[] | ListEnumActionsFieldRefInput<$PrismaModel>
    notIn?: $Enums.Actions[] | ListEnumActionsFieldRefInput<$PrismaModel>
    not?: NestedEnumActionsWithAggregatesFilter<$PrismaModel> | $Enums.Actions
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionsFilter<$PrismaModel>
    _max?: NestedEnumActionsFilter<$PrismaModel>
  }

  export type NestedEnumRessourcesFilter<$PrismaModel = never> = {
    equals?: $Enums.Ressources | EnumRessourcesFieldRefInput<$PrismaModel>
    in?: $Enums.Ressources[] | ListEnumRessourcesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Ressources[] | ListEnumRessourcesFieldRefInput<$PrismaModel>
    not?: NestedEnumRessourcesFilter<$PrismaModel> | $Enums.Ressources
  }

  export type NestedEnumRessourcesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Ressources | EnumRessourcesFieldRefInput<$PrismaModel>
    in?: $Enums.Ressources[] | ListEnumRessourcesFieldRefInput<$PrismaModel>
    notIn?: $Enums.Ressources[] | ListEnumRessourcesFieldRefInput<$PrismaModel>
    not?: NestedEnumRessourcesWithAggregatesFilter<$PrismaModel> | $Enums.Ressources
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRessourcesFilter<$PrismaModel>
    _max?: NestedEnumRessourcesFilter<$PrismaModel>
  }

  export type AddressCreateWithoutCustomersInput = {
    addressId?: string
    city: string
    country: string
    postCode: string
    state: string
    streetName: string
    streetNumber: string
    modifiedAt?: Date | string | null
    deleted?: boolean
    siteConfig?: SiteConfigCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutCustomersInput = {
    addressId?: string
    city: string
    country: string
    postCode: string
    state: string
    streetName: string
    streetNumber: string
    modifiedAt?: Date | string | null
    deleted?: boolean
    siteConfig?: SiteConfigUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutCustomersInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutCustomersInput, AddressUncheckedCreateWithoutCustomersInput>
  }

  export type CartCreateWithoutCustomerInput = {
    cartId?: string
    products?: CartOnProductsCreateNestedManyWithoutCartInput
  }

  export type CartUncheckedCreateWithoutCustomerInput = {
    cartId?: string
    products?: CartOnProductsUncheckedCreateNestedManyWithoutCartInput
  }

  export type CartCreateOrConnectWithoutCustomerInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutCustomerInput, CartUncheckedCreateWithoutCustomerInput>
  }

  export type OrderCreateWithoutCustomerInput = {
    orderId?: string
    orderDate?: Date | string
    deliveryDate?: Date | string | null
    deleted?: boolean
    orderState?: $Enums.OrderState
    selfCollect?: boolean
    products?: OrderOnProductsCreateNestedManyWithoutOrderInput
    invoice?: InvoiceCreateNestedOneWithoutOrderInput
    route?: RoutesOnOrdersCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCustomerInput = {
    orderId?: string
    orderDate?: Date | string
    deliveryDate?: Date | string | null
    deleted?: boolean
    orderState?: $Enums.OrderState
    selfCollect?: boolean
    products?: OrderOnProductsUncheckedCreateNestedManyWithoutOrderInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutOrderInput
    route?: RoutesOnOrdersUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderCreateManyCustomerInputEnvelope = {
    data: OrderCreateManyCustomerInput | OrderCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerHistoryCreateWithoutCustomerInput = {
    historyId?: string
    email: string
    phoneNumber: string
    password: string
    firstName?: string | null
    lastName: string
    companyNumber?: string | null
    modifiedAt?: Date | string | null
    deleted?: boolean
    signedUp?: Date | string
    avatarPath?: string | null
    addressId: string
    businessSector?: $Enums.BusinessSector | null
  }

  export type CustomerHistoryUncheckedCreateWithoutCustomerInput = {
    historyId?: string
    email: string
    phoneNumber: string
    password: string
    firstName?: string | null
    lastName: string
    companyNumber?: string | null
    modifiedAt?: Date | string | null
    deleted?: boolean
    signedUp?: Date | string
    avatarPath?: string | null
    addressId: string
    businessSector?: $Enums.BusinessSector | null
  }

  export type CustomerHistoryCreateOrConnectWithoutCustomerInput = {
    where: CustomerHistoryWhereUniqueInput
    create: XOR<CustomerHistoryCreateWithoutCustomerInput, CustomerHistoryUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerHistoryCreateManyCustomerInputEnvelope = {
    data: CustomerHistoryCreateManyCustomerInput | CustomerHistoryCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithoutCustomersInput = {
    update: XOR<AddressUpdateWithoutCustomersInput, AddressUncheckedUpdateWithoutCustomersInput>
    create: XOR<AddressCreateWithoutCustomersInput, AddressUncheckedCreateWithoutCustomersInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutCustomersInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutCustomersInput, AddressUncheckedUpdateWithoutCustomersInput>
  }

  export type AddressUpdateWithoutCustomersInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    streetName?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    siteConfig?: SiteConfigUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutCustomersInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    streetName?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    siteConfig?: SiteConfigUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type CartUpsertWithoutCustomerInput = {
    update: XOR<CartUpdateWithoutCustomerInput, CartUncheckedUpdateWithoutCustomerInput>
    create: XOR<CartCreateWithoutCustomerInput, CartUncheckedCreateWithoutCustomerInput>
    where?: CartWhereInput
  }

  export type CartUpdateToOneWithWhereWithoutCustomerInput = {
    where?: CartWhereInput
    data: XOR<CartUpdateWithoutCustomerInput, CartUncheckedUpdateWithoutCustomerInput>
  }

  export type CartUpdateWithoutCustomerInput = {
    cartId?: StringFieldUpdateOperationsInput | string
    products?: CartOnProductsUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateWithoutCustomerInput = {
    cartId?: StringFieldUpdateOperationsInput | string
    products?: CartOnProductsUncheckedUpdateManyWithoutCartNestedInput
  }

  export type OrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUpdateManyWithWhereWithoutCustomerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    orderId?: UuidFilter<"Order"> | string
    customerReference?: IntFilter<"Order"> | number
    orderDate?: DateTimeFilter<"Order"> | Date | string
    deliveryDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    deleted?: BoolFilter<"Order"> | boolean
    orderState?: EnumOrderStateFilter<"Order"> | $Enums.OrderState
    selfCollect?: BoolFilter<"Order"> | boolean
  }

  export type CustomerHistoryUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerHistoryWhereUniqueInput
    update: XOR<CustomerHistoryUpdateWithoutCustomerInput, CustomerHistoryUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerHistoryCreateWithoutCustomerInput, CustomerHistoryUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerHistoryUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerHistoryWhereUniqueInput
    data: XOR<CustomerHistoryUpdateWithoutCustomerInput, CustomerHistoryUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerHistoryUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerHistoryScalarWhereInput
    data: XOR<CustomerHistoryUpdateManyMutationInput, CustomerHistoryUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerHistoryScalarWhereInput = {
    AND?: CustomerHistoryScalarWhereInput | CustomerHistoryScalarWhereInput[]
    OR?: CustomerHistoryScalarWhereInput[]
    NOT?: CustomerHistoryScalarWhereInput | CustomerHistoryScalarWhereInput[]
    historyId?: UuidFilter<"CustomerHistory"> | string
    customerReference?: IntFilter<"CustomerHistory"> | number
    email?: StringFilter<"CustomerHistory"> | string
    phoneNumber?: StringFilter<"CustomerHistory"> | string
    password?: StringFilter<"CustomerHistory"> | string
    firstName?: StringNullableFilter<"CustomerHistory"> | string | null
    lastName?: StringFilter<"CustomerHistory"> | string
    companyNumber?: StringNullableFilter<"CustomerHistory"> | string | null
    modifiedAt?: DateTimeNullableFilter<"CustomerHistory"> | Date | string | null
    deleted?: BoolFilter<"CustomerHistory"> | boolean
    signedUp?: DateTimeFilter<"CustomerHistory"> | Date | string
    avatarPath?: StringNullableFilter<"CustomerHistory"> | string | null
    addressId?: UuidFilter<"CustomerHistory"> | string
    businessSector?: EnumBusinessSectorNullableFilter<"CustomerHistory"> | $Enums.BusinessSector | null
  }

  export type CustomerCreateWithoutHistoryInput = {
    customerId?: string
    customerReference: number
    email: string
    phoneNumber: string
    password: string
    firstName?: string | null
    lastName: string
    companyNumber?: string | null
    modifiedAt?: Date | string | null
    deleted?: boolean
    signedUp?: Date | string
    avatarPath?: string | null
    businessSector?: $Enums.BusinessSector | null
    address: AddressCreateNestedOneWithoutCustomersInput
    cart?: CartCreateNestedOneWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutHistoryInput = {
    customerId?: string
    customerReference: number
    email: string
    phoneNumber: string
    password: string
    firstName?: string | null
    lastName: string
    companyNumber?: string | null
    modifiedAt?: Date | string | null
    deleted?: boolean
    signedUp?: Date | string
    avatarPath?: string | null
    addressId: string
    businessSector?: $Enums.BusinessSector | null
    cart?: CartUncheckedCreateNestedOneWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutHistoryInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutHistoryInput, CustomerUncheckedCreateWithoutHistoryInput>
  }

  export type CustomerUpsertWithoutHistoryInput = {
    update: XOR<CustomerUpdateWithoutHistoryInput, CustomerUncheckedUpdateWithoutHistoryInput>
    create: XOR<CustomerCreateWithoutHistoryInput, CustomerUncheckedCreateWithoutHistoryInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutHistoryInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutHistoryInput, CustomerUncheckedUpdateWithoutHistoryInput>
  }

  export type CustomerUpdateWithoutHistoryInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    customerReference?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    signedUp?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    businessSector?: NullableEnumBusinessSectorFieldUpdateOperationsInput | $Enums.BusinessSector | null
    address?: AddressUpdateOneRequiredWithoutCustomersNestedInput
    cart?: CartUpdateOneWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutHistoryInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    customerReference?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    signedUp?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: StringFieldUpdateOperationsInput | string
    businessSector?: NullableEnumBusinessSectorFieldUpdateOperationsInput | $Enums.BusinessSector | null
    cart?: CartUncheckedUpdateOneWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateWithoutCartInput = {
    customerId?: string
    customerReference: number
    email: string
    phoneNumber: string
    password: string
    firstName?: string | null
    lastName: string
    companyNumber?: string | null
    modifiedAt?: Date | string | null
    deleted?: boolean
    signedUp?: Date | string
    avatarPath?: string | null
    businessSector?: $Enums.BusinessSector | null
    address: AddressCreateNestedOneWithoutCustomersInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    history?: CustomerHistoryCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCartInput = {
    customerId?: string
    customerReference: number
    email: string
    phoneNumber: string
    password: string
    firstName?: string | null
    lastName: string
    companyNumber?: string | null
    modifiedAt?: Date | string | null
    deleted?: boolean
    signedUp?: Date | string
    avatarPath?: string | null
    addressId: string
    businessSector?: $Enums.BusinessSector | null
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    history?: CustomerHistoryUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCartInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCartInput, CustomerUncheckedCreateWithoutCartInput>
  }

  export type CartOnProductsCreateWithoutCartInput = {
    quantity?: number
    product: ProductCreateNestedOneWithoutCartsInput
  }

  export type CartOnProductsUncheckedCreateWithoutCartInput = {
    productId: string
    quantity?: number
  }

  export type CartOnProductsCreateOrConnectWithoutCartInput = {
    where: CartOnProductsWhereUniqueInput
    create: XOR<CartOnProductsCreateWithoutCartInput, CartOnProductsUncheckedCreateWithoutCartInput>
  }

  export type CartOnProductsCreateManyCartInputEnvelope = {
    data: CartOnProductsCreateManyCartInput | CartOnProductsCreateManyCartInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutCartInput = {
    update: XOR<CustomerUpdateWithoutCartInput, CustomerUncheckedUpdateWithoutCartInput>
    create: XOR<CustomerCreateWithoutCartInput, CustomerUncheckedCreateWithoutCartInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutCartInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutCartInput, CustomerUncheckedUpdateWithoutCartInput>
  }

  export type CustomerUpdateWithoutCartInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    customerReference?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    signedUp?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    businessSector?: NullableEnumBusinessSectorFieldUpdateOperationsInput | $Enums.BusinessSector | null
    address?: AddressUpdateOneRequiredWithoutCustomersNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    history?: CustomerHistoryUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCartInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    customerReference?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    signedUp?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: StringFieldUpdateOperationsInput | string
    businessSector?: NullableEnumBusinessSectorFieldUpdateOperationsInput | $Enums.BusinessSector | null
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    history?: CustomerHistoryUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CartOnProductsUpsertWithWhereUniqueWithoutCartInput = {
    where: CartOnProductsWhereUniqueInput
    update: XOR<CartOnProductsUpdateWithoutCartInput, CartOnProductsUncheckedUpdateWithoutCartInput>
    create: XOR<CartOnProductsCreateWithoutCartInput, CartOnProductsUncheckedCreateWithoutCartInput>
  }

  export type CartOnProductsUpdateWithWhereUniqueWithoutCartInput = {
    where: CartOnProductsWhereUniqueInput
    data: XOR<CartOnProductsUpdateWithoutCartInput, CartOnProductsUncheckedUpdateWithoutCartInput>
  }

  export type CartOnProductsUpdateManyWithWhereWithoutCartInput = {
    where: CartOnProductsScalarWhereInput
    data: XOR<CartOnProductsUpdateManyMutationInput, CartOnProductsUncheckedUpdateManyWithoutCartInput>
  }

  export type CartOnProductsScalarWhereInput = {
    AND?: CartOnProductsScalarWhereInput | CartOnProductsScalarWhereInput[]
    OR?: CartOnProductsScalarWhereInput[]
    NOT?: CartOnProductsScalarWhereInput | CartOnProductsScalarWhereInput[]
    cartId?: UuidFilter<"CartOnProducts"> | string
    productId?: UuidFilter<"CartOnProducts"> | string
    quantity?: IntFilter<"CartOnProducts"> | number
  }

  export type CustomerCreateWithoutAddressInput = {
    customerId?: string
    customerReference: number
    email: string
    phoneNumber: string
    password: string
    firstName?: string | null
    lastName: string
    companyNumber?: string | null
    modifiedAt?: Date | string | null
    deleted?: boolean
    signedUp?: Date | string
    avatarPath?: string | null
    businessSector?: $Enums.BusinessSector | null
    cart?: CartCreateNestedOneWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    history?: CustomerHistoryCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutAddressInput = {
    customerId?: string
    customerReference: number
    email: string
    phoneNumber: string
    password: string
    firstName?: string | null
    lastName: string
    companyNumber?: string | null
    modifiedAt?: Date | string | null
    deleted?: boolean
    signedUp?: Date | string
    avatarPath?: string | null
    businessSector?: $Enums.BusinessSector | null
    cart?: CartUncheckedCreateNestedOneWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    history?: CustomerHistoryUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutAddressInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutAddressInput, CustomerUncheckedCreateWithoutAddressInput>
  }

  export type CustomerCreateManyAddressInputEnvelope = {
    data: CustomerCreateManyAddressInput | CustomerCreateManyAddressInput[]
    skipDuplicates?: boolean
  }

  export type SiteConfigCreateWithoutAddressInput = {
    siteConfigId?: string
    companyName: string
    logoPath: string
    email: string
    phoneNumber: string
    iban: string
    companyNumber: string
    modifiedAt?: Date | string | null
    isPremium?: boolean
    deleted?: boolean
    stripeCustomerId?: string | null
    stripeAccountId?: string | null
    stripeConfigured?: boolean
  }

  export type SiteConfigUncheckedCreateWithoutAddressInput = {
    siteConfigId?: string
    companyName: string
    logoPath: string
    email: string
    phoneNumber: string
    iban: string
    companyNumber: string
    modifiedAt?: Date | string | null
    isPremium?: boolean
    deleted?: boolean
    stripeCustomerId?: string | null
    stripeAccountId?: string | null
    stripeConfigured?: boolean
  }

  export type SiteConfigCreateOrConnectWithoutAddressInput = {
    where: SiteConfigWhereUniqueInput
    create: XOR<SiteConfigCreateWithoutAddressInput, SiteConfigUncheckedCreateWithoutAddressInput>
  }

  export type SiteConfigCreateManyAddressInputEnvelope = {
    data: SiteConfigCreateManyAddressInput | SiteConfigCreateManyAddressInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithWhereUniqueWithoutAddressInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutAddressInput, CustomerUncheckedUpdateWithoutAddressInput>
    create: XOR<CustomerCreateWithoutAddressInput, CustomerUncheckedCreateWithoutAddressInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutAddressInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutAddressInput, CustomerUncheckedUpdateWithoutAddressInput>
  }

  export type CustomerUpdateManyWithWhereWithoutAddressInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutAddressInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    customerId?: UuidFilter<"Customer"> | string
    customerReference?: IntFilter<"Customer"> | number
    email?: StringFilter<"Customer"> | string
    phoneNumber?: StringFilter<"Customer"> | string
    password?: StringFilter<"Customer"> | string
    firstName?: StringNullableFilter<"Customer"> | string | null
    lastName?: StringFilter<"Customer"> | string
    companyNumber?: StringNullableFilter<"Customer"> | string | null
    modifiedAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    deleted?: BoolFilter<"Customer"> | boolean
    signedUp?: DateTimeFilter<"Customer"> | Date | string
    avatarPath?: StringNullableFilter<"Customer"> | string | null
    addressId?: UuidFilter<"Customer"> | string
    businessSector?: EnumBusinessSectorNullableFilter<"Customer"> | $Enums.BusinessSector | null
  }

  export type SiteConfigUpsertWithWhereUniqueWithoutAddressInput = {
    where: SiteConfigWhereUniqueInput
    update: XOR<SiteConfigUpdateWithoutAddressInput, SiteConfigUncheckedUpdateWithoutAddressInput>
    create: XOR<SiteConfigCreateWithoutAddressInput, SiteConfigUncheckedCreateWithoutAddressInput>
  }

  export type SiteConfigUpdateWithWhereUniqueWithoutAddressInput = {
    where: SiteConfigWhereUniqueInput
    data: XOR<SiteConfigUpdateWithoutAddressInput, SiteConfigUncheckedUpdateWithoutAddressInput>
  }

  export type SiteConfigUpdateManyWithWhereWithoutAddressInput = {
    where: SiteConfigScalarWhereInput
    data: XOR<SiteConfigUpdateManyMutationInput, SiteConfigUncheckedUpdateManyWithoutAddressInput>
  }

  export type SiteConfigScalarWhereInput = {
    AND?: SiteConfigScalarWhereInput | SiteConfigScalarWhereInput[]
    OR?: SiteConfigScalarWhereInput[]
    NOT?: SiteConfigScalarWhereInput | SiteConfigScalarWhereInput[]
    siteConfigId?: UuidFilter<"SiteConfig"> | string
    companyName?: StringFilter<"SiteConfig"> | string
    logoPath?: StringFilter<"SiteConfig"> | string
    email?: StringFilter<"SiteConfig"> | string
    phoneNumber?: StringFilter<"SiteConfig"> | string
    iban?: StringFilter<"SiteConfig"> | string
    companyNumber?: StringFilter<"SiteConfig"> | string
    addressId?: UuidFilter<"SiteConfig"> | string
    modifiedAt?: DateTimeNullableFilter<"SiteConfig"> | Date | string | null
    isPremium?: BoolFilter<"SiteConfig"> | boolean
    deleted?: BoolFilter<"SiteConfig"> | boolean
    stripeCustomerId?: StringNullableFilter<"SiteConfig"> | string | null
    stripeAccountId?: StringNullableFilter<"SiteConfig"> | string | null
    stripeConfigured?: BoolFilter<"SiteConfig"> | boolean
  }

  export type CategoryCreateWithoutProductsInput = {
    categoryId?: string
    name: string
    imagePath?: string | null
    deleted?: boolean
    ProductHistory?: ProductHistoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    categoryId?: string
    name: string
    imagePath?: string | null
    deleted?: boolean
    ProductHistory?: ProductHistoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type CartOnProductsCreateWithoutProductInput = {
    quantity?: number
    cart: CartCreateNestedOneWithoutProductsInput
  }

  export type CartOnProductsUncheckedCreateWithoutProductInput = {
    cartId: string
    quantity?: number
  }

  export type CartOnProductsCreateOrConnectWithoutProductInput = {
    where: CartOnProductsWhereUniqueInput
    create: XOR<CartOnProductsCreateWithoutProductInput, CartOnProductsUncheckedCreateWithoutProductInput>
  }

  export type CartOnProductsCreateManyProductInputEnvelope = {
    data: CartOnProductsCreateManyProductInput | CartOnProductsCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type OrderOnProductsCreateWithoutProductInput = {
    orderDate?: Date | string
    productAmount?: number
    order: OrderCreateNestedOneWithoutProductsInput
  }

  export type OrderOnProductsUncheckedCreateWithoutProductInput = {
    orderId: string
    orderDate?: Date | string
    productAmount?: number
  }

  export type OrderOnProductsCreateOrConnectWithoutProductInput = {
    where: OrderOnProductsWhereUniqueInput
    create: XOR<OrderOnProductsCreateWithoutProductInput, OrderOnProductsUncheckedCreateWithoutProductInput>
  }

  export type OrderOnProductsCreateManyProductInputEnvelope = {
    data: OrderOnProductsCreateManyProductInput | OrderOnProductsCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductHistoryCreateWithoutProductInput = {
    historyId?: string
    name: string
    price: number
    description: string
    stock: number
    imagePath?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string | null
    deleted?: boolean
    category: CategoryCreateNestedOneWithoutProductHistoryInput
  }

  export type ProductHistoryUncheckedCreateWithoutProductInput = {
    historyId?: string
    name: string
    price: number
    description: string
    stock: number
    imagePath?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string | null
    deleted?: boolean
    categoryId: string
  }

  export type ProductHistoryCreateOrConnectWithoutProductInput = {
    where: ProductHistoryWhereUniqueInput
    create: XOR<ProductHistoryCreateWithoutProductInput, ProductHistoryUncheckedCreateWithoutProductInput>
  }

  export type ProductHistoryCreateManyProductInputEnvelope = {
    data: ProductHistoryCreateManyProductInput | ProductHistoryCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutProductsInput = {
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateWithoutProductsInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    ProductHistory?: ProductHistoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    ProductHistory?: ProductHistoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CartOnProductsUpsertWithWhereUniqueWithoutProductInput = {
    where: CartOnProductsWhereUniqueInput
    update: XOR<CartOnProductsUpdateWithoutProductInput, CartOnProductsUncheckedUpdateWithoutProductInput>
    create: XOR<CartOnProductsCreateWithoutProductInput, CartOnProductsUncheckedCreateWithoutProductInput>
  }

  export type CartOnProductsUpdateWithWhereUniqueWithoutProductInput = {
    where: CartOnProductsWhereUniqueInput
    data: XOR<CartOnProductsUpdateWithoutProductInput, CartOnProductsUncheckedUpdateWithoutProductInput>
  }

  export type CartOnProductsUpdateManyWithWhereWithoutProductInput = {
    where: CartOnProductsScalarWhereInput
    data: XOR<CartOnProductsUpdateManyMutationInput, CartOnProductsUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderOnProductsUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderOnProductsWhereUniqueInput
    update: XOR<OrderOnProductsUpdateWithoutProductInput, OrderOnProductsUncheckedUpdateWithoutProductInput>
    create: XOR<OrderOnProductsCreateWithoutProductInput, OrderOnProductsUncheckedCreateWithoutProductInput>
  }

  export type OrderOnProductsUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderOnProductsWhereUniqueInput
    data: XOR<OrderOnProductsUpdateWithoutProductInput, OrderOnProductsUncheckedUpdateWithoutProductInput>
  }

  export type OrderOnProductsUpdateManyWithWhereWithoutProductInput = {
    where: OrderOnProductsScalarWhereInput
    data: XOR<OrderOnProductsUpdateManyMutationInput, OrderOnProductsUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderOnProductsScalarWhereInput = {
    AND?: OrderOnProductsScalarWhereInput | OrderOnProductsScalarWhereInput[]
    OR?: OrderOnProductsScalarWhereInput[]
    NOT?: OrderOnProductsScalarWhereInput | OrderOnProductsScalarWhereInput[]
    orderId?: UuidFilter<"OrderOnProducts"> | string
    productId?: UuidFilter<"OrderOnProducts"> | string
    orderDate?: DateTimeFilter<"OrderOnProducts"> | Date | string
    productAmount?: IntFilter<"OrderOnProducts"> | number
  }

  export type ProductHistoryUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductHistoryWhereUniqueInput
    update: XOR<ProductHistoryUpdateWithoutProductInput, ProductHistoryUncheckedUpdateWithoutProductInput>
    create: XOR<ProductHistoryCreateWithoutProductInput, ProductHistoryUncheckedCreateWithoutProductInput>
  }

  export type ProductHistoryUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductHistoryWhereUniqueInput
    data: XOR<ProductHistoryUpdateWithoutProductInput, ProductHistoryUncheckedUpdateWithoutProductInput>
  }

  export type ProductHistoryUpdateManyWithWhereWithoutProductInput = {
    where: ProductHistoryScalarWhereInput
    data: XOR<ProductHistoryUpdateManyMutationInput, ProductHistoryUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductHistoryScalarWhereInput = {
    AND?: ProductHistoryScalarWhereInput | ProductHistoryScalarWhereInput[]
    OR?: ProductHistoryScalarWhereInput[]
    NOT?: ProductHistoryScalarWhereInput | ProductHistoryScalarWhereInput[]
    historyId?: UuidFilter<"ProductHistory"> | string
    productId?: UuidFilter<"ProductHistory"> | string
    name?: StringFilter<"ProductHistory"> | string
    price?: IntFilter<"ProductHistory"> | number
    description?: StringFilter<"ProductHistory"> | string
    stock?: IntFilter<"ProductHistory"> | number
    imagePath?: StringNullableFilter<"ProductHistory"> | string | null
    createdAt?: DateTimeFilter<"ProductHistory"> | Date | string
    modifiedAt?: DateTimeNullableFilter<"ProductHistory"> | Date | string | null
    deleted?: BoolFilter<"ProductHistory"> | boolean
    categoryId?: UuidFilter<"ProductHistory"> | string
  }

  export type CategoryCreateWithoutProductHistoryInput = {
    categoryId?: string
    name: string
    imagePath?: string | null
    deleted?: boolean
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutProductHistoryInput = {
    categoryId?: string
    name: string
    imagePath?: string | null
    deleted?: boolean
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutProductHistoryInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductHistoryInput, CategoryUncheckedCreateWithoutProductHistoryInput>
  }

  export type ProductCreateWithoutProductHistoryInput = {
    productId?: string
    name: string
    price: number
    description: string
    stock: number
    imagePath?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string | null
    deleted?: boolean
    category: CategoryCreateNestedOneWithoutProductsInput
    carts?: CartOnProductsCreateNestedManyWithoutProductInput
    orders?: OrderOnProductsCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductHistoryInput = {
    productId?: string
    name: string
    price: number
    description: string
    stock: number
    imagePath?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string | null
    deleted?: boolean
    categoryId: string
    carts?: CartOnProductsUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderOnProductsUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductHistoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductHistoryInput, ProductUncheckedCreateWithoutProductHistoryInput>
  }

  export type CategoryUpsertWithoutProductHistoryInput = {
    update: XOR<CategoryUpdateWithoutProductHistoryInput, CategoryUncheckedUpdateWithoutProductHistoryInput>
    create: XOR<CategoryCreateWithoutProductHistoryInput, CategoryUncheckedCreateWithoutProductHistoryInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProductHistoryInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProductHistoryInput, CategoryUncheckedUpdateWithoutProductHistoryInput>
  }

  export type CategoryUpdateWithoutProductHistoryInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutProductHistoryInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductUpsertWithoutProductHistoryInput = {
    update: XOR<ProductUpdateWithoutProductHistoryInput, ProductUncheckedUpdateWithoutProductHistoryInput>
    create: XOR<ProductCreateWithoutProductHistoryInput, ProductUncheckedCreateWithoutProductHistoryInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductHistoryInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductHistoryInput, ProductUncheckedUpdateWithoutProductHistoryInput>
  }

  export type ProductUpdateWithoutProductHistoryInput = {
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    carts?: CartOnProductsUpdateManyWithoutProductNestedInput
    orders?: OrderOnProductsUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductHistoryInput = {
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: StringFieldUpdateOperationsInput | string
    carts?: CartOnProductsUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderOnProductsUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateWithoutCategoryInput = {
    productId?: string
    name: string
    price: number
    description: string
    stock: number
    imagePath?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string | null
    deleted?: boolean
    carts?: CartOnProductsCreateNestedManyWithoutProductInput
    orders?: OrderOnProductsCreateNestedManyWithoutProductInput
    ProductHistory?: ProductHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    productId?: string
    name: string
    price: number
    description: string
    stock: number
    imagePath?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string | null
    deleted?: boolean
    carts?: CartOnProductsUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderOnProductsUncheckedCreateNestedManyWithoutProductInput
    ProductHistory?: ProductHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ProductHistoryCreateWithoutCategoryInput = {
    historyId?: string
    name: string
    price: number
    description: string
    stock: number
    imagePath?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string | null
    deleted?: boolean
    product: ProductCreateNestedOneWithoutProductHistoryInput
  }

  export type ProductHistoryUncheckedCreateWithoutCategoryInput = {
    historyId?: string
    productId: string
    name: string
    price: number
    description: string
    stock: number
    imagePath?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string | null
    deleted?: boolean
  }

  export type ProductHistoryCreateOrConnectWithoutCategoryInput = {
    where: ProductHistoryWhereUniqueInput
    create: XOR<ProductHistoryCreateWithoutCategoryInput, ProductHistoryUncheckedCreateWithoutCategoryInput>
  }

  export type ProductHistoryCreateManyCategoryInputEnvelope = {
    data: ProductHistoryCreateManyCategoryInput | ProductHistoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    productId?: UuidFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    price?: IntFilter<"Product"> | number
    description?: StringFilter<"Product"> | string
    stock?: IntFilter<"Product"> | number
    imagePath?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    modifiedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    deleted?: BoolFilter<"Product"> | boolean
    categoryId?: UuidFilter<"Product"> | string
  }

  export type ProductHistoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductHistoryWhereUniqueInput
    update: XOR<ProductHistoryUpdateWithoutCategoryInput, ProductHistoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductHistoryCreateWithoutCategoryInput, ProductHistoryUncheckedCreateWithoutCategoryInput>
  }

  export type ProductHistoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductHistoryWhereUniqueInput
    data: XOR<ProductHistoryUpdateWithoutCategoryInput, ProductHistoryUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductHistoryUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductHistoryScalarWhereInput
    data: XOR<ProductHistoryUpdateManyMutationInput, ProductHistoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type CustomerCreateWithoutOrdersInput = {
    customerId?: string
    customerReference: number
    email: string
    phoneNumber: string
    password: string
    firstName?: string | null
    lastName: string
    companyNumber?: string | null
    modifiedAt?: Date | string | null
    deleted?: boolean
    signedUp?: Date | string
    avatarPath?: string | null
    businessSector?: $Enums.BusinessSector | null
    address: AddressCreateNestedOneWithoutCustomersInput
    cart?: CartCreateNestedOneWithoutCustomerInput
    history?: CustomerHistoryCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutOrdersInput = {
    customerId?: string
    customerReference: number
    email: string
    phoneNumber: string
    password: string
    firstName?: string | null
    lastName: string
    companyNumber?: string | null
    modifiedAt?: Date | string | null
    deleted?: boolean
    signedUp?: Date | string
    avatarPath?: string | null
    addressId: string
    businessSector?: $Enums.BusinessSector | null
    cart?: CartUncheckedCreateNestedOneWithoutCustomerInput
    history?: CustomerHistoryUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutOrdersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
  }

  export type OrderOnProductsCreateWithoutOrderInput = {
    orderDate?: Date | string
    productAmount?: number
    product: ProductCreateNestedOneWithoutOrdersInput
  }

  export type OrderOnProductsUncheckedCreateWithoutOrderInput = {
    productId: string
    orderDate?: Date | string
    productAmount?: number
  }

  export type OrderOnProductsCreateOrConnectWithoutOrderInput = {
    where: OrderOnProductsWhereUniqueInput
    create: XOR<OrderOnProductsCreateWithoutOrderInput, OrderOnProductsUncheckedCreateWithoutOrderInput>
  }

  export type OrderOnProductsCreateManyOrderInputEnvelope = {
    data: OrderOnProductsCreateManyOrderInput | OrderOnProductsCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutOrderInput = {
    invoiceId?: string
    invoiceAmount: number
    paymentDate?: Date | string | null
    pdfUrl: string
    deleted?: boolean
  }

  export type InvoiceUncheckedCreateWithoutOrderInput = {
    invoiceId?: string
    invoiceAmount: number
    paymentDate?: Date | string | null
    pdfUrl: string
    deleted?: boolean
  }

  export type InvoiceCreateOrConnectWithoutOrderInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
  }

  export type RoutesOnOrdersCreateWithoutOrderInput = {
    route: RouteCreateNestedOneWithoutOrderInput
  }

  export type RoutesOnOrdersUncheckedCreateWithoutOrderInput = {
    routeId: string
  }

  export type RoutesOnOrdersCreateOrConnectWithoutOrderInput = {
    where: RoutesOnOrdersWhereUniqueInput
    create: XOR<RoutesOnOrdersCreateWithoutOrderInput, RoutesOnOrdersUncheckedCreateWithoutOrderInput>
  }

  export type RoutesOnOrdersCreateManyOrderInputEnvelope = {
    data: RoutesOnOrdersCreateManyOrderInput | RoutesOnOrdersCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutOrdersInput = {
    update: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutOrdersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomerUpdateWithoutOrdersInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    customerReference?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    signedUp?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    businessSector?: NullableEnumBusinessSectorFieldUpdateOperationsInput | $Enums.BusinessSector | null
    address?: AddressUpdateOneRequiredWithoutCustomersNestedInput
    cart?: CartUpdateOneWithoutCustomerNestedInput
    history?: CustomerHistoryUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutOrdersInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    customerReference?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    signedUp?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: StringFieldUpdateOperationsInput | string
    businessSector?: NullableEnumBusinessSectorFieldUpdateOperationsInput | $Enums.BusinessSector | null
    cart?: CartUncheckedUpdateOneWithoutCustomerNestedInput
    history?: CustomerHistoryUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type OrderOnProductsUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderOnProductsWhereUniqueInput
    update: XOR<OrderOnProductsUpdateWithoutOrderInput, OrderOnProductsUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderOnProductsCreateWithoutOrderInput, OrderOnProductsUncheckedCreateWithoutOrderInput>
  }

  export type OrderOnProductsUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderOnProductsWhereUniqueInput
    data: XOR<OrderOnProductsUpdateWithoutOrderInput, OrderOnProductsUncheckedUpdateWithoutOrderInput>
  }

  export type OrderOnProductsUpdateManyWithWhereWithoutOrderInput = {
    where: OrderOnProductsScalarWhereInput
    data: XOR<OrderOnProductsUpdateManyMutationInput, OrderOnProductsUncheckedUpdateManyWithoutOrderInput>
  }

  export type InvoiceUpsertWithoutOrderInput = {
    update: XOR<InvoiceUpdateWithoutOrderInput, InvoiceUncheckedUpdateWithoutOrderInput>
    create: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutOrderInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutOrderInput, InvoiceUncheckedUpdateWithoutOrderInput>
  }

  export type InvoiceUpdateWithoutOrderInput = {
    invoiceId?: StringFieldUpdateOperationsInput | string
    invoiceAmount?: IntFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pdfUrl?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceUncheckedUpdateWithoutOrderInput = {
    invoiceId?: StringFieldUpdateOperationsInput | string
    invoiceAmount?: IntFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pdfUrl?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoutesOnOrdersUpsertWithWhereUniqueWithoutOrderInput = {
    where: RoutesOnOrdersWhereUniqueInput
    update: XOR<RoutesOnOrdersUpdateWithoutOrderInput, RoutesOnOrdersUncheckedUpdateWithoutOrderInput>
    create: XOR<RoutesOnOrdersCreateWithoutOrderInput, RoutesOnOrdersUncheckedCreateWithoutOrderInput>
  }

  export type RoutesOnOrdersUpdateWithWhereUniqueWithoutOrderInput = {
    where: RoutesOnOrdersWhereUniqueInput
    data: XOR<RoutesOnOrdersUpdateWithoutOrderInput, RoutesOnOrdersUncheckedUpdateWithoutOrderInput>
  }

  export type RoutesOnOrdersUpdateManyWithWhereWithoutOrderInput = {
    where: RoutesOnOrdersScalarWhereInput
    data: XOR<RoutesOnOrdersUpdateManyMutationInput, RoutesOnOrdersUncheckedUpdateManyWithoutOrderInput>
  }

  export type RoutesOnOrdersScalarWhereInput = {
    AND?: RoutesOnOrdersScalarWhereInput | RoutesOnOrdersScalarWhereInput[]
    OR?: RoutesOnOrdersScalarWhereInput[]
    NOT?: RoutesOnOrdersScalarWhereInput | RoutesOnOrdersScalarWhereInput[]
    routeId?: UuidFilter<"RoutesOnOrders"> | string
    orderId?: UuidFilter<"RoutesOnOrders"> | string
  }

  export type OrderCreateWithoutInvoiceInput = {
    orderId?: string
    orderDate?: Date | string
    deliveryDate?: Date | string | null
    deleted?: boolean
    orderState?: $Enums.OrderState
    selfCollect?: boolean
    customer: CustomerCreateNestedOneWithoutOrdersInput
    products?: OrderOnProductsCreateNestedManyWithoutOrderInput
    route?: RoutesOnOrdersCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutInvoiceInput = {
    orderId?: string
    customerReference: number
    orderDate?: Date | string
    deliveryDate?: Date | string | null
    deleted?: boolean
    orderState?: $Enums.OrderState
    selfCollect?: boolean
    products?: OrderOnProductsUncheckedCreateNestedManyWithoutOrderInput
    route?: RoutesOnOrdersUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutInvoiceInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutInvoiceInput, OrderUncheckedCreateWithoutInvoiceInput>
  }

  export type OrderUpsertWithoutInvoiceInput = {
    update: XOR<OrderUpdateWithoutInvoiceInput, OrderUncheckedUpdateWithoutInvoiceInput>
    create: XOR<OrderCreateWithoutInvoiceInput, OrderUncheckedCreateWithoutInvoiceInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutInvoiceInput, OrderUncheckedUpdateWithoutInvoiceInput>
  }

  export type OrderUpdateWithoutInvoiceInput = {
    orderId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    orderState?: EnumOrderStateFieldUpdateOperationsInput | $Enums.OrderState
    selfCollect?: BoolFieldUpdateOperationsInput | boolean
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    products?: OrderOnProductsUpdateManyWithoutOrderNestedInput
    route?: RoutesOnOrdersUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutInvoiceInput = {
    orderId?: StringFieldUpdateOperationsInput | string
    customerReference?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    orderState?: EnumOrderStateFieldUpdateOperationsInput | $Enums.OrderState
    selfCollect?: BoolFieldUpdateOperationsInput | boolean
    products?: OrderOnProductsUncheckedUpdateManyWithoutOrderNestedInput
    route?: RoutesOnOrdersUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type RoutesOnOrdersCreateWithoutRouteInput = {
    order: OrderCreateNestedOneWithoutRouteInput
  }

  export type RoutesOnOrdersUncheckedCreateWithoutRouteInput = {
    orderId: string
  }

  export type RoutesOnOrdersCreateOrConnectWithoutRouteInput = {
    where: RoutesOnOrdersWhereUniqueInput
    create: XOR<RoutesOnOrdersCreateWithoutRouteInput, RoutesOnOrdersUncheckedCreateWithoutRouteInput>
  }

  export type RoutesOnOrdersCreateManyRouteInputEnvelope = {
    data: RoutesOnOrdersCreateManyRouteInput | RoutesOnOrdersCreateManyRouteInput[]
    skipDuplicates?: boolean
  }

  export type RoutesOnOrdersUpsertWithWhereUniqueWithoutRouteInput = {
    where: RoutesOnOrdersWhereUniqueInput
    update: XOR<RoutesOnOrdersUpdateWithoutRouteInput, RoutesOnOrdersUncheckedUpdateWithoutRouteInput>
    create: XOR<RoutesOnOrdersCreateWithoutRouteInput, RoutesOnOrdersUncheckedCreateWithoutRouteInput>
  }

  export type RoutesOnOrdersUpdateWithWhereUniqueWithoutRouteInput = {
    where: RoutesOnOrdersWhereUniqueInput
    data: XOR<RoutesOnOrdersUpdateWithoutRouteInput, RoutesOnOrdersUncheckedUpdateWithoutRouteInput>
  }

  export type RoutesOnOrdersUpdateManyWithWhereWithoutRouteInput = {
    where: RoutesOnOrdersScalarWhereInput
    data: XOR<RoutesOnOrdersUpdateManyMutationInput, RoutesOnOrdersUncheckedUpdateManyWithoutRouteInput>
  }

  export type RoleCreateWithoutEmployeesInput = {
    name?: string
    description?: string | null
    deleted?: boolean
    permissions?: PermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutEmployeesInput = {
    name?: string
    description?: string | null
    deleted?: boolean
    permissions?: PermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutEmployeesInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutEmployeesInput, RoleUncheckedCreateWithoutEmployeesInput>
  }

  export type RoleUpsertWithoutEmployeesInput = {
    update: XOR<RoleUpdateWithoutEmployeesInput, RoleUncheckedUpdateWithoutEmployeesInput>
    create: XOR<RoleCreateWithoutEmployeesInput, RoleUncheckedCreateWithoutEmployeesInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutEmployeesInput, RoleUncheckedUpdateWithoutEmployeesInput>
  }

  export type RoleUpdateWithoutEmployeesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    permissions?: PermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutEmployeesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    permissions?: PermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type AddressCreateWithoutSiteConfigInput = {
    addressId?: string
    city: string
    country: string
    postCode: string
    state: string
    streetName: string
    streetNumber: string
    modifiedAt?: Date | string | null
    deleted?: boolean
    customers?: CustomerCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutSiteConfigInput = {
    addressId?: string
    city: string
    country: string
    postCode: string
    state: string
    streetName: string
    streetNumber: string
    modifiedAt?: Date | string | null
    deleted?: boolean
    customers?: CustomerUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutSiteConfigInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutSiteConfigInput, AddressUncheckedCreateWithoutSiteConfigInput>
  }

  export type AddressUpsertWithoutSiteConfigInput = {
    update: XOR<AddressUpdateWithoutSiteConfigInput, AddressUncheckedUpdateWithoutSiteConfigInput>
    create: XOR<AddressCreateWithoutSiteConfigInput, AddressUncheckedCreateWithoutSiteConfigInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutSiteConfigInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutSiteConfigInput, AddressUncheckedUpdateWithoutSiteConfigInput>
  }

  export type AddressUpdateWithoutSiteConfigInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    streetName?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    customers?: CustomerUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutSiteConfigInput = {
    addressId?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    streetName?: StringFieldUpdateOperationsInput | string
    streetNumber?: StringFieldUpdateOperationsInput | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    customers?: CustomerUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type ResourceActionCreateWithoutActionInput = {
    Ressource: RessourceCreateNestedOneWithoutActionLinksInput
    permissions?: PermissionCreateNestedManyWithoutResourceActionInput
  }

  export type ResourceActionUncheckedCreateWithoutActionInput = {
    resource: $Enums.Ressources
    permissions?: PermissionUncheckedCreateNestedManyWithoutResourceActionInput
  }

  export type ResourceActionCreateOrConnectWithoutActionInput = {
    where: ResourceActionWhereUniqueInput
    create: XOR<ResourceActionCreateWithoutActionInput, ResourceActionUncheckedCreateWithoutActionInput>
  }

  export type ResourceActionCreateManyActionInputEnvelope = {
    data: ResourceActionCreateManyActionInput | ResourceActionCreateManyActionInput[]
    skipDuplicates?: boolean
  }

  export type ResourceActionUpsertWithWhereUniqueWithoutActionInput = {
    where: ResourceActionWhereUniqueInput
    update: XOR<ResourceActionUpdateWithoutActionInput, ResourceActionUncheckedUpdateWithoutActionInput>
    create: XOR<ResourceActionCreateWithoutActionInput, ResourceActionUncheckedCreateWithoutActionInput>
  }

  export type ResourceActionUpdateWithWhereUniqueWithoutActionInput = {
    where: ResourceActionWhereUniqueInput
    data: XOR<ResourceActionUpdateWithoutActionInput, ResourceActionUncheckedUpdateWithoutActionInput>
  }

  export type ResourceActionUpdateManyWithWhereWithoutActionInput = {
    where: ResourceActionScalarWhereInput
    data: XOR<ResourceActionUpdateManyMutationInput, ResourceActionUncheckedUpdateManyWithoutActionInput>
  }

  export type ResourceActionScalarWhereInput = {
    AND?: ResourceActionScalarWhereInput | ResourceActionScalarWhereInput[]
    OR?: ResourceActionScalarWhereInput[]
    NOT?: ResourceActionScalarWhereInput | ResourceActionScalarWhereInput[]
    action?: EnumActionsFilter<"ResourceAction"> | $Enums.Actions
    resource?: EnumRessourcesFilter<"ResourceAction"> | $Enums.Ressources
  }

  export type ResourceActionCreateWithoutRessourceInput = {
    Action: ActionCreateNestedOneWithoutResourceLinksInput
    permissions?: PermissionCreateNestedManyWithoutResourceActionInput
  }

  export type ResourceActionUncheckedCreateWithoutRessourceInput = {
    action: $Enums.Actions
    permissions?: PermissionUncheckedCreateNestedManyWithoutResourceActionInput
  }

  export type ResourceActionCreateOrConnectWithoutRessourceInput = {
    where: ResourceActionWhereUniqueInput
    create: XOR<ResourceActionCreateWithoutRessourceInput, ResourceActionUncheckedCreateWithoutRessourceInput>
  }

  export type ResourceActionCreateManyRessourceInputEnvelope = {
    data: ResourceActionCreateManyRessourceInput | ResourceActionCreateManyRessourceInput[]
    skipDuplicates?: boolean
  }

  export type ResourceActionUpsertWithWhereUniqueWithoutRessourceInput = {
    where: ResourceActionWhereUniqueInput
    update: XOR<ResourceActionUpdateWithoutRessourceInput, ResourceActionUncheckedUpdateWithoutRessourceInput>
    create: XOR<ResourceActionCreateWithoutRessourceInput, ResourceActionUncheckedCreateWithoutRessourceInput>
  }

  export type ResourceActionUpdateWithWhereUniqueWithoutRessourceInput = {
    where: ResourceActionWhereUniqueInput
    data: XOR<ResourceActionUpdateWithoutRessourceInput, ResourceActionUncheckedUpdateWithoutRessourceInput>
  }

  export type ResourceActionUpdateManyWithWhereWithoutRessourceInput = {
    where: ResourceActionScalarWhereInput
    data: XOR<ResourceActionUpdateManyMutationInput, ResourceActionUncheckedUpdateManyWithoutRessourceInput>
  }

  export type ActionCreateWithoutResourceLinksInput = {
    name: $Enums.Actions
    description?: string | null
    deleted?: boolean
  }

  export type ActionUncheckedCreateWithoutResourceLinksInput = {
    name: $Enums.Actions
    description?: string | null
    deleted?: boolean
  }

  export type ActionCreateOrConnectWithoutResourceLinksInput = {
    where: ActionWhereUniqueInput
    create: XOR<ActionCreateWithoutResourceLinksInput, ActionUncheckedCreateWithoutResourceLinksInput>
  }

  export type RessourceCreateWithoutActionLinksInput = {
    name: $Enums.Ressources
    description?: string | null
    deleted?: boolean
  }

  export type RessourceUncheckedCreateWithoutActionLinksInput = {
    name: $Enums.Ressources
    description?: string | null
    deleted?: boolean
  }

  export type RessourceCreateOrConnectWithoutActionLinksInput = {
    where: RessourceWhereUniqueInput
    create: XOR<RessourceCreateWithoutActionLinksInput, RessourceUncheckedCreateWithoutActionLinksInput>
  }

  export type PermissionCreateWithoutResourceActionInput = {
    id?: string
    allowed?: boolean
    createdAt?: Date | string
    Role: RoleCreateNestedOneWithoutPermissionsInput
  }

  export type PermissionUncheckedCreateWithoutResourceActionInput = {
    id?: string
    role: string
    allowed?: boolean
    createdAt?: Date | string
  }

  export type PermissionCreateOrConnectWithoutResourceActionInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutResourceActionInput, PermissionUncheckedCreateWithoutResourceActionInput>
  }

  export type PermissionCreateManyResourceActionInputEnvelope = {
    data: PermissionCreateManyResourceActionInput | PermissionCreateManyResourceActionInput[]
    skipDuplicates?: boolean
  }

  export type ActionUpsertWithoutResourceLinksInput = {
    update: XOR<ActionUpdateWithoutResourceLinksInput, ActionUncheckedUpdateWithoutResourceLinksInput>
    create: XOR<ActionCreateWithoutResourceLinksInput, ActionUncheckedCreateWithoutResourceLinksInput>
    where?: ActionWhereInput
  }

  export type ActionUpdateToOneWithWhereWithoutResourceLinksInput = {
    where?: ActionWhereInput
    data: XOR<ActionUpdateWithoutResourceLinksInput, ActionUncheckedUpdateWithoutResourceLinksInput>
  }

  export type ActionUpdateWithoutResourceLinksInput = {
    name?: EnumActionsFieldUpdateOperationsInput | $Enums.Actions
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ActionUncheckedUpdateWithoutResourceLinksInput = {
    name?: EnumActionsFieldUpdateOperationsInput | $Enums.Actions
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RessourceUpsertWithoutActionLinksInput = {
    update: XOR<RessourceUpdateWithoutActionLinksInput, RessourceUncheckedUpdateWithoutActionLinksInput>
    create: XOR<RessourceCreateWithoutActionLinksInput, RessourceUncheckedCreateWithoutActionLinksInput>
    where?: RessourceWhereInput
  }

  export type RessourceUpdateToOneWithWhereWithoutActionLinksInput = {
    where?: RessourceWhereInput
    data: XOR<RessourceUpdateWithoutActionLinksInput, RessourceUncheckedUpdateWithoutActionLinksInput>
  }

  export type RessourceUpdateWithoutActionLinksInput = {
    name?: EnumRessourcesFieldUpdateOperationsInput | $Enums.Ressources
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RessourceUncheckedUpdateWithoutActionLinksInput = {
    name?: EnumRessourcesFieldUpdateOperationsInput | $Enums.Ressources
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PermissionUpsertWithWhereUniqueWithoutResourceActionInput = {
    where: PermissionWhereUniqueInput
    update: XOR<PermissionUpdateWithoutResourceActionInput, PermissionUncheckedUpdateWithoutResourceActionInput>
    create: XOR<PermissionCreateWithoutResourceActionInput, PermissionUncheckedCreateWithoutResourceActionInput>
  }

  export type PermissionUpdateWithWhereUniqueWithoutResourceActionInput = {
    where: PermissionWhereUniqueInput
    data: XOR<PermissionUpdateWithoutResourceActionInput, PermissionUncheckedUpdateWithoutResourceActionInput>
  }

  export type PermissionUpdateManyWithWhereWithoutResourceActionInput = {
    where: PermissionScalarWhereInput
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyWithoutResourceActionInput>
  }

  export type PermissionScalarWhereInput = {
    AND?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
    OR?: PermissionScalarWhereInput[]
    NOT?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
    id?: UuidFilter<"Permission"> | string
    role?: StringFilter<"Permission"> | string
    action?: EnumActionsFilter<"Permission"> | $Enums.Actions
    resource?: EnumRessourcesFilter<"Permission"> | $Enums.Ressources
    allowed?: BoolFilter<"Permission"> | boolean
    createdAt?: DateTimeFilter<"Permission"> | Date | string
  }

  export type EmployeesCreateWithoutRoleInput = {
    employeeId?: string
    email: string
    password: string
    firstName: string
    lastName: string
    deleted?: boolean
  }

  export type EmployeesUncheckedCreateWithoutRoleInput = {
    employeeId?: string
    email: string
    password: string
    firstName: string
    lastName: string
    deleted?: boolean
  }

  export type EmployeesCreateOrConnectWithoutRoleInput = {
    where: EmployeesWhereUniqueInput
    create: XOR<EmployeesCreateWithoutRoleInput, EmployeesUncheckedCreateWithoutRoleInput>
  }

  export type EmployeesCreateManyRoleInputEnvelope = {
    data: EmployeesCreateManyRoleInput | EmployeesCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type PermissionCreateWithoutRoleInput = {
    id?: string
    allowed?: boolean
    createdAt?: Date | string
    resourceAction: ResourceActionCreateNestedOneWithoutPermissionsInput
  }

  export type PermissionUncheckedCreateWithoutRoleInput = {
    id?: string
    action: $Enums.Actions
    resource: $Enums.Ressources
    allowed?: boolean
    createdAt?: Date | string
  }

  export type PermissionCreateOrConnectWithoutRoleInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRoleInput, PermissionUncheckedCreateWithoutRoleInput>
  }

  export type PermissionCreateManyRoleInputEnvelope = {
    data: PermissionCreateManyRoleInput | PermissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type EmployeesUpsertWithWhereUniqueWithoutRoleInput = {
    where: EmployeesWhereUniqueInput
    update: XOR<EmployeesUpdateWithoutRoleInput, EmployeesUncheckedUpdateWithoutRoleInput>
    create: XOR<EmployeesCreateWithoutRoleInput, EmployeesUncheckedCreateWithoutRoleInput>
  }

  export type EmployeesUpdateWithWhereUniqueWithoutRoleInput = {
    where: EmployeesWhereUniqueInput
    data: XOR<EmployeesUpdateWithoutRoleInput, EmployeesUncheckedUpdateWithoutRoleInput>
  }

  export type EmployeesUpdateManyWithWhereWithoutRoleInput = {
    where: EmployeesScalarWhereInput
    data: XOR<EmployeesUpdateManyMutationInput, EmployeesUncheckedUpdateManyWithoutRoleInput>
  }

  export type EmployeesScalarWhereInput = {
    AND?: EmployeesScalarWhereInput | EmployeesScalarWhereInput[]
    OR?: EmployeesScalarWhereInput[]
    NOT?: EmployeesScalarWhereInput | EmployeesScalarWhereInput[]
    employeeId?: UuidFilter<"Employees"> | string
    email?: StringFilter<"Employees"> | string
    password?: StringFilter<"Employees"> | string
    firstName?: StringFilter<"Employees"> | string
    lastName?: StringFilter<"Employees"> | string
    deleted?: BoolFilter<"Employees"> | boolean
    role?: StringFilter<"Employees"> | string
  }

  export type PermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: PermissionWhereUniqueInput
    update: XOR<PermissionUpdateWithoutRoleInput, PermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<PermissionCreateWithoutRoleInput, PermissionUncheckedCreateWithoutRoleInput>
  }

  export type PermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: PermissionWhereUniqueInput
    data: XOR<PermissionUpdateWithoutRoleInput, PermissionUncheckedUpdateWithoutRoleInput>
  }

  export type PermissionUpdateManyWithWhereWithoutRoleInput = {
    where: PermissionScalarWhereInput
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type RoleCreateWithoutPermissionsInput = {
    name?: string
    description?: string | null
    deleted?: boolean
    employees?: EmployeesCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutPermissionsInput = {
    name?: string
    description?: string | null
    deleted?: boolean
    employees?: EmployeesUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutPermissionsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
  }

  export type ResourceActionCreateWithoutPermissionsInput = {
    Action: ActionCreateNestedOneWithoutResourceLinksInput
    Ressource: RessourceCreateNestedOneWithoutActionLinksInput
  }

  export type ResourceActionUncheckedCreateWithoutPermissionsInput = {
    action: $Enums.Actions
    resource: $Enums.Ressources
  }

  export type ResourceActionCreateOrConnectWithoutPermissionsInput = {
    where: ResourceActionWhereUniqueInput
    create: XOR<ResourceActionCreateWithoutPermissionsInput, ResourceActionUncheckedCreateWithoutPermissionsInput>
  }

  export type RoleUpsertWithoutPermissionsInput = {
    update: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type RoleUpdateWithoutPermissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    employees?: EmployeesUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutPermissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    employees?: EmployeesUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type ResourceActionUpsertWithoutPermissionsInput = {
    update: XOR<ResourceActionUpdateWithoutPermissionsInput, ResourceActionUncheckedUpdateWithoutPermissionsInput>
    create: XOR<ResourceActionCreateWithoutPermissionsInput, ResourceActionUncheckedCreateWithoutPermissionsInput>
    where?: ResourceActionWhereInput
  }

  export type ResourceActionUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: ResourceActionWhereInput
    data: XOR<ResourceActionUpdateWithoutPermissionsInput, ResourceActionUncheckedUpdateWithoutPermissionsInput>
  }

  export type ResourceActionUpdateWithoutPermissionsInput = {
    Action?: ActionUpdateOneRequiredWithoutResourceLinksNestedInput
    Ressource?: RessourceUpdateOneRequiredWithoutActionLinksNestedInput
  }

  export type ResourceActionUncheckedUpdateWithoutPermissionsInput = {
    action?: EnumActionsFieldUpdateOperationsInput | $Enums.Actions
    resource?: EnumRessourcesFieldUpdateOperationsInput | $Enums.Ressources
  }

  export type CartCreateWithoutProductsInput = {
    cartId?: string
    customer?: CustomerCreateNestedOneWithoutCartInput
  }

  export type CartUncheckedCreateWithoutProductsInput = {
    cartId?: string
    customerReference?: number | null
  }

  export type CartCreateOrConnectWithoutProductsInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutProductsInput, CartUncheckedCreateWithoutProductsInput>
  }

  export type ProductCreateWithoutCartsInput = {
    productId?: string
    name: string
    price: number
    description: string
    stock: number
    imagePath?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string | null
    deleted?: boolean
    category: CategoryCreateNestedOneWithoutProductsInput
    orders?: OrderOnProductsCreateNestedManyWithoutProductInput
    ProductHistory?: ProductHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCartsInput = {
    productId?: string
    name: string
    price: number
    description: string
    stock: number
    imagePath?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string | null
    deleted?: boolean
    categoryId: string
    orders?: OrderOnProductsUncheckedCreateNestedManyWithoutProductInput
    ProductHistory?: ProductHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCartsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCartsInput, ProductUncheckedCreateWithoutCartsInput>
  }

  export type CartUpsertWithoutProductsInput = {
    update: XOR<CartUpdateWithoutProductsInput, CartUncheckedUpdateWithoutProductsInput>
    create: XOR<CartCreateWithoutProductsInput, CartUncheckedCreateWithoutProductsInput>
    where?: CartWhereInput
  }

  export type CartUpdateToOneWithWhereWithoutProductsInput = {
    where?: CartWhereInput
    data: XOR<CartUpdateWithoutProductsInput, CartUncheckedUpdateWithoutProductsInput>
  }

  export type CartUpdateWithoutProductsInput = {
    cartId?: StringFieldUpdateOperationsInput | string
    customer?: CustomerUpdateOneWithoutCartNestedInput
  }

  export type CartUncheckedUpdateWithoutProductsInput = {
    cartId?: StringFieldUpdateOperationsInput | string
    customerReference?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductUpsertWithoutCartsInput = {
    update: XOR<ProductUpdateWithoutCartsInput, ProductUncheckedUpdateWithoutCartsInput>
    create: XOR<ProductCreateWithoutCartsInput, ProductUncheckedCreateWithoutCartsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutCartsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutCartsInput, ProductUncheckedUpdateWithoutCartsInput>
  }

  export type ProductUpdateWithoutCartsInput = {
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    orders?: OrderOnProductsUpdateManyWithoutProductNestedInput
    ProductHistory?: ProductHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCartsInput = {
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: StringFieldUpdateOperationsInput | string
    orders?: OrderOnProductsUncheckedUpdateManyWithoutProductNestedInput
    ProductHistory?: ProductHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type OrderCreateWithoutProductsInput = {
    orderId?: string
    orderDate?: Date | string
    deliveryDate?: Date | string | null
    deleted?: boolean
    orderState?: $Enums.OrderState
    selfCollect?: boolean
    customer: CustomerCreateNestedOneWithoutOrdersInput
    invoice?: InvoiceCreateNestedOneWithoutOrderInput
    route?: RoutesOnOrdersCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutProductsInput = {
    orderId?: string
    customerReference: number
    orderDate?: Date | string
    deliveryDate?: Date | string | null
    deleted?: boolean
    orderState?: $Enums.OrderState
    selfCollect?: boolean
    invoice?: InvoiceUncheckedCreateNestedOneWithoutOrderInput
    route?: RoutesOnOrdersUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutProductsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutProductsInput, OrderUncheckedCreateWithoutProductsInput>
  }

  export type ProductCreateWithoutOrdersInput = {
    productId?: string
    name: string
    price: number
    description: string
    stock: number
    imagePath?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string | null
    deleted?: boolean
    category: CategoryCreateNestedOneWithoutProductsInput
    carts?: CartOnProductsCreateNestedManyWithoutProductInput
    ProductHistory?: ProductHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrdersInput = {
    productId?: string
    name: string
    price: number
    description: string
    stock: number
    imagePath?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string | null
    deleted?: boolean
    categoryId: string
    carts?: CartOnProductsUncheckedCreateNestedManyWithoutProductInput
    ProductHistory?: ProductHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrdersInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput>
  }

  export type OrderUpsertWithoutProductsInput = {
    update: XOR<OrderUpdateWithoutProductsInput, OrderUncheckedUpdateWithoutProductsInput>
    create: XOR<OrderCreateWithoutProductsInput, OrderUncheckedCreateWithoutProductsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutProductsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutProductsInput, OrderUncheckedUpdateWithoutProductsInput>
  }

  export type OrderUpdateWithoutProductsInput = {
    orderId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    orderState?: EnumOrderStateFieldUpdateOperationsInput | $Enums.OrderState
    selfCollect?: BoolFieldUpdateOperationsInput | boolean
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    invoice?: InvoiceUpdateOneWithoutOrderNestedInput
    route?: RoutesOnOrdersUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutProductsInput = {
    orderId?: StringFieldUpdateOperationsInput | string
    customerReference?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    orderState?: EnumOrderStateFieldUpdateOperationsInput | $Enums.OrderState
    selfCollect?: BoolFieldUpdateOperationsInput | boolean
    invoice?: InvoiceUncheckedUpdateOneWithoutOrderNestedInput
    route?: RoutesOnOrdersUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ProductUpsertWithoutOrdersInput = {
    update: XOR<ProductUpdateWithoutOrdersInput, ProductUncheckedUpdateWithoutOrdersInput>
    create: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrdersInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrdersInput, ProductUncheckedUpdateWithoutOrdersInput>
  }

  export type ProductUpdateWithoutOrdersInput = {
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    carts?: CartOnProductsUpdateManyWithoutProductNestedInput
    ProductHistory?: ProductHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrdersInput = {
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: StringFieldUpdateOperationsInput | string
    carts?: CartOnProductsUncheckedUpdateManyWithoutProductNestedInput
    ProductHistory?: ProductHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type RouteCreateWithoutOrderInput = {
    routeId?: string
    name: string
    deleted?: boolean
  }

  export type RouteUncheckedCreateWithoutOrderInput = {
    routeId?: string
    name: string
    deleted?: boolean
  }

  export type RouteCreateOrConnectWithoutOrderInput = {
    where: RouteWhereUniqueInput
    create: XOR<RouteCreateWithoutOrderInput, RouteUncheckedCreateWithoutOrderInput>
  }

  export type OrderCreateWithoutRouteInput = {
    orderId?: string
    orderDate?: Date | string
    deliveryDate?: Date | string | null
    deleted?: boolean
    orderState?: $Enums.OrderState
    selfCollect?: boolean
    customer: CustomerCreateNestedOneWithoutOrdersInput
    products?: OrderOnProductsCreateNestedManyWithoutOrderInput
    invoice?: InvoiceCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutRouteInput = {
    orderId?: string
    customerReference: number
    orderDate?: Date | string
    deliveryDate?: Date | string | null
    deleted?: boolean
    orderState?: $Enums.OrderState
    selfCollect?: boolean
    products?: OrderOnProductsUncheckedCreateNestedManyWithoutOrderInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutRouteInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutRouteInput, OrderUncheckedCreateWithoutRouteInput>
  }

  export type RouteUpsertWithoutOrderInput = {
    update: XOR<RouteUpdateWithoutOrderInput, RouteUncheckedUpdateWithoutOrderInput>
    create: XOR<RouteCreateWithoutOrderInput, RouteUncheckedCreateWithoutOrderInput>
    where?: RouteWhereInput
  }

  export type RouteUpdateToOneWithWhereWithoutOrderInput = {
    where?: RouteWhereInput
    data: XOR<RouteUpdateWithoutOrderInput, RouteUncheckedUpdateWithoutOrderInput>
  }

  export type RouteUpdateWithoutOrderInput = {
    routeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RouteUncheckedUpdateWithoutOrderInput = {
    routeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrderUpsertWithoutRouteInput = {
    update: XOR<OrderUpdateWithoutRouteInput, OrderUncheckedUpdateWithoutRouteInput>
    create: XOR<OrderCreateWithoutRouteInput, OrderUncheckedCreateWithoutRouteInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutRouteInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutRouteInput, OrderUncheckedUpdateWithoutRouteInput>
  }

  export type OrderUpdateWithoutRouteInput = {
    orderId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    orderState?: EnumOrderStateFieldUpdateOperationsInput | $Enums.OrderState
    selfCollect?: BoolFieldUpdateOperationsInput | boolean
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    products?: OrderOnProductsUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutRouteInput = {
    orderId?: StringFieldUpdateOperationsInput | string
    customerReference?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    orderState?: EnumOrderStateFieldUpdateOperationsInput | $Enums.OrderState
    selfCollect?: BoolFieldUpdateOperationsInput | boolean
    products?: OrderOnProductsUncheckedUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderCreateManyCustomerInput = {
    orderId?: string
    orderDate?: Date | string
    deliveryDate?: Date | string | null
    deleted?: boolean
    orderState?: $Enums.OrderState
    selfCollect?: boolean
  }

  export type CustomerHistoryCreateManyCustomerInput = {
    historyId?: string
    email: string
    phoneNumber: string
    password: string
    firstName?: string | null
    lastName: string
    companyNumber?: string | null
    modifiedAt?: Date | string | null
    deleted?: boolean
    signedUp?: Date | string
    avatarPath?: string | null
    addressId: string
    businessSector?: $Enums.BusinessSector | null
  }

  export type OrderUpdateWithoutCustomerInput = {
    orderId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    orderState?: EnumOrderStateFieldUpdateOperationsInput | $Enums.OrderState
    selfCollect?: BoolFieldUpdateOperationsInput | boolean
    products?: OrderOnProductsUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUpdateOneWithoutOrderNestedInput
    route?: RoutesOnOrdersUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCustomerInput = {
    orderId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    orderState?: EnumOrderStateFieldUpdateOperationsInput | $Enums.OrderState
    selfCollect?: BoolFieldUpdateOperationsInput | boolean
    products?: OrderOnProductsUncheckedUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutOrderNestedInput
    route?: RoutesOnOrdersUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCustomerInput = {
    orderId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    orderState?: EnumOrderStateFieldUpdateOperationsInput | $Enums.OrderState
    selfCollect?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CustomerHistoryUpdateWithoutCustomerInput = {
    historyId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    signedUp?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: StringFieldUpdateOperationsInput | string
    businessSector?: NullableEnumBusinessSectorFieldUpdateOperationsInput | $Enums.BusinessSector | null
  }

  export type CustomerHistoryUncheckedUpdateWithoutCustomerInput = {
    historyId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    signedUp?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: StringFieldUpdateOperationsInput | string
    businessSector?: NullableEnumBusinessSectorFieldUpdateOperationsInput | $Enums.BusinessSector | null
  }

  export type CustomerHistoryUncheckedUpdateManyWithoutCustomerInput = {
    historyId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    signedUp?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: StringFieldUpdateOperationsInput | string
    businessSector?: NullableEnumBusinessSectorFieldUpdateOperationsInput | $Enums.BusinessSector | null
  }

  export type CartOnProductsCreateManyCartInput = {
    productId: string
    quantity?: number
  }

  export type CartOnProductsUpdateWithoutCartInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutCartsNestedInput
  }

  export type CartOnProductsUncheckedUpdateWithoutCartInput = {
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type CartOnProductsUncheckedUpdateManyWithoutCartInput = {
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type CustomerCreateManyAddressInput = {
    customerId?: string
    customerReference: number
    email: string
    phoneNumber: string
    password: string
    firstName?: string | null
    lastName: string
    companyNumber?: string | null
    modifiedAt?: Date | string | null
    deleted?: boolean
    signedUp?: Date | string
    avatarPath?: string | null
    businessSector?: $Enums.BusinessSector | null
  }

  export type SiteConfigCreateManyAddressInput = {
    siteConfigId?: string
    companyName: string
    logoPath: string
    email: string
    phoneNumber: string
    iban: string
    companyNumber: string
    modifiedAt?: Date | string | null
    isPremium?: boolean
    deleted?: boolean
    stripeCustomerId?: string | null
    stripeAccountId?: string | null
    stripeConfigured?: boolean
  }

  export type CustomerUpdateWithoutAddressInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    customerReference?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    signedUp?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    businessSector?: NullableEnumBusinessSectorFieldUpdateOperationsInput | $Enums.BusinessSector | null
    cart?: CartUpdateOneWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    history?: CustomerHistoryUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutAddressInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    customerReference?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    signedUp?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    businessSector?: NullableEnumBusinessSectorFieldUpdateOperationsInput | $Enums.BusinessSector | null
    cart?: CartUncheckedUpdateOneWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    history?: CustomerHistoryUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutAddressInput = {
    customerId?: StringFieldUpdateOperationsInput | string
    customerReference?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    companyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    signedUp?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    businessSector?: NullableEnumBusinessSectorFieldUpdateOperationsInput | $Enums.BusinessSector | null
  }

  export type SiteConfigUpdateWithoutAddressInput = {
    siteConfigId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    logoPath?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    iban?: StringFieldUpdateOperationsInput | string
    companyNumber?: StringFieldUpdateOperationsInput | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConfigured?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SiteConfigUncheckedUpdateWithoutAddressInput = {
    siteConfigId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    logoPath?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    iban?: StringFieldUpdateOperationsInput | string
    companyNumber?: StringFieldUpdateOperationsInput | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConfigured?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SiteConfigUncheckedUpdateManyWithoutAddressInput = {
    siteConfigId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    logoPath?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    iban?: StringFieldUpdateOperationsInput | string
    companyNumber?: StringFieldUpdateOperationsInput | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConfigured?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CartOnProductsCreateManyProductInput = {
    cartId: string
    quantity?: number
  }

  export type OrderOnProductsCreateManyProductInput = {
    orderId: string
    orderDate?: Date | string
    productAmount?: number
  }

  export type ProductHistoryCreateManyProductInput = {
    historyId?: string
    name: string
    price: number
    description: string
    stock: number
    imagePath?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string | null
    deleted?: boolean
    categoryId: string
  }

  export type CartOnProductsUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    cart?: CartUpdateOneRequiredWithoutProductsNestedInput
  }

  export type CartOnProductsUncheckedUpdateWithoutProductInput = {
    cartId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type CartOnProductsUncheckedUpdateManyWithoutProductInput = {
    cartId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type OrderOnProductsUpdateWithoutProductInput = {
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    productAmount?: IntFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutProductsNestedInput
  }

  export type OrderOnProductsUncheckedUpdateWithoutProductInput = {
    orderId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    productAmount?: IntFieldUpdateOperationsInput | number
  }

  export type OrderOnProductsUncheckedUpdateManyWithoutProductInput = {
    orderId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    productAmount?: IntFieldUpdateOperationsInput | number
  }

  export type ProductHistoryUpdateWithoutProductInput = {
    historyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    category?: CategoryUpdateOneRequiredWithoutProductHistoryNestedInput
  }

  export type ProductHistoryUncheckedUpdateWithoutProductInput = {
    historyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductHistoryUncheckedUpdateManyWithoutProductInput = {
    historyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCreateManyCategoryInput = {
    productId?: string
    name: string
    price: number
    description: string
    stock: number
    imagePath?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string | null
    deleted?: boolean
  }

  export type ProductHistoryCreateManyCategoryInput = {
    historyId?: string
    productId: string
    name: string
    price: number
    description: string
    stock: number
    imagePath?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string | null
    deleted?: boolean
  }

  export type ProductUpdateWithoutCategoryInput = {
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    carts?: CartOnProductsUpdateManyWithoutProductNestedInput
    orders?: OrderOnProductsUpdateManyWithoutProductNestedInput
    ProductHistory?: ProductHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    carts?: CartOnProductsUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderOnProductsUncheckedUpdateManyWithoutProductNestedInput
    ProductHistory?: ProductHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductHistoryUpdateWithoutCategoryInput = {
    historyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    product?: ProductUpdateOneRequiredWithoutProductHistoryNestedInput
  }

  export type ProductHistoryUncheckedUpdateWithoutCategoryInput = {
    historyId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductHistoryUncheckedUpdateManyWithoutCategoryInput = {
    historyId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrderOnProductsCreateManyOrderInput = {
    productId: string
    orderDate?: Date | string
    productAmount?: number
  }

  export type RoutesOnOrdersCreateManyOrderInput = {
    routeId: string
  }

  export type OrderOnProductsUpdateWithoutOrderInput = {
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    productAmount?: IntFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderOnProductsUncheckedUpdateWithoutOrderInput = {
    productId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    productAmount?: IntFieldUpdateOperationsInput | number
  }

  export type OrderOnProductsUncheckedUpdateManyWithoutOrderInput = {
    productId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    productAmount?: IntFieldUpdateOperationsInput | number
  }

  export type RoutesOnOrdersUpdateWithoutOrderInput = {
    route?: RouteUpdateOneRequiredWithoutOrderNestedInput
  }

  export type RoutesOnOrdersUncheckedUpdateWithoutOrderInput = {
    routeId?: StringFieldUpdateOperationsInput | string
  }

  export type RoutesOnOrdersUncheckedUpdateManyWithoutOrderInput = {
    routeId?: StringFieldUpdateOperationsInput | string
  }

  export type RoutesOnOrdersCreateManyRouteInput = {
    orderId: string
  }

  export type RoutesOnOrdersUpdateWithoutRouteInput = {
    order?: OrderUpdateOneRequiredWithoutRouteNestedInput
  }

  export type RoutesOnOrdersUncheckedUpdateWithoutRouteInput = {
    orderId?: StringFieldUpdateOperationsInput | string
  }

  export type RoutesOnOrdersUncheckedUpdateManyWithoutRouteInput = {
    orderId?: StringFieldUpdateOperationsInput | string
  }

  export type ResourceActionCreateManyActionInput = {
    resource: $Enums.Ressources
  }

  export type ResourceActionUpdateWithoutActionInput = {
    Ressource?: RessourceUpdateOneRequiredWithoutActionLinksNestedInput
    permissions?: PermissionUpdateManyWithoutResourceActionNestedInput
  }

  export type ResourceActionUncheckedUpdateWithoutActionInput = {
    resource?: EnumRessourcesFieldUpdateOperationsInput | $Enums.Ressources
    permissions?: PermissionUncheckedUpdateManyWithoutResourceActionNestedInput
  }

  export type ResourceActionUncheckedUpdateManyWithoutActionInput = {
    resource?: EnumRessourcesFieldUpdateOperationsInput | $Enums.Ressources
  }

  export type ResourceActionCreateManyRessourceInput = {
    action: $Enums.Actions
  }

  export type ResourceActionUpdateWithoutRessourceInput = {
    Action?: ActionUpdateOneRequiredWithoutResourceLinksNestedInput
    permissions?: PermissionUpdateManyWithoutResourceActionNestedInput
  }

  export type ResourceActionUncheckedUpdateWithoutRessourceInput = {
    action?: EnumActionsFieldUpdateOperationsInput | $Enums.Actions
    permissions?: PermissionUncheckedUpdateManyWithoutResourceActionNestedInput
  }

  export type ResourceActionUncheckedUpdateManyWithoutRessourceInput = {
    action?: EnumActionsFieldUpdateOperationsInput | $Enums.Actions
  }

  export type PermissionCreateManyResourceActionInput = {
    id?: string
    role: string
    allowed?: boolean
    createdAt?: Date | string
  }

  export type PermissionUpdateWithoutResourceActionInput = {
    id?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type PermissionUncheckedUpdateWithoutResourceActionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyWithoutResourceActionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeesCreateManyRoleInput = {
    employeeId?: string
    email: string
    password: string
    firstName: string
    lastName: string
    deleted?: boolean
  }

  export type PermissionCreateManyRoleInput = {
    id?: string
    action: $Enums.Actions
    resource: $Enums.Ressources
    allowed?: boolean
    createdAt?: Date | string
  }

  export type EmployeesUpdateWithoutRoleInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmployeesUncheckedUpdateWithoutRoleInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmployeesUncheckedUpdateManyWithoutRoleInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PermissionUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resourceAction?: ResourceActionUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type PermissionUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActionsFieldUpdateOperationsInput | $Enums.Actions
    resource?: EnumRessourcesFieldUpdateOperationsInput | $Enums.Ressources
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActionsFieldUpdateOperationsInput | $Enums.Actions
    resource?: EnumRessourcesFieldUpdateOperationsInput | $Enums.Ressources
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}